// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACE_ACE_H_
#define FLATBUFFERS_GENERATED_ACE_ACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "caffe_op_generated.h"
#include "extra_info_generated.h"
#include "tensorflow_op_generated.h"
#include "tf_quantize_op_generated.h"
#include "user_define_generated.h"

namespace ace {

struct Plugin;
struct PluginBuilder;
struct PluginT;

struct Extra;
struct ExtraBuilder;
struct ExtraT;

struct StringVec;
struct StringVecBuilder;
struct StringVecT;

struct WhileParam;
struct WhileParamBuilder;
struct WhileParamT;

struct IfParam;
struct IfParamBuilder;
struct IfParamT;

struct RegionCommand;
struct RegionCommandBuilder;
struct RegionCommandT;

struct LoopParam;
struct LoopParamBuilder;
struct LoopParamT;

struct Op;
struct OpBuilder;
struct OpT;

struct View;
struct ViewBuilder;
struct ViewT;

struct Region;
struct RegionBuilder;
struct RegionT;

struct TensorDescribe;
struct TensorDescribeBuilder;
struct TensorDescribeT;

struct SubGraphProto;
struct SubGraphProtoBuilder;
struct SubGraphProtoT;

struct TensorQuantInfo;
struct TensorQuantInfoBuilder;
struct TensorQuantInfoT;

struct Net;
struct NetBuilder;
struct NetT;

inline const flatbuffers::TypeTable *PluginTypeTable();

inline const flatbuffers::TypeTable *ExtraTypeTable();

inline const flatbuffers::TypeTable *StringVecTypeTable();

inline const flatbuffers::TypeTable *WhileParamTypeTable();

inline const flatbuffers::TypeTable *IfParamTypeTable();

inline const flatbuffers::TypeTable *RegionCommandTypeTable();

inline const flatbuffers::TypeTable *LoopParamTypeTable();

inline const flatbuffers::TypeTable *OpTypeTable();

inline const flatbuffers::TypeTable *ViewTypeTable();

inline const flatbuffers::TypeTable *RegionTypeTable();

inline const flatbuffers::TypeTable *TensorDescribeTypeTable();

inline const flatbuffers::TypeTable *SubGraphProtoTypeTable();

inline const flatbuffers::TypeTable *TensorQuantInfoTypeTable();

inline const flatbuffers::TypeTable *NetTypeTable();

enum OpType : int32_t {
  OpType_AbsVal = 0,
  OpType_QuantizedAdd = 1,
  OpType_ArgMax = 2,
  OpType_AsString = 3,
  OpType_InstanceNorm = 4,
  OpType_BatchToSpaceND = 5,
  OpType_Copy = 6,
  OpType_BinaryOp = 7,
  OpType_Bnll = 8,
  OpType_Cast = 9,
  OpType_Concat = 10,
  OpType_Const = 11,
  OpType_Convolution = 12,
  OpType_ConvolutionDepthwise = 13,
  OpType_Crop = 14,
  OpType_CropAndResize = 15,
  OpType_ImageProcess = 16,
  OpType_Deconvolution = 17,
  OpType_DeconvolutionDepthwise = 18,
  OpType_Dequantize = 19,
  OpType_DetectionOutput = 20,
  OpType_Dropout = 21,
  OpType_Eltwise = 22,
  OpType_ELU = 23,
  OpType_Unique = 24,
  OpType_Exp = 25,
  OpType_ExpandDims = 26,
  OpType_Fill = 27,
  OpType_Flatten = 28,
  OpType_Im2Col = 29,
  OpType_Gather = 30,
  OpType_GatherV2 = 31,
  OpType_Im2Seq = 32,
  OpType_InnerProduct = 33,
  OpType_Input = 34,
  OpType_Interp = 35,
  OpType_Log = 36,
  OpType_LRN = 37,
  OpType_LSTM = 38,
  OpType_MatMul = 39,
  OpType_MVN = 40,
  OpType_NonMaxSuppression = 41,
  OpType_NonMaxSuppressionV2 = 42,
  OpType_Normalize = 43,
  OpType_Pack = 44,
  OpType_Padding = 45,
  OpType_Permute = 46,
  OpType_Pooling = 47,
  OpType_Power = 48,
  OpType_PReLU = 49,
  OpType_PriorBox = 50,
  OpType_Proposal = 51,
  OpType_QuantizedAvgPool = 52,
  OpType_QuantizedBiasAdd = 53,
  OpType_QuantizedConcat = 54,
  OpType_QuantizedDepthwiseConv2D = 55,
  OpType_QuantizedLogistic = 56,
  OpType_QuantizedMatMul = 57,
  OpType_QuantizedMaxPool = 58,
  OpType_QuantizedRelu = 59,
  OpType_QuantizedRelu6 = 60,
  OpType_QuantizedReshape = 61,
  OpType_QuantizedSoftmax = 62,
  OpType_QuantizeMaxMin = 63,
  OpType_QuantizeV2 = 64,
  OpType_Range = 65,
  OpType_Rank = 66,
  OpType_ReduceJoin = 67,
  OpType_Reduction = 68,
  OpType_ReLU = 69,
  OpType_ReLU6 = 70,
  OpType_RequantizationRange = 71,
  OpType_Requantize = 72,
  OpType_Reshape = 73,
  OpType_Resize = 74,
  OpType_RNN = 75,
  OpType_ROIPooling = 76,
  OpType_Scale = 77,
  OpType_Selu = 78,
  OpType_Seq2Out = 79,
  OpType_Shape = 80,
  OpType_Sigmoid = 81,
  OpType_Size = 82,
  OpType_Slice = 83,
  OpType_SliceTf = 84,
  OpType_Softmax = 85,
  OpType_SpaceToBatchND = 86,
  OpType_SpatialProduct = 87,
  OpType_Col2Im = 88,
  OpType_Segment = 89,
  OpType_Squeeze = 90,
  OpType_StridedSlice = 91,
  OpType_StringJoin = 92,
  OpType_StringSplit = 93,
  OpType_StringToNumber = 94,
  OpType_TanH = 95,
  OpType_TfQuantizedConv2D = 96,
  OpType_Threshold = 97,
  OpType_Tile = 98,
  OpType_TopKV2 = 99,
  OpType_Transpose = 100,
  OpType_UnaryOp = 101,
  OpType_Unpack = 102,
  OpType_Where = 103,
  OpType_Moments = 104,
  OpType_RNNSequenceGRU = 105,
  OpType_BatchMatMul = 106,
  OpType_Unsqueeze = 107,
  OpType_CosineSimilarity = 108,
  OpType_DepthToSpace = 109,
  OpType_SpaceToDepth = 110,
  OpType_ReverseSequence = 111,
  OpType_Pooling3D = 112,
  OpType_Convolution3D = 113,
  OpType_MatrixBandPart = 114,
  OpType_GatherND = 115,
  OpType_DetectionPostProcess = 116,
  OpType_UnravelIndex = 117,
  OpType_ScatterNd = 118,
  OpType_OneHot = 119,
  OpType_BroadcastTo = 120,
  OpType_Dilation2D = 121,
  OpType_Interp3D = 122,
  OpType_Raster = 128,
  OpType_ConvertTensor = 129,
  OpType_ArgMin = 130,
  OpType_LinSpace = 131,
  OpType_RandomUniform = 132,
  OpType_TensorArray = 133,
  OpType_TensorArraySize = 134,
  OpType_TensorArrayRead = 135,
  OpType_TensorArrayWrite = 136,
  OpType_TensorArrayGather = 137,
  OpType_TensorArrayScatter = 138,
  OpType_TensorArraySplit = 139,
  OpType_TensorArrayConcat = 140,
  OpType_LSTMBlockCell = 141,
  OpType_Reverse = 142,
  OpType_ROIAlign = 143,
  OpType_RandomNormal = 144,
  OpType_TensorArrayInsert = 145,
  OpType_TensorArrayErase = 146,
  OpType_EyeLike = 147,
  OpType_CumSum = 148,
  OpType_Det = 149,
  OpType_CumProd = 150,
  OpType_ScatterElements = 151,
  OpType_GatherElements = 152,
  OpType_Svd = 153,
  OpType_Histogram = 154,
  OpType_Plugin = 256,
  OpType_Select = 257,
  OpType_ZerosLike = 258,
  OpType_Broastcast = 259,
  OpType_SetDiff1D = 260,
  OpType_ReluGrad = 261,
  OpType_Identity = 262,
  OpType_PoolGrad = 263,
  OpType_SoftmaxGrad = 264,
  OpType_Conv2DBackPropFilter = 265,
  OpType_TrainableParam = 266,
  OpType_BatchNorm = 267,
  OpType_ConvTranspose3D = 268,
  OpType_ZeroGrad = 269,
  OpType_Extra = 512,
  OpType_ConvInt8 = 513,
  OpType_Int8ToFloat = 514,
  OpType_DepthwiseConvInt8 = 515,
  OpType_PoolInt8 = 516,
  OpType_FloatToInt8 = 517,
  OpType_EltwiseInt8 = 518,
  OpType_While = 600,
  OpType_If = 601,
  OpType_LayerNorm = 603,
  OpType_GridSample = 604,
  OpType_MIN = OpType_AbsVal,
  OpType_MAX = OpType_GridSample
};

inline const OpType (&EnumValuesOpType())[175] {
  static const OpType values[] = {
    OpType_AbsVal,
    OpType_QuantizedAdd,
    OpType_ArgMax,
    OpType_AsString,
    OpType_InstanceNorm,
    OpType_BatchToSpaceND,
    OpType_Copy,
    OpType_BinaryOp,
    OpType_Bnll,
    OpType_Cast,
    OpType_Concat,
    OpType_Const,
    OpType_Convolution,
    OpType_ConvolutionDepthwise,
    OpType_Crop,
    OpType_CropAndResize,
    OpType_ImageProcess,
    OpType_Deconvolution,
    OpType_DeconvolutionDepthwise,
    OpType_Dequantize,
    OpType_DetectionOutput,
    OpType_Dropout,
    OpType_Eltwise,
    OpType_ELU,
    OpType_Unique,
    OpType_Exp,
    OpType_ExpandDims,
    OpType_Fill,
    OpType_Flatten,
    OpType_Im2Col,
    OpType_Gather,
    OpType_GatherV2,
    OpType_Im2Seq,
    OpType_InnerProduct,
    OpType_Input,
    OpType_Interp,
    OpType_Log,
    OpType_LRN,
    OpType_LSTM,
    OpType_MatMul,
    OpType_MVN,
    OpType_NonMaxSuppression,
    OpType_NonMaxSuppressionV2,
    OpType_Normalize,
    OpType_Pack,
    OpType_Padding,
    OpType_Permute,
    OpType_Pooling,
    OpType_Power,
    OpType_PReLU,
    OpType_PriorBox,
    OpType_Proposal,
    OpType_QuantizedAvgPool,
    OpType_QuantizedBiasAdd,
    OpType_QuantizedConcat,
    OpType_QuantizedDepthwiseConv2D,
    OpType_QuantizedLogistic,
    OpType_QuantizedMatMul,
    OpType_QuantizedMaxPool,
    OpType_QuantizedRelu,
    OpType_QuantizedRelu6,
    OpType_QuantizedReshape,
    OpType_QuantizedSoftmax,
    OpType_QuantizeMaxMin,
    OpType_QuantizeV2,
    OpType_Range,
    OpType_Rank,
    OpType_ReduceJoin,
    OpType_Reduction,
    OpType_ReLU,
    OpType_ReLU6,
    OpType_RequantizationRange,
    OpType_Requantize,
    OpType_Reshape,
    OpType_Resize,
    OpType_RNN,
    OpType_ROIPooling,
    OpType_Scale,
    OpType_Selu,
    OpType_Seq2Out,
    OpType_Shape,
    OpType_Sigmoid,
    OpType_Size,
    OpType_Slice,
    OpType_SliceTf,
    OpType_Softmax,
    OpType_SpaceToBatchND,
    OpType_SpatialProduct,
    OpType_Col2Im,
    OpType_Segment,
    OpType_Squeeze,
    OpType_StridedSlice,
    OpType_StringJoin,
    OpType_StringSplit,
    OpType_StringToNumber,
    OpType_TanH,
    OpType_TfQuantizedConv2D,
    OpType_Threshold,
    OpType_Tile,
    OpType_TopKV2,
    OpType_Transpose,
    OpType_UnaryOp,
    OpType_Unpack,
    OpType_Where,
    OpType_Moments,
    OpType_RNNSequenceGRU,
    OpType_BatchMatMul,
    OpType_Unsqueeze,
    OpType_CosineSimilarity,
    OpType_DepthToSpace,
    OpType_SpaceToDepth,
    OpType_ReverseSequence,
    OpType_Pooling3D,
    OpType_Convolution3D,
    OpType_MatrixBandPart,
    OpType_GatherND,
    OpType_DetectionPostProcess,
    OpType_UnravelIndex,
    OpType_ScatterNd,
    OpType_OneHot,
    OpType_BroadcastTo,
    OpType_Dilation2D,
    OpType_Interp3D,
    OpType_Raster,
    OpType_ConvertTensor,
    OpType_ArgMin,
    OpType_LinSpace,
    OpType_RandomUniform,
    OpType_TensorArray,
    OpType_TensorArraySize,
    OpType_TensorArrayRead,
    OpType_TensorArrayWrite,
    OpType_TensorArrayGather,
    OpType_TensorArrayScatter,
    OpType_TensorArraySplit,
    OpType_TensorArrayConcat,
    OpType_LSTMBlockCell,
    OpType_Reverse,
    OpType_ROIAlign,
    OpType_RandomNormal,
    OpType_TensorArrayInsert,
    OpType_TensorArrayErase,
    OpType_EyeLike,
    OpType_CumSum,
    OpType_Det,
    OpType_CumProd,
    OpType_ScatterElements,
    OpType_GatherElements,
    OpType_Svd,
    OpType_Histogram,
    OpType_Plugin,
    OpType_Select,
    OpType_ZerosLike,
    OpType_Broastcast,
    OpType_SetDiff1D,
    OpType_ReluGrad,
    OpType_Identity,
    OpType_PoolGrad,
    OpType_SoftmaxGrad,
    OpType_Conv2DBackPropFilter,
    OpType_TrainableParam,
    OpType_BatchNorm,
    OpType_ConvTranspose3D,
    OpType_ZeroGrad,
    OpType_Extra,
    OpType_ConvInt8,
    OpType_Int8ToFloat,
    OpType_DepthwiseConvInt8,
    OpType_PoolInt8,
    OpType_FloatToInt8,
    OpType_EltwiseInt8,
    OpType_While,
    OpType_If,
    OpType_LayerNorm,
    OpType_GridSample
  };
  return values;
}

inline const char * const *EnumNamesOpType() {
  static const char * const names[606] = {
    "AbsVal",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "InstanceNorm",
    "BatchToSpaceND",
    "Copy",
    "BinaryOp",
    "Bnll",
    "Cast",
    "Concat",
    "Const",
    "Convolution",
    "ConvolutionDepthwise",
    "Crop",
    "CropAndResize",
    "ImageProcess",
    "Deconvolution",
    "DeconvolutionDepthwise",
    "Dequantize",
    "DetectionOutput",
    "Dropout",
    "Eltwise",
    "ELU",
    "Unique",
    "Exp",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Im2Col",
    "Gather",
    "GatherV2",
    "Im2Seq",
    "InnerProduct",
    "Input",
    "Interp",
    "Log",
    "LRN",
    "LSTM",
    "MatMul",
    "MVN",
    "NonMaxSuppression",
    "NonMaxSuppressionV2",
    "Normalize",
    "Pack",
    "Padding",
    "Permute",
    "Pooling",
    "Power",
    "PReLU",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedDepthwiseConv2D",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "Reduction",
    "ReLU",
    "ReLU6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RNN",
    "ROIPooling",
    "Scale",
    "Selu",
    "Seq2Out",
    "Shape",
    "Sigmoid",
    "Size",
    "Slice",
    "SliceTf",
    "Softmax",
    "SpaceToBatchND",
    "SpatialProduct",
    "Col2Im",
    "Segment",
    "Squeeze",
    "StridedSlice",
    "StringJoin",
    "StringSplit",
    "StringToNumber",
    "TanH",
    "TfQuantizedConv2D",
    "Threshold",
    "Tile",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "Unpack",
    "Where",
    "Moments",
    "RNNSequenceGRU",
    "BatchMatMul",
    "Unsqueeze",
    "CosineSimilarity",
    "DepthToSpace",
    "SpaceToDepth",
    "ReverseSequence",
    "Pooling3D",
    "Convolution3D",
    "MatrixBandPart",
    "GatherND",
    "DetectionPostProcess",
    "UnravelIndex",
    "ScatterNd",
    "OneHot",
    "BroadcastTo",
    "Dilation2D",
    "Interp3D",
    "",
    "",
    "",
    "",
    "",
    "Raster",
    "ConvertTensor",
    "ArgMin",
    "LinSpace",
    "RandomUniform",
    "TensorArray",
    "TensorArraySize",
    "TensorArrayRead",
    "TensorArrayWrite",
    "TensorArrayGather",
    "TensorArrayScatter",
    "TensorArraySplit",
    "TensorArrayConcat",
    "LSTMBlockCell",
    "Reverse",
    "ROIAlign",
    "RandomNormal",
    "TensorArrayInsert",
    "TensorArrayErase",
    "EyeLike",
    "CumSum",
    "Det",
    "CumProd",
    "ScatterElements",
    "GatherElements",
    "Svd",
    "Histogram",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Plugin",
    "Select",
    "ZerosLike",
    "Broastcast",
    "SetDiff1D",
    "ReluGrad",
    "Identity",
    "PoolGrad",
    "SoftmaxGrad",
    "Conv2DBackPropFilter",
    "TrainableParam",
    "BatchNorm",
    "ConvTranspose3D",
    "ZeroGrad",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Extra",
    "ConvInt8",
    "Int8ToFloat",
    "DepthwiseConvInt8",
    "PoolInt8",
    "FloatToInt8",
    "EltwiseInt8",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "While",
    "If",
    "",
    "LayerNorm",
    "GridSample",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpType(OpType e) {
  if (flatbuffers::IsOutRange(e, OpType_AbsVal, OpType_GridSample)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpType()[index];
}

enum OpParameter : uint8_t {
  OpParameter_NONE = 0,
  OpParameter_QuantizedAdd = 1,
  OpParameter_ArgMax = 2,
  OpParameter_AsString = 3,
  OpParameter_Axis = 4,
  OpParameter_BatchNorm = 5,
  OpParameter_BinaryOp = 6,
  OpParameter_Blob = 7,
  OpParameter_CastParam = 8,
  OpParameter_Convolution2D = 9,
  OpParameter_Crop = 10,
  OpParameter_CropAndResize = 11,
  OpParameter_Dequantize = 12,
  OpParameter_DetectionOutput = 13,
  OpParameter_Eltwise = 14,
  OpParameter_ExpandDims = 15,
  OpParameter_Fill = 16,
  OpParameter_Flatten = 17,
  OpParameter_Gather = 18,
  OpParameter_GatherV2 = 19,
  OpParameter_InnerProduct = 20,
  OpParameter_Input = 21,
  OpParameter_Interp = 22,
  OpParameter_LRN = 23,
  OpParameter_LSTM = 24,
  OpParameter_MatMul = 25,
  OpParameter_NonMaxSuppressionV2 = 26,
  OpParameter_Normalize = 27,
  OpParameter_PackParam = 28,
  OpParameter_Permute = 29,
  OpParameter_Plugin = 30,
  OpParameter_Pool = 31,
  OpParameter_PRelu = 32,
  OpParameter_PriorBox = 33,
  OpParameter_Proposal = 34,
  OpParameter_QuantizedAvgPool = 35,
  OpParameter_QuantizedBiasAdd = 36,
  OpParameter_QuantizedConcat = 37,
  OpParameter_QuantizedLogistic = 38,
  OpParameter_QuantizedMatMul = 39,
  OpParameter_QuantizedMaxPool = 40,
  OpParameter_QuantizedRelu = 41,
  OpParameter_QuantizedRelu6 = 42,
  OpParameter_QuantizedReshape = 43,
  OpParameter_QuantizedSoftmax = 44,
  OpParameter_QuantizeMaxMin = 45,
  OpParameter_QuantizeV2 = 46,
  OpParameter_Range = 47,
  OpParameter_Rank = 48,
  OpParameter_ReduceJoin = 49,
  OpParameter_ReductionParam = 50,
  OpParameter_Relu = 51,
  OpParameter_Relu6 = 52,
  OpParameter_RequantizationRange = 53,
  OpParameter_Requantize = 54,
  OpParameter_Reshape = 55,
  OpParameter_Resize = 56,
  OpParameter_RoiParameters = 57,
  OpParameter_Scale = 58,
  OpParameter_Selu = 59,
  OpParameter_Size = 60,
  OpParameter_Slice = 61,
  OpParameter_SliceTf = 62,
  OpParameter_SpaceBatch = 63,
  OpParameter_SqueezeParam = 64,
  OpParameter_StridedSliceParam = 65,
  OpParameter_TensorConvertInfo = 66,
  OpParameter_TfQuantizedConv2D = 67,
  OpParameter_TopKV2 = 68,
  OpParameter_Transpose = 69,
  OpParameter_UnaryOp = 70,
  OpParameter_MomentsParam = 71,
  OpParameter_RNNParam = 72,
  OpParameter_BatchMatMulParam = 73,
  OpParameter_QuantizedFloatParam = 74,
  OpParameter_DepthSpaceParam = 75,
  OpParameter_EltwiseInt8 = 76,
  OpParameter_ReverseSequenceParam = 77,
  OpParameter_Extra = 78,
  OpParameter_Pool3D = 79,
  OpParameter_Convolution3D = 80,
  OpParameter_ELU = 81,
  OpParameter_DetectionPostProcessParam = 82,
  OpParameter_OneHotParam = 83,
  OpParameter_PadParam = 84,
  OpParameter_WhileParam = 85,
  OpParameter_IfParam = 86,
  OpParameter_RandomUniform = 87,
  OpParameter_LayerNorm = 88,
  OpParameter_TensorArray = 89,
  OpParameter_LSTMBlockCell = 90,
  OpParameter_GridSample = 91,
  OpParameter_LoopParam = 92,
  OpParameter_ImageProcessParam = 93,
  OpParameter_CumSum = 94,
  OpParameter_MIN = OpParameter_NONE,
  OpParameter_MAX = OpParameter_CumSum
};

inline const OpParameter (&EnumValuesOpParameter())[95] {
  static const OpParameter values[] = {
    OpParameter_NONE,
    OpParameter_QuantizedAdd,
    OpParameter_ArgMax,
    OpParameter_AsString,
    OpParameter_Axis,
    OpParameter_BatchNorm,
    OpParameter_BinaryOp,
    OpParameter_Blob,
    OpParameter_CastParam,
    OpParameter_Convolution2D,
    OpParameter_Crop,
    OpParameter_CropAndResize,
    OpParameter_Dequantize,
    OpParameter_DetectionOutput,
    OpParameter_Eltwise,
    OpParameter_ExpandDims,
    OpParameter_Fill,
    OpParameter_Flatten,
    OpParameter_Gather,
    OpParameter_GatherV2,
    OpParameter_InnerProduct,
    OpParameter_Input,
    OpParameter_Interp,
    OpParameter_LRN,
    OpParameter_LSTM,
    OpParameter_MatMul,
    OpParameter_NonMaxSuppressionV2,
    OpParameter_Normalize,
    OpParameter_PackParam,
    OpParameter_Permute,
    OpParameter_Plugin,
    OpParameter_Pool,
    OpParameter_PRelu,
    OpParameter_PriorBox,
    OpParameter_Proposal,
    OpParameter_QuantizedAvgPool,
    OpParameter_QuantizedBiasAdd,
    OpParameter_QuantizedConcat,
    OpParameter_QuantizedLogistic,
    OpParameter_QuantizedMatMul,
    OpParameter_QuantizedMaxPool,
    OpParameter_QuantizedRelu,
    OpParameter_QuantizedRelu6,
    OpParameter_QuantizedReshape,
    OpParameter_QuantizedSoftmax,
    OpParameter_QuantizeMaxMin,
    OpParameter_QuantizeV2,
    OpParameter_Range,
    OpParameter_Rank,
    OpParameter_ReduceJoin,
    OpParameter_ReductionParam,
    OpParameter_Relu,
    OpParameter_Relu6,
    OpParameter_RequantizationRange,
    OpParameter_Requantize,
    OpParameter_Reshape,
    OpParameter_Resize,
    OpParameter_RoiParameters,
    OpParameter_Scale,
    OpParameter_Selu,
    OpParameter_Size,
    OpParameter_Slice,
    OpParameter_SliceTf,
    OpParameter_SpaceBatch,
    OpParameter_SqueezeParam,
    OpParameter_StridedSliceParam,
    OpParameter_TensorConvertInfo,
    OpParameter_TfQuantizedConv2D,
    OpParameter_TopKV2,
    OpParameter_Transpose,
    OpParameter_UnaryOp,
    OpParameter_MomentsParam,
    OpParameter_RNNParam,
    OpParameter_BatchMatMulParam,
    OpParameter_QuantizedFloatParam,
    OpParameter_DepthSpaceParam,
    OpParameter_EltwiseInt8,
    OpParameter_ReverseSequenceParam,
    OpParameter_Extra,
    OpParameter_Pool3D,
    OpParameter_Convolution3D,
    OpParameter_ELU,
    OpParameter_DetectionPostProcessParam,
    OpParameter_OneHotParam,
    OpParameter_PadParam,
    OpParameter_WhileParam,
    OpParameter_IfParam,
    OpParameter_RandomUniform,
    OpParameter_LayerNorm,
    OpParameter_TensorArray,
    OpParameter_LSTMBlockCell,
    OpParameter_GridSample,
    OpParameter_LoopParam,
    OpParameter_ImageProcessParam,
    OpParameter_CumSum
  };
  return values;
}

inline const char * const *EnumNamesOpParameter() {
  static const char * const names[96] = {
    "NONE",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "Axis",
    "BatchNorm",
    "BinaryOp",
    "Blob",
    "CastParam",
    "Convolution2D",
    "Crop",
    "CropAndResize",
    "Dequantize",
    "DetectionOutput",
    "Eltwise",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Gather",
    "GatherV2",
    "InnerProduct",
    "Input",
    "Interp",
    "LRN",
    "LSTM",
    "MatMul",
    "NonMaxSuppressionV2",
    "Normalize",
    "PackParam",
    "Permute",
    "Plugin",
    "Pool",
    "PRelu",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "ReductionParam",
    "Relu",
    "Relu6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RoiParameters",
    "Scale",
    "Selu",
    "Size",
    "Slice",
    "SliceTf",
    "SpaceBatch",
    "SqueezeParam",
    "StridedSliceParam",
    "TensorConvertInfo",
    "TfQuantizedConv2D",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "MomentsParam",
    "RNNParam",
    "BatchMatMulParam",
    "QuantizedFloatParam",
    "DepthSpaceParam",
    "EltwiseInt8",
    "ReverseSequenceParam",
    "Extra",
    "Pool3D",
    "Convolution3D",
    "ELU",
    "DetectionPostProcessParam",
    "OneHotParam",
    "PadParam",
    "WhileParam",
    "IfParam",
    "RandomUniform",
    "LayerNorm",
    "TensorArray",
    "LSTMBlockCell",
    "GridSample",
    "LoopParam",
    "ImageProcessParam",
    "CumSum",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParameter(OpParameter e) {
  if (flatbuffers::IsOutRange(e, OpParameter_NONE, OpParameter_CumSum)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpParameter()[index];
}

template<typename T> struct OpParameterTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterTraits<ace::QuantizedAdd> {
  static const OpParameter enum_value = OpParameter_QuantizedAdd;
};

template<> struct OpParameterTraits<ace::ArgMax> {
  static const OpParameter enum_value = OpParameter_ArgMax;
};

template<> struct OpParameterTraits<ace::AsString> {
  static const OpParameter enum_value = OpParameter_AsString;
};

template<> struct OpParameterTraits<ace::Axis> {
  static const OpParameter enum_value = OpParameter_Axis;
};

template<> struct OpParameterTraits<ace::BatchNorm> {
  static const OpParameter enum_value = OpParameter_BatchNorm;
};

template<> struct OpParameterTraits<ace::BinaryOp> {
  static const OpParameter enum_value = OpParameter_BinaryOp;
};

template<> struct OpParameterTraits<ace::Blob> {
  static const OpParameter enum_value = OpParameter_Blob;
};

template<> struct OpParameterTraits<ace::CastParam> {
  static const OpParameter enum_value = OpParameter_CastParam;
};

template<> struct OpParameterTraits<ace::Convolution2D> {
  static const OpParameter enum_value = OpParameter_Convolution2D;
};

template<> struct OpParameterTraits<ace::Crop> {
  static const OpParameter enum_value = OpParameter_Crop;
};

template<> struct OpParameterTraits<ace::CropAndResize> {
  static const OpParameter enum_value = OpParameter_CropAndResize;
};

template<> struct OpParameterTraits<ace::Dequantize> {
  static const OpParameter enum_value = OpParameter_Dequantize;
};

template<> struct OpParameterTraits<ace::DetectionOutput> {
  static const OpParameter enum_value = OpParameter_DetectionOutput;
};

template<> struct OpParameterTraits<ace::Eltwise> {
  static const OpParameter enum_value = OpParameter_Eltwise;
};

template<> struct OpParameterTraits<ace::ExpandDims> {
  static const OpParameter enum_value = OpParameter_ExpandDims;
};

template<> struct OpParameterTraits<ace::Fill> {
  static const OpParameter enum_value = OpParameter_Fill;
};

template<> struct OpParameterTraits<ace::Flatten> {
  static const OpParameter enum_value = OpParameter_Flatten;
};

template<> struct OpParameterTraits<ace::Gather> {
  static const OpParameter enum_value = OpParameter_Gather;
};

template<> struct OpParameterTraits<ace::GatherV2> {
  static const OpParameter enum_value = OpParameter_GatherV2;
};

template<> struct OpParameterTraits<ace::InnerProduct> {
  static const OpParameter enum_value = OpParameter_InnerProduct;
};

template<> struct OpParameterTraits<ace::Input> {
  static const OpParameter enum_value = OpParameter_Input;
};

template<> struct OpParameterTraits<ace::Interp> {
  static const OpParameter enum_value = OpParameter_Interp;
};

template<> struct OpParameterTraits<ace::LRN> {
  static const OpParameter enum_value = OpParameter_LRN;
};

template<> struct OpParameterTraits<ace::LSTM> {
  static const OpParameter enum_value = OpParameter_LSTM;
};

template<> struct OpParameterTraits<ace::MatMul> {
  static const OpParameter enum_value = OpParameter_MatMul;
};

template<> struct OpParameterTraits<ace::NonMaxSuppressionV2> {
  static const OpParameter enum_value = OpParameter_NonMaxSuppressionV2;
};

template<> struct OpParameterTraits<ace::Normalize> {
  static const OpParameter enum_value = OpParameter_Normalize;
};

template<> struct OpParameterTraits<ace::PackParam> {
  static const OpParameter enum_value = OpParameter_PackParam;
};

template<> struct OpParameterTraits<ace::Permute> {
  static const OpParameter enum_value = OpParameter_Permute;
};

template<> struct OpParameterTraits<ace::Plugin> {
  static const OpParameter enum_value = OpParameter_Plugin;
};

template<> struct OpParameterTraits<ace::Pool> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<> struct OpParameterTraits<ace::PRelu> {
  static const OpParameter enum_value = OpParameter_PRelu;
};

template<> struct OpParameterTraits<ace::PriorBox> {
  static const OpParameter enum_value = OpParameter_PriorBox;
};

template<> struct OpParameterTraits<ace::Proposal> {
  static const OpParameter enum_value = OpParameter_Proposal;
};

template<> struct OpParameterTraits<ace::QuantizedAvgPool> {
  static const OpParameter enum_value = OpParameter_QuantizedAvgPool;
};

template<> struct OpParameterTraits<ace::QuantizedBiasAdd> {
  static const OpParameter enum_value = OpParameter_QuantizedBiasAdd;
};

template<> struct OpParameterTraits<ace::QuantizedConcat> {
  static const OpParameter enum_value = OpParameter_QuantizedConcat;
};

template<> struct OpParameterTraits<ace::QuantizedLogistic> {
  static const OpParameter enum_value = OpParameter_QuantizedLogistic;
};

template<> struct OpParameterTraits<ace::QuantizedMatMul> {
  static const OpParameter enum_value = OpParameter_QuantizedMatMul;
};

template<> struct OpParameterTraits<ace::QuantizedMaxPool> {
  static const OpParameter enum_value = OpParameter_QuantizedMaxPool;
};

template<> struct OpParameterTraits<ace::QuantizedRelu> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu;
};

template<> struct OpParameterTraits<ace::QuantizedRelu6> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu6;
};

template<> struct OpParameterTraits<ace::QuantizedReshape> {
  static const OpParameter enum_value = OpParameter_QuantizedReshape;
};

template<> struct OpParameterTraits<ace::QuantizedSoftmax> {
  static const OpParameter enum_value = OpParameter_QuantizedSoftmax;
};

template<> struct OpParameterTraits<ace::QuantizeMaxMin> {
  static const OpParameter enum_value = OpParameter_QuantizeMaxMin;
};

template<> struct OpParameterTraits<ace::QuantizeV2> {
  static const OpParameter enum_value = OpParameter_QuantizeV2;
};

template<> struct OpParameterTraits<ace::Range> {
  static const OpParameter enum_value = OpParameter_Range;
};

template<> struct OpParameterTraits<ace::Rank> {
  static const OpParameter enum_value = OpParameter_Rank;
};

template<> struct OpParameterTraits<ace::ReduceJoin> {
  static const OpParameter enum_value = OpParameter_ReduceJoin;
};

template<> struct OpParameterTraits<ace::ReductionParam> {
  static const OpParameter enum_value = OpParameter_ReductionParam;
};

template<> struct OpParameterTraits<ace::Relu> {
  static const OpParameter enum_value = OpParameter_Relu;
};

template<> struct OpParameterTraits<ace::Relu6> {
  static const OpParameter enum_value = OpParameter_Relu6;
};

template<> struct OpParameterTraits<ace::RequantizationRange> {
  static const OpParameter enum_value = OpParameter_RequantizationRange;
};

template<> struct OpParameterTraits<ace::Requantize> {
  static const OpParameter enum_value = OpParameter_Requantize;
};

template<> struct OpParameterTraits<ace::Reshape> {
  static const OpParameter enum_value = OpParameter_Reshape;
};

template<> struct OpParameterTraits<ace::Resize> {
  static const OpParameter enum_value = OpParameter_Resize;
};

template<> struct OpParameterTraits<ace::RoiParameters> {
  static const OpParameter enum_value = OpParameter_RoiParameters;
};

template<> struct OpParameterTraits<ace::Scale> {
  static const OpParameter enum_value = OpParameter_Scale;
};

template<> struct OpParameterTraits<ace::Selu> {
  static const OpParameter enum_value = OpParameter_Selu;
};

template<> struct OpParameterTraits<ace::Size> {
  static const OpParameter enum_value = OpParameter_Size;
};

template<> struct OpParameterTraits<ace::Slice> {
  static const OpParameter enum_value = OpParameter_Slice;
};

template<> struct OpParameterTraits<ace::SliceTf> {
  static const OpParameter enum_value = OpParameter_SliceTf;
};

template<> struct OpParameterTraits<ace::SpaceBatch> {
  static const OpParameter enum_value = OpParameter_SpaceBatch;
};

template<> struct OpParameterTraits<ace::SqueezeParam> {
  static const OpParameter enum_value = OpParameter_SqueezeParam;
};

template<> struct OpParameterTraits<ace::StridedSliceParam> {
  static const OpParameter enum_value = OpParameter_StridedSliceParam;
};

template<> struct OpParameterTraits<ace::TensorConvertInfo> {
  static const OpParameter enum_value = OpParameter_TensorConvertInfo;
};

template<> struct OpParameterTraits<ace::TfQuantizedConv2D> {
  static const OpParameter enum_value = OpParameter_TfQuantizedConv2D;
};

template<> struct OpParameterTraits<ace::TopKV2> {
  static const OpParameter enum_value = OpParameter_TopKV2;
};

template<> struct OpParameterTraits<ace::Transpose> {
  static const OpParameter enum_value = OpParameter_Transpose;
};

template<> struct OpParameterTraits<ace::UnaryOp> {
  static const OpParameter enum_value = OpParameter_UnaryOp;
};

template<> struct OpParameterTraits<ace::MomentsParam> {
  static const OpParameter enum_value = OpParameter_MomentsParam;
};

template<> struct OpParameterTraits<ace::RNNParam> {
  static const OpParameter enum_value = OpParameter_RNNParam;
};

template<> struct OpParameterTraits<ace::BatchMatMulParam> {
  static const OpParameter enum_value = OpParameter_BatchMatMulParam;
};

template<> struct OpParameterTraits<ace::QuantizedFloatParam> {
  static const OpParameter enum_value = OpParameter_QuantizedFloatParam;
};

template<> struct OpParameterTraits<ace::DepthSpaceParam> {
  static const OpParameter enum_value = OpParameter_DepthSpaceParam;
};

template<> struct OpParameterTraits<ace::EltwiseInt8> {
  static const OpParameter enum_value = OpParameter_EltwiseInt8;
};

template<> struct OpParameterTraits<ace::ReverseSequenceParam> {
  static const OpParameter enum_value = OpParameter_ReverseSequenceParam;
};

template<> struct OpParameterTraits<ace::Extra> {
  static const OpParameter enum_value = OpParameter_Extra;
};

template<> struct OpParameterTraits<ace::Pool3D> {
  static const OpParameter enum_value = OpParameter_Pool3D;
};

template<> struct OpParameterTraits<ace::Convolution3D> {
  static const OpParameter enum_value = OpParameter_Convolution3D;
};

template<> struct OpParameterTraits<ace::ELU> {
  static const OpParameter enum_value = OpParameter_ELU;
};

template<> struct OpParameterTraits<ace::DetectionPostProcessParam> {
  static const OpParameter enum_value = OpParameter_DetectionPostProcessParam;
};

template<> struct OpParameterTraits<ace::OneHotParam> {
  static const OpParameter enum_value = OpParameter_OneHotParam;
};

template<> struct OpParameterTraits<ace::PadParam> {
  static const OpParameter enum_value = OpParameter_PadParam;
};

template<> struct OpParameterTraits<ace::WhileParam> {
  static const OpParameter enum_value = OpParameter_WhileParam;
};

template<> struct OpParameterTraits<ace::IfParam> {
  static const OpParameter enum_value = OpParameter_IfParam;
};

template<> struct OpParameterTraits<ace::RandomUniform> {
  static const OpParameter enum_value = OpParameter_RandomUniform;
};

template<> struct OpParameterTraits<ace::LayerNorm> {
  static const OpParameter enum_value = OpParameter_LayerNorm;
};

template<> struct OpParameterTraits<ace::TensorArray> {
  static const OpParameter enum_value = OpParameter_TensorArray;
};

template<> struct OpParameterTraits<ace::LSTMBlockCell> {
  static const OpParameter enum_value = OpParameter_LSTMBlockCell;
};

template<> struct OpParameterTraits<ace::GridSample> {
  static const OpParameter enum_value = OpParameter_GridSample;
};

template<> struct OpParameterTraits<ace::LoopParam> {
  static const OpParameter enum_value = OpParameter_LoopParam;
};

template<> struct OpParameterTraits<ace::ImageProcessParam> {
  static const OpParameter enum_value = OpParameter_ImageProcessParam;
};

template<> struct OpParameterTraits<ace::CumSum> {
  static const OpParameter enum_value = OpParameter_CumSum;
};

template<typename T> struct OpParameterUnionTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterUnionTraits<ace::QuantizedAddT> {
  static const OpParameter enum_value = OpParameter_QuantizedAdd;
};

template<> struct OpParameterUnionTraits<ace::ArgMaxT> {
  static const OpParameter enum_value = OpParameter_ArgMax;
};

template<> struct OpParameterUnionTraits<ace::AsStringT> {
  static const OpParameter enum_value = OpParameter_AsString;
};

template<> struct OpParameterUnionTraits<ace::AxisT> {
  static const OpParameter enum_value = OpParameter_Axis;
};

template<> struct OpParameterUnionTraits<ace::BatchNormT> {
  static const OpParameter enum_value = OpParameter_BatchNorm;
};

template<> struct OpParameterUnionTraits<ace::BinaryOpT> {
  static const OpParameter enum_value = OpParameter_BinaryOp;
};

template<> struct OpParameterUnionTraits<ace::BlobT> {
  static const OpParameter enum_value = OpParameter_Blob;
};

template<> struct OpParameterUnionTraits<ace::CastParamT> {
  static const OpParameter enum_value = OpParameter_CastParam;
};

template<> struct OpParameterUnionTraits<ace::Convolution2DT> {
  static const OpParameter enum_value = OpParameter_Convolution2D;
};

template<> struct OpParameterUnionTraits<ace::CropT> {
  static const OpParameter enum_value = OpParameter_Crop;
};

template<> struct OpParameterUnionTraits<ace::CropAndResizeT> {
  static const OpParameter enum_value = OpParameter_CropAndResize;
};

template<> struct OpParameterUnionTraits<ace::DequantizeT> {
  static const OpParameter enum_value = OpParameter_Dequantize;
};

template<> struct OpParameterUnionTraits<ace::DetectionOutputT> {
  static const OpParameter enum_value = OpParameter_DetectionOutput;
};

template<> struct OpParameterUnionTraits<ace::EltwiseT> {
  static const OpParameter enum_value = OpParameter_Eltwise;
};

template<> struct OpParameterUnionTraits<ace::ExpandDimsT> {
  static const OpParameter enum_value = OpParameter_ExpandDims;
};

template<> struct OpParameterUnionTraits<ace::FillT> {
  static const OpParameter enum_value = OpParameter_Fill;
};

template<> struct OpParameterUnionTraits<ace::FlattenT> {
  static const OpParameter enum_value = OpParameter_Flatten;
};

template<> struct OpParameterUnionTraits<ace::GatherT> {
  static const OpParameter enum_value = OpParameter_Gather;
};

template<> struct OpParameterUnionTraits<ace::GatherV2T> {
  static const OpParameter enum_value = OpParameter_GatherV2;
};

template<> struct OpParameterUnionTraits<ace::InnerProductT> {
  static const OpParameter enum_value = OpParameter_InnerProduct;
};

template<> struct OpParameterUnionTraits<ace::InputT> {
  static const OpParameter enum_value = OpParameter_Input;
};

template<> struct OpParameterUnionTraits<ace::InterpT> {
  static const OpParameter enum_value = OpParameter_Interp;
};

template<> struct OpParameterUnionTraits<ace::LRNT> {
  static const OpParameter enum_value = OpParameter_LRN;
};

template<> struct OpParameterUnionTraits<ace::LSTMT> {
  static const OpParameter enum_value = OpParameter_LSTM;
};

template<> struct OpParameterUnionTraits<ace::MatMulT> {
  static const OpParameter enum_value = OpParameter_MatMul;
};

template<> struct OpParameterUnionTraits<ace::NonMaxSuppressionV2T> {
  static const OpParameter enum_value = OpParameter_NonMaxSuppressionV2;
};

template<> struct OpParameterUnionTraits<ace::NormalizeT> {
  static const OpParameter enum_value = OpParameter_Normalize;
};

template<> struct OpParameterUnionTraits<ace::PackParamT> {
  static const OpParameter enum_value = OpParameter_PackParam;
};

template<> struct OpParameterUnionTraits<ace::PermuteT> {
  static const OpParameter enum_value = OpParameter_Permute;
};

template<> struct OpParameterUnionTraits<ace::PluginT> {
  static const OpParameter enum_value = OpParameter_Plugin;
};

template<> struct OpParameterUnionTraits<ace::PoolT> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<> struct OpParameterUnionTraits<ace::PReluT> {
  static const OpParameter enum_value = OpParameter_PRelu;
};

template<> struct OpParameterUnionTraits<ace::PriorBoxT> {
  static const OpParameter enum_value = OpParameter_PriorBox;
};

template<> struct OpParameterUnionTraits<ace::ProposalT> {
  static const OpParameter enum_value = OpParameter_Proposal;
};

template<> struct OpParameterUnionTraits<ace::QuantizedAvgPoolT> {
  static const OpParameter enum_value = OpParameter_QuantizedAvgPool;
};

template<> struct OpParameterUnionTraits<ace::QuantizedBiasAddT> {
  static const OpParameter enum_value = OpParameter_QuantizedBiasAdd;
};

template<> struct OpParameterUnionTraits<ace::QuantizedConcatT> {
  static const OpParameter enum_value = OpParameter_QuantizedConcat;
};

template<> struct OpParameterUnionTraits<ace::QuantizedLogisticT> {
  static const OpParameter enum_value = OpParameter_QuantizedLogistic;
};

template<> struct OpParameterUnionTraits<ace::QuantizedMatMulT> {
  static const OpParameter enum_value = OpParameter_QuantizedMatMul;
};

template<> struct OpParameterUnionTraits<ace::QuantizedMaxPoolT> {
  static const OpParameter enum_value = OpParameter_QuantizedMaxPool;
};

template<> struct OpParameterUnionTraits<ace::QuantizedReluT> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu;
};

template<> struct OpParameterUnionTraits<ace::QuantizedRelu6T> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu6;
};

template<> struct OpParameterUnionTraits<ace::QuantizedReshapeT> {
  static const OpParameter enum_value = OpParameter_QuantizedReshape;
};

template<> struct OpParameterUnionTraits<ace::QuantizedSoftmaxT> {
  static const OpParameter enum_value = OpParameter_QuantizedSoftmax;
};

template<> struct OpParameterUnionTraits<ace::QuantizeMaxMinT> {
  static const OpParameter enum_value = OpParameter_QuantizeMaxMin;
};

template<> struct OpParameterUnionTraits<ace::QuantizeV2T> {
  static const OpParameter enum_value = OpParameter_QuantizeV2;
};

template<> struct OpParameterUnionTraits<ace::RangeT> {
  static const OpParameter enum_value = OpParameter_Range;
};

template<> struct OpParameterUnionTraits<ace::RankT> {
  static const OpParameter enum_value = OpParameter_Rank;
};

template<> struct OpParameterUnionTraits<ace::ReduceJoinT> {
  static const OpParameter enum_value = OpParameter_ReduceJoin;
};

template<> struct OpParameterUnionTraits<ace::ReductionParamT> {
  static const OpParameter enum_value = OpParameter_ReductionParam;
};

template<> struct OpParameterUnionTraits<ace::ReluT> {
  static const OpParameter enum_value = OpParameter_Relu;
};

template<> struct OpParameterUnionTraits<ace::Relu6T> {
  static const OpParameter enum_value = OpParameter_Relu6;
};

template<> struct OpParameterUnionTraits<ace::RequantizationRangeT> {
  static const OpParameter enum_value = OpParameter_RequantizationRange;
};

template<> struct OpParameterUnionTraits<ace::RequantizeT> {
  static const OpParameter enum_value = OpParameter_Requantize;
};

template<> struct OpParameterUnionTraits<ace::ReshapeT> {
  static const OpParameter enum_value = OpParameter_Reshape;
};

template<> struct OpParameterUnionTraits<ace::ResizeT> {
  static const OpParameter enum_value = OpParameter_Resize;
};

template<> struct OpParameterUnionTraits<ace::RoiParametersT> {
  static const OpParameter enum_value = OpParameter_RoiParameters;
};

template<> struct OpParameterUnionTraits<ace::ScaleT> {
  static const OpParameter enum_value = OpParameter_Scale;
};

template<> struct OpParameterUnionTraits<ace::SeluT> {
  static const OpParameter enum_value = OpParameter_Selu;
};

template<> struct OpParameterUnionTraits<ace::SizeT> {
  static const OpParameter enum_value = OpParameter_Size;
};

template<> struct OpParameterUnionTraits<ace::SliceT> {
  static const OpParameter enum_value = OpParameter_Slice;
};

template<> struct OpParameterUnionTraits<ace::SliceTfT> {
  static const OpParameter enum_value = OpParameter_SliceTf;
};

template<> struct OpParameterUnionTraits<ace::SpaceBatchT> {
  static const OpParameter enum_value = OpParameter_SpaceBatch;
};

template<> struct OpParameterUnionTraits<ace::SqueezeParamT> {
  static const OpParameter enum_value = OpParameter_SqueezeParam;
};

template<> struct OpParameterUnionTraits<ace::StridedSliceParamT> {
  static const OpParameter enum_value = OpParameter_StridedSliceParam;
};

template<> struct OpParameterUnionTraits<ace::TensorConvertInfoT> {
  static const OpParameter enum_value = OpParameter_TensorConvertInfo;
};

template<> struct OpParameterUnionTraits<ace::TfQuantizedConv2DT> {
  static const OpParameter enum_value = OpParameter_TfQuantizedConv2D;
};

template<> struct OpParameterUnionTraits<ace::TopKV2T> {
  static const OpParameter enum_value = OpParameter_TopKV2;
};

template<> struct OpParameterUnionTraits<ace::TransposeT> {
  static const OpParameter enum_value = OpParameter_Transpose;
};

template<> struct OpParameterUnionTraits<ace::UnaryOpT> {
  static const OpParameter enum_value = OpParameter_UnaryOp;
};

template<> struct OpParameterUnionTraits<ace::MomentsParamT> {
  static const OpParameter enum_value = OpParameter_MomentsParam;
};

template<> struct OpParameterUnionTraits<ace::RNNParamT> {
  static const OpParameter enum_value = OpParameter_RNNParam;
};

template<> struct OpParameterUnionTraits<ace::BatchMatMulParamT> {
  static const OpParameter enum_value = OpParameter_BatchMatMulParam;
};

template<> struct OpParameterUnionTraits<ace::QuantizedFloatParamT> {
  static const OpParameter enum_value = OpParameter_QuantizedFloatParam;
};

template<> struct OpParameterUnionTraits<ace::DepthSpaceParamT> {
  static const OpParameter enum_value = OpParameter_DepthSpaceParam;
};

template<> struct OpParameterUnionTraits<ace::EltwiseInt8T> {
  static const OpParameter enum_value = OpParameter_EltwiseInt8;
};

template<> struct OpParameterUnionTraits<ace::ReverseSequenceParamT> {
  static const OpParameter enum_value = OpParameter_ReverseSequenceParam;
};

template<> struct OpParameterUnionTraits<ace::ExtraT> {
  static const OpParameter enum_value = OpParameter_Extra;
};

template<> struct OpParameterUnionTraits<ace::Pool3DT> {
  static const OpParameter enum_value = OpParameter_Pool3D;
};

template<> struct OpParameterUnionTraits<ace::Convolution3DT> {
  static const OpParameter enum_value = OpParameter_Convolution3D;
};

template<> struct OpParameterUnionTraits<ace::ELUT> {
  static const OpParameter enum_value = OpParameter_ELU;
};

template<> struct OpParameterUnionTraits<ace::DetectionPostProcessParamT> {
  static const OpParameter enum_value = OpParameter_DetectionPostProcessParam;
};

template<> struct OpParameterUnionTraits<ace::OneHotParamT> {
  static const OpParameter enum_value = OpParameter_OneHotParam;
};

template<> struct OpParameterUnionTraits<ace::PadParamT> {
  static const OpParameter enum_value = OpParameter_PadParam;
};

template<> struct OpParameterUnionTraits<ace::WhileParamT> {
  static const OpParameter enum_value = OpParameter_WhileParam;
};

template<> struct OpParameterUnionTraits<ace::IfParamT> {
  static const OpParameter enum_value = OpParameter_IfParam;
};

template<> struct OpParameterUnionTraits<ace::RandomUniformT> {
  static const OpParameter enum_value = OpParameter_RandomUniform;
};

template<> struct OpParameterUnionTraits<ace::LayerNormT> {
  static const OpParameter enum_value = OpParameter_LayerNorm;
};

template<> struct OpParameterUnionTraits<ace::TensorArrayT> {
  static const OpParameter enum_value = OpParameter_TensorArray;
};

template<> struct OpParameterUnionTraits<ace::LSTMBlockCellT> {
  static const OpParameter enum_value = OpParameter_LSTMBlockCell;
};

template<> struct OpParameterUnionTraits<ace::GridSampleT> {
  static const OpParameter enum_value = OpParameter_GridSample;
};

template<> struct OpParameterUnionTraits<ace::LoopParamT> {
  static const OpParameter enum_value = OpParameter_LoopParam;
};

template<> struct OpParameterUnionTraits<ace::ImageProcessParamT> {
  static const OpParameter enum_value = OpParameter_ImageProcessParam;
};

template<> struct OpParameterUnionTraits<ace::CumSumT> {
  static const OpParameter enum_value = OpParameter_CumSum;
};

struct OpParameterUnion {
  OpParameter type;
  void *value;

  OpParameterUnion() : type(OpParameter_NONE), value(nullptr) {}
  OpParameterUnion(OpParameterUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpParameter_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpParameterUnion(const OpParameterUnion &);
  OpParameterUnion &operator=(const OpParameterUnion &u)
    { OpParameterUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpParameterUnion &operator=(OpParameterUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpParameterUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpParameterUnionTraits<RT>::enum_value;
    if (type != OpParameter_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpParameter type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ace::QuantizedAddT *AsQuantizedAdd() {
    return type == OpParameter_QuantizedAdd ?
      reinterpret_cast<ace::QuantizedAddT *>(value) : nullptr;
  }
  const ace::QuantizedAddT *AsQuantizedAdd() const {
    return type == OpParameter_QuantizedAdd ?
      reinterpret_cast<const ace::QuantizedAddT *>(value) : nullptr;
  }
  ace::ArgMaxT *AsArgMax() {
    return type == OpParameter_ArgMax ?
      reinterpret_cast<ace::ArgMaxT *>(value) : nullptr;
  }
  const ace::ArgMaxT *AsArgMax() const {
    return type == OpParameter_ArgMax ?
      reinterpret_cast<const ace::ArgMaxT *>(value) : nullptr;
  }
  ace::AsStringT *AsAsString() {
    return type == OpParameter_AsString ?
      reinterpret_cast<ace::AsStringT *>(value) : nullptr;
  }
  const ace::AsStringT *AsAsString() const {
    return type == OpParameter_AsString ?
      reinterpret_cast<const ace::AsStringT *>(value) : nullptr;
  }
  ace::AxisT *AsAxis() {
    return type == OpParameter_Axis ?
      reinterpret_cast<ace::AxisT *>(value) : nullptr;
  }
  const ace::AxisT *AsAxis() const {
    return type == OpParameter_Axis ?
      reinterpret_cast<const ace::AxisT *>(value) : nullptr;
  }
  ace::BatchNormT *AsBatchNorm() {
    return type == OpParameter_BatchNorm ?
      reinterpret_cast<ace::BatchNormT *>(value) : nullptr;
  }
  const ace::BatchNormT *AsBatchNorm() const {
    return type == OpParameter_BatchNorm ?
      reinterpret_cast<const ace::BatchNormT *>(value) : nullptr;
  }
  ace::BinaryOpT *AsBinaryOp() {
    return type == OpParameter_BinaryOp ?
      reinterpret_cast<ace::BinaryOpT *>(value) : nullptr;
  }
  const ace::BinaryOpT *AsBinaryOp() const {
    return type == OpParameter_BinaryOp ?
      reinterpret_cast<const ace::BinaryOpT *>(value) : nullptr;
  }
  ace::BlobT *AsBlob() {
    return type == OpParameter_Blob ?
      reinterpret_cast<ace::BlobT *>(value) : nullptr;
  }
  const ace::BlobT *AsBlob() const {
    return type == OpParameter_Blob ?
      reinterpret_cast<const ace::BlobT *>(value) : nullptr;
  }
  ace::CastParamT *AsCastParam() {
    return type == OpParameter_CastParam ?
      reinterpret_cast<ace::CastParamT *>(value) : nullptr;
  }
  const ace::CastParamT *AsCastParam() const {
    return type == OpParameter_CastParam ?
      reinterpret_cast<const ace::CastParamT *>(value) : nullptr;
  }
  ace::Convolution2DT *AsConvolution2D() {
    return type == OpParameter_Convolution2D ?
      reinterpret_cast<ace::Convolution2DT *>(value) : nullptr;
  }
  const ace::Convolution2DT *AsConvolution2D() const {
    return type == OpParameter_Convolution2D ?
      reinterpret_cast<const ace::Convolution2DT *>(value) : nullptr;
  }
  ace::CropT *AsCrop() {
    return type == OpParameter_Crop ?
      reinterpret_cast<ace::CropT *>(value) : nullptr;
  }
  const ace::CropT *AsCrop() const {
    return type == OpParameter_Crop ?
      reinterpret_cast<const ace::CropT *>(value) : nullptr;
  }
  ace::CropAndResizeT *AsCropAndResize() {
    return type == OpParameter_CropAndResize ?
      reinterpret_cast<ace::CropAndResizeT *>(value) : nullptr;
  }
  const ace::CropAndResizeT *AsCropAndResize() const {
    return type == OpParameter_CropAndResize ?
      reinterpret_cast<const ace::CropAndResizeT *>(value) : nullptr;
  }
  ace::DequantizeT *AsDequantize() {
    return type == OpParameter_Dequantize ?
      reinterpret_cast<ace::DequantizeT *>(value) : nullptr;
  }
  const ace::DequantizeT *AsDequantize() const {
    return type == OpParameter_Dequantize ?
      reinterpret_cast<const ace::DequantizeT *>(value) : nullptr;
  }
  ace::DetectionOutputT *AsDetectionOutput() {
    return type == OpParameter_DetectionOutput ?
      reinterpret_cast<ace::DetectionOutputT *>(value) : nullptr;
  }
  const ace::DetectionOutputT *AsDetectionOutput() const {
    return type == OpParameter_DetectionOutput ?
      reinterpret_cast<const ace::DetectionOutputT *>(value) : nullptr;
  }
  ace::EltwiseT *AsEltwise() {
    return type == OpParameter_Eltwise ?
      reinterpret_cast<ace::EltwiseT *>(value) : nullptr;
  }
  const ace::EltwiseT *AsEltwise() const {
    return type == OpParameter_Eltwise ?
      reinterpret_cast<const ace::EltwiseT *>(value) : nullptr;
  }
  ace::ExpandDimsT *AsExpandDims() {
    return type == OpParameter_ExpandDims ?
      reinterpret_cast<ace::ExpandDimsT *>(value) : nullptr;
  }
  const ace::ExpandDimsT *AsExpandDims() const {
    return type == OpParameter_ExpandDims ?
      reinterpret_cast<const ace::ExpandDimsT *>(value) : nullptr;
  }
  ace::FillT *AsFill() {
    return type == OpParameter_Fill ?
      reinterpret_cast<ace::FillT *>(value) : nullptr;
  }
  const ace::FillT *AsFill() const {
    return type == OpParameter_Fill ?
      reinterpret_cast<const ace::FillT *>(value) : nullptr;
  }
  ace::FlattenT *AsFlatten() {
    return type == OpParameter_Flatten ?
      reinterpret_cast<ace::FlattenT *>(value) : nullptr;
  }
  const ace::FlattenT *AsFlatten() const {
    return type == OpParameter_Flatten ?
      reinterpret_cast<const ace::FlattenT *>(value) : nullptr;
  }
  ace::GatherT *AsGather() {
    return type == OpParameter_Gather ?
      reinterpret_cast<ace::GatherT *>(value) : nullptr;
  }
  const ace::GatherT *AsGather() const {
    return type == OpParameter_Gather ?
      reinterpret_cast<const ace::GatherT *>(value) : nullptr;
  }
  ace::GatherV2T *AsGatherV2() {
    return type == OpParameter_GatherV2 ?
      reinterpret_cast<ace::GatherV2T *>(value) : nullptr;
  }
  const ace::GatherV2T *AsGatherV2() const {
    return type == OpParameter_GatherV2 ?
      reinterpret_cast<const ace::GatherV2T *>(value) : nullptr;
  }
  ace::InnerProductT *AsInnerProduct() {
    return type == OpParameter_InnerProduct ?
      reinterpret_cast<ace::InnerProductT *>(value) : nullptr;
  }
  const ace::InnerProductT *AsInnerProduct() const {
    return type == OpParameter_InnerProduct ?
      reinterpret_cast<const ace::InnerProductT *>(value) : nullptr;
  }
  ace::InputT *AsInput() {
    return type == OpParameter_Input ?
      reinterpret_cast<ace::InputT *>(value) : nullptr;
  }
  const ace::InputT *AsInput() const {
    return type == OpParameter_Input ?
      reinterpret_cast<const ace::InputT *>(value) : nullptr;
  }
  ace::InterpT *AsInterp() {
    return type == OpParameter_Interp ?
      reinterpret_cast<ace::InterpT *>(value) : nullptr;
  }
  const ace::InterpT *AsInterp() const {
    return type == OpParameter_Interp ?
      reinterpret_cast<const ace::InterpT *>(value) : nullptr;
  }
  ace::LRNT *AsLRN() {
    return type == OpParameter_LRN ?
      reinterpret_cast<ace::LRNT *>(value) : nullptr;
  }
  const ace::LRNT *AsLRN() const {
    return type == OpParameter_LRN ?
      reinterpret_cast<const ace::LRNT *>(value) : nullptr;
  }
  ace::LSTMT *AsLSTM() {
    return type == OpParameter_LSTM ?
      reinterpret_cast<ace::LSTMT *>(value) : nullptr;
  }
  const ace::LSTMT *AsLSTM() const {
    return type == OpParameter_LSTM ?
      reinterpret_cast<const ace::LSTMT *>(value) : nullptr;
  }
  ace::MatMulT *AsMatMul() {
    return type == OpParameter_MatMul ?
      reinterpret_cast<ace::MatMulT *>(value) : nullptr;
  }
  const ace::MatMulT *AsMatMul() const {
    return type == OpParameter_MatMul ?
      reinterpret_cast<const ace::MatMulT *>(value) : nullptr;
  }
  ace::NonMaxSuppressionV2T *AsNonMaxSuppressionV2() {
    return type == OpParameter_NonMaxSuppressionV2 ?
      reinterpret_cast<ace::NonMaxSuppressionV2T *>(value) : nullptr;
  }
  const ace::NonMaxSuppressionV2T *AsNonMaxSuppressionV2() const {
    return type == OpParameter_NonMaxSuppressionV2 ?
      reinterpret_cast<const ace::NonMaxSuppressionV2T *>(value) : nullptr;
  }
  ace::NormalizeT *AsNormalize() {
    return type == OpParameter_Normalize ?
      reinterpret_cast<ace::NormalizeT *>(value) : nullptr;
  }
  const ace::NormalizeT *AsNormalize() const {
    return type == OpParameter_Normalize ?
      reinterpret_cast<const ace::NormalizeT *>(value) : nullptr;
  }
  ace::PackParamT *AsPackParam() {
    return type == OpParameter_PackParam ?
      reinterpret_cast<ace::PackParamT *>(value) : nullptr;
  }
  const ace::PackParamT *AsPackParam() const {
    return type == OpParameter_PackParam ?
      reinterpret_cast<const ace::PackParamT *>(value) : nullptr;
  }
  ace::PermuteT *AsPermute() {
    return type == OpParameter_Permute ?
      reinterpret_cast<ace::PermuteT *>(value) : nullptr;
  }
  const ace::PermuteT *AsPermute() const {
    return type == OpParameter_Permute ?
      reinterpret_cast<const ace::PermuteT *>(value) : nullptr;
  }
  ace::PluginT *AsPlugin() {
    return type == OpParameter_Plugin ?
      reinterpret_cast<ace::PluginT *>(value) : nullptr;
  }
  const ace::PluginT *AsPlugin() const {
    return type == OpParameter_Plugin ?
      reinterpret_cast<const ace::PluginT *>(value) : nullptr;
  }
  ace::PoolT *AsPool() {
    return type == OpParameter_Pool ?
      reinterpret_cast<ace::PoolT *>(value) : nullptr;
  }
  const ace::PoolT *AsPool() const {
    return type == OpParameter_Pool ?
      reinterpret_cast<const ace::PoolT *>(value) : nullptr;
  }
  ace::PReluT *AsPRelu() {
    return type == OpParameter_PRelu ?
      reinterpret_cast<ace::PReluT *>(value) : nullptr;
  }
  const ace::PReluT *AsPRelu() const {
    return type == OpParameter_PRelu ?
      reinterpret_cast<const ace::PReluT *>(value) : nullptr;
  }
  ace::PriorBoxT *AsPriorBox() {
    return type == OpParameter_PriorBox ?
      reinterpret_cast<ace::PriorBoxT *>(value) : nullptr;
  }
  const ace::PriorBoxT *AsPriorBox() const {
    return type == OpParameter_PriorBox ?
      reinterpret_cast<const ace::PriorBoxT *>(value) : nullptr;
  }
  ace::ProposalT *AsProposal() {
    return type == OpParameter_Proposal ?
      reinterpret_cast<ace::ProposalT *>(value) : nullptr;
  }
  const ace::ProposalT *AsProposal() const {
    return type == OpParameter_Proposal ?
      reinterpret_cast<const ace::ProposalT *>(value) : nullptr;
  }
  ace::QuantizedAvgPoolT *AsQuantizedAvgPool() {
    return type == OpParameter_QuantizedAvgPool ?
      reinterpret_cast<ace::QuantizedAvgPoolT *>(value) : nullptr;
  }
  const ace::QuantizedAvgPoolT *AsQuantizedAvgPool() const {
    return type == OpParameter_QuantizedAvgPool ?
      reinterpret_cast<const ace::QuantizedAvgPoolT *>(value) : nullptr;
  }
  ace::QuantizedBiasAddT *AsQuantizedBiasAdd() {
    return type == OpParameter_QuantizedBiasAdd ?
      reinterpret_cast<ace::QuantizedBiasAddT *>(value) : nullptr;
  }
  const ace::QuantizedBiasAddT *AsQuantizedBiasAdd() const {
    return type == OpParameter_QuantizedBiasAdd ?
      reinterpret_cast<const ace::QuantizedBiasAddT *>(value) : nullptr;
  }
  ace::QuantizedConcatT *AsQuantizedConcat() {
    return type == OpParameter_QuantizedConcat ?
      reinterpret_cast<ace::QuantizedConcatT *>(value) : nullptr;
  }
  const ace::QuantizedConcatT *AsQuantizedConcat() const {
    return type == OpParameter_QuantizedConcat ?
      reinterpret_cast<const ace::QuantizedConcatT *>(value) : nullptr;
  }
  ace::QuantizedLogisticT *AsQuantizedLogistic() {
    return type == OpParameter_QuantizedLogistic ?
      reinterpret_cast<ace::QuantizedLogisticT *>(value) : nullptr;
  }
  const ace::QuantizedLogisticT *AsQuantizedLogistic() const {
    return type == OpParameter_QuantizedLogistic ?
      reinterpret_cast<const ace::QuantizedLogisticT *>(value) : nullptr;
  }
  ace::QuantizedMatMulT *AsQuantizedMatMul() {
    return type == OpParameter_QuantizedMatMul ?
      reinterpret_cast<ace::QuantizedMatMulT *>(value) : nullptr;
  }
  const ace::QuantizedMatMulT *AsQuantizedMatMul() const {
    return type == OpParameter_QuantizedMatMul ?
      reinterpret_cast<const ace::QuantizedMatMulT *>(value) : nullptr;
  }
  ace::QuantizedMaxPoolT *AsQuantizedMaxPool() {
    return type == OpParameter_QuantizedMaxPool ?
      reinterpret_cast<ace::QuantizedMaxPoolT *>(value) : nullptr;
  }
  const ace::QuantizedMaxPoolT *AsQuantizedMaxPool() const {
    return type == OpParameter_QuantizedMaxPool ?
      reinterpret_cast<const ace::QuantizedMaxPoolT *>(value) : nullptr;
  }
  ace::QuantizedReluT *AsQuantizedRelu() {
    return type == OpParameter_QuantizedRelu ?
      reinterpret_cast<ace::QuantizedReluT *>(value) : nullptr;
  }
  const ace::QuantizedReluT *AsQuantizedRelu() const {
    return type == OpParameter_QuantizedRelu ?
      reinterpret_cast<const ace::QuantizedReluT *>(value) : nullptr;
  }
  ace::QuantizedRelu6T *AsQuantizedRelu6() {
    return type == OpParameter_QuantizedRelu6 ?
      reinterpret_cast<ace::QuantizedRelu6T *>(value) : nullptr;
  }
  const ace::QuantizedRelu6T *AsQuantizedRelu6() const {
    return type == OpParameter_QuantizedRelu6 ?
      reinterpret_cast<const ace::QuantizedRelu6T *>(value) : nullptr;
  }
  ace::QuantizedReshapeT *AsQuantizedReshape() {
    return type == OpParameter_QuantizedReshape ?
      reinterpret_cast<ace::QuantizedReshapeT *>(value) : nullptr;
  }
  const ace::QuantizedReshapeT *AsQuantizedReshape() const {
    return type == OpParameter_QuantizedReshape ?
      reinterpret_cast<const ace::QuantizedReshapeT *>(value) : nullptr;
  }
  ace::QuantizedSoftmaxT *AsQuantizedSoftmax() {
    return type == OpParameter_QuantizedSoftmax ?
      reinterpret_cast<ace::QuantizedSoftmaxT *>(value) : nullptr;
  }
  const ace::QuantizedSoftmaxT *AsQuantizedSoftmax() const {
    return type == OpParameter_QuantizedSoftmax ?
      reinterpret_cast<const ace::QuantizedSoftmaxT *>(value) : nullptr;
  }
  ace::QuantizeMaxMinT *AsQuantizeMaxMin() {
    return type == OpParameter_QuantizeMaxMin ?
      reinterpret_cast<ace::QuantizeMaxMinT *>(value) : nullptr;
  }
  const ace::QuantizeMaxMinT *AsQuantizeMaxMin() const {
    return type == OpParameter_QuantizeMaxMin ?
      reinterpret_cast<const ace::QuantizeMaxMinT *>(value) : nullptr;
  }
  ace::QuantizeV2T *AsQuantizeV2() {
    return type == OpParameter_QuantizeV2 ?
      reinterpret_cast<ace::QuantizeV2T *>(value) : nullptr;
  }
  const ace::QuantizeV2T *AsQuantizeV2() const {
    return type == OpParameter_QuantizeV2 ?
      reinterpret_cast<const ace::QuantizeV2T *>(value) : nullptr;
  }
  ace::RangeT *AsRange() {
    return type == OpParameter_Range ?
      reinterpret_cast<ace::RangeT *>(value) : nullptr;
  }
  const ace::RangeT *AsRange() const {
    return type == OpParameter_Range ?
      reinterpret_cast<const ace::RangeT *>(value) : nullptr;
  }
  ace::RankT *AsRank() {
    return type == OpParameter_Rank ?
      reinterpret_cast<ace::RankT *>(value) : nullptr;
  }
  const ace::RankT *AsRank() const {
    return type == OpParameter_Rank ?
      reinterpret_cast<const ace::RankT *>(value) : nullptr;
  }
  ace::ReduceJoinT *AsReduceJoin() {
    return type == OpParameter_ReduceJoin ?
      reinterpret_cast<ace::ReduceJoinT *>(value) : nullptr;
  }
  const ace::ReduceJoinT *AsReduceJoin() const {
    return type == OpParameter_ReduceJoin ?
      reinterpret_cast<const ace::ReduceJoinT *>(value) : nullptr;
  }
  ace::ReductionParamT *AsReductionParam() {
    return type == OpParameter_ReductionParam ?
      reinterpret_cast<ace::ReductionParamT *>(value) : nullptr;
  }
  const ace::ReductionParamT *AsReductionParam() const {
    return type == OpParameter_ReductionParam ?
      reinterpret_cast<const ace::ReductionParamT *>(value) : nullptr;
  }
  ace::ReluT *AsRelu() {
    return type == OpParameter_Relu ?
      reinterpret_cast<ace::ReluT *>(value) : nullptr;
  }
  const ace::ReluT *AsRelu() const {
    return type == OpParameter_Relu ?
      reinterpret_cast<const ace::ReluT *>(value) : nullptr;
  }
  ace::Relu6T *AsRelu6() {
    return type == OpParameter_Relu6 ?
      reinterpret_cast<ace::Relu6T *>(value) : nullptr;
  }
  const ace::Relu6T *AsRelu6() const {
    return type == OpParameter_Relu6 ?
      reinterpret_cast<const ace::Relu6T *>(value) : nullptr;
  }
  ace::RequantizationRangeT *AsRequantizationRange() {
    return type == OpParameter_RequantizationRange ?
      reinterpret_cast<ace::RequantizationRangeT *>(value) : nullptr;
  }
  const ace::RequantizationRangeT *AsRequantizationRange() const {
    return type == OpParameter_RequantizationRange ?
      reinterpret_cast<const ace::RequantizationRangeT *>(value) : nullptr;
  }
  ace::RequantizeT *AsRequantize() {
    return type == OpParameter_Requantize ?
      reinterpret_cast<ace::RequantizeT *>(value) : nullptr;
  }
  const ace::RequantizeT *AsRequantize() const {
    return type == OpParameter_Requantize ?
      reinterpret_cast<const ace::RequantizeT *>(value) : nullptr;
  }
  ace::ReshapeT *AsReshape() {
    return type == OpParameter_Reshape ?
      reinterpret_cast<ace::ReshapeT *>(value) : nullptr;
  }
  const ace::ReshapeT *AsReshape() const {
    return type == OpParameter_Reshape ?
      reinterpret_cast<const ace::ReshapeT *>(value) : nullptr;
  }
  ace::ResizeT *AsResize() {
    return type == OpParameter_Resize ?
      reinterpret_cast<ace::ResizeT *>(value) : nullptr;
  }
  const ace::ResizeT *AsResize() const {
    return type == OpParameter_Resize ?
      reinterpret_cast<const ace::ResizeT *>(value) : nullptr;
  }
  ace::RoiParametersT *AsRoiParameters() {
    return type == OpParameter_RoiParameters ?
      reinterpret_cast<ace::RoiParametersT *>(value) : nullptr;
  }
  const ace::RoiParametersT *AsRoiParameters() const {
    return type == OpParameter_RoiParameters ?
      reinterpret_cast<const ace::RoiParametersT *>(value) : nullptr;
  }
  ace::ScaleT *AsScale() {
    return type == OpParameter_Scale ?
      reinterpret_cast<ace::ScaleT *>(value) : nullptr;
  }
  const ace::ScaleT *AsScale() const {
    return type == OpParameter_Scale ?
      reinterpret_cast<const ace::ScaleT *>(value) : nullptr;
  }
  ace::SeluT *AsSelu() {
    return type == OpParameter_Selu ?
      reinterpret_cast<ace::SeluT *>(value) : nullptr;
  }
  const ace::SeluT *AsSelu() const {
    return type == OpParameter_Selu ?
      reinterpret_cast<const ace::SeluT *>(value) : nullptr;
  }
  ace::SizeT *AsSize() {
    return type == OpParameter_Size ?
      reinterpret_cast<ace::SizeT *>(value) : nullptr;
  }
  const ace::SizeT *AsSize() const {
    return type == OpParameter_Size ?
      reinterpret_cast<const ace::SizeT *>(value) : nullptr;
  }
  ace::SliceT *AsSlice() {
    return type == OpParameter_Slice ?
      reinterpret_cast<ace::SliceT *>(value) : nullptr;
  }
  const ace::SliceT *AsSlice() const {
    return type == OpParameter_Slice ?
      reinterpret_cast<const ace::SliceT *>(value) : nullptr;
  }
  ace::SliceTfT *AsSliceTf() {
    return type == OpParameter_SliceTf ?
      reinterpret_cast<ace::SliceTfT *>(value) : nullptr;
  }
  const ace::SliceTfT *AsSliceTf() const {
    return type == OpParameter_SliceTf ?
      reinterpret_cast<const ace::SliceTfT *>(value) : nullptr;
  }
  ace::SpaceBatchT *AsSpaceBatch() {
    return type == OpParameter_SpaceBatch ?
      reinterpret_cast<ace::SpaceBatchT *>(value) : nullptr;
  }
  const ace::SpaceBatchT *AsSpaceBatch() const {
    return type == OpParameter_SpaceBatch ?
      reinterpret_cast<const ace::SpaceBatchT *>(value) : nullptr;
  }
  ace::SqueezeParamT *AsSqueezeParam() {
    return type == OpParameter_SqueezeParam ?
      reinterpret_cast<ace::SqueezeParamT *>(value) : nullptr;
  }
  const ace::SqueezeParamT *AsSqueezeParam() const {
    return type == OpParameter_SqueezeParam ?
      reinterpret_cast<const ace::SqueezeParamT *>(value) : nullptr;
  }
  ace::StridedSliceParamT *AsStridedSliceParam() {
    return type == OpParameter_StridedSliceParam ?
      reinterpret_cast<ace::StridedSliceParamT *>(value) : nullptr;
  }
  const ace::StridedSliceParamT *AsStridedSliceParam() const {
    return type == OpParameter_StridedSliceParam ?
      reinterpret_cast<const ace::StridedSliceParamT *>(value) : nullptr;
  }
  ace::TensorConvertInfoT *AsTensorConvertInfo() {
    return type == OpParameter_TensorConvertInfo ?
      reinterpret_cast<ace::TensorConvertInfoT *>(value) : nullptr;
  }
  const ace::TensorConvertInfoT *AsTensorConvertInfo() const {
    return type == OpParameter_TensorConvertInfo ?
      reinterpret_cast<const ace::TensorConvertInfoT *>(value) : nullptr;
  }
  ace::TfQuantizedConv2DT *AsTfQuantizedConv2D() {
    return type == OpParameter_TfQuantizedConv2D ?
      reinterpret_cast<ace::TfQuantizedConv2DT *>(value) : nullptr;
  }
  const ace::TfQuantizedConv2DT *AsTfQuantizedConv2D() const {
    return type == OpParameter_TfQuantizedConv2D ?
      reinterpret_cast<const ace::TfQuantizedConv2DT *>(value) : nullptr;
  }
  ace::TopKV2T *AsTopKV2() {
    return type == OpParameter_TopKV2 ?
      reinterpret_cast<ace::TopKV2T *>(value) : nullptr;
  }
  const ace::TopKV2T *AsTopKV2() const {
    return type == OpParameter_TopKV2 ?
      reinterpret_cast<const ace::TopKV2T *>(value) : nullptr;
  }
  ace::TransposeT *AsTranspose() {
    return type == OpParameter_Transpose ?
      reinterpret_cast<ace::TransposeT *>(value) : nullptr;
  }
  const ace::TransposeT *AsTranspose() const {
    return type == OpParameter_Transpose ?
      reinterpret_cast<const ace::TransposeT *>(value) : nullptr;
  }
  ace::UnaryOpT *AsUnaryOp() {
    return type == OpParameter_UnaryOp ?
      reinterpret_cast<ace::UnaryOpT *>(value) : nullptr;
  }
  const ace::UnaryOpT *AsUnaryOp() const {
    return type == OpParameter_UnaryOp ?
      reinterpret_cast<const ace::UnaryOpT *>(value) : nullptr;
  }
  ace::MomentsParamT *AsMomentsParam() {
    return type == OpParameter_MomentsParam ?
      reinterpret_cast<ace::MomentsParamT *>(value) : nullptr;
  }
  const ace::MomentsParamT *AsMomentsParam() const {
    return type == OpParameter_MomentsParam ?
      reinterpret_cast<const ace::MomentsParamT *>(value) : nullptr;
  }
  ace::RNNParamT *AsRNNParam() {
    return type == OpParameter_RNNParam ?
      reinterpret_cast<ace::RNNParamT *>(value) : nullptr;
  }
  const ace::RNNParamT *AsRNNParam() const {
    return type == OpParameter_RNNParam ?
      reinterpret_cast<const ace::RNNParamT *>(value) : nullptr;
  }
  ace::BatchMatMulParamT *AsBatchMatMulParam() {
    return type == OpParameter_BatchMatMulParam ?
      reinterpret_cast<ace::BatchMatMulParamT *>(value) : nullptr;
  }
  const ace::BatchMatMulParamT *AsBatchMatMulParam() const {
    return type == OpParameter_BatchMatMulParam ?
      reinterpret_cast<const ace::BatchMatMulParamT *>(value) : nullptr;
  }
  ace::QuantizedFloatParamT *AsQuantizedFloatParam() {
    return type == OpParameter_QuantizedFloatParam ?
      reinterpret_cast<ace::QuantizedFloatParamT *>(value) : nullptr;
  }
  const ace::QuantizedFloatParamT *AsQuantizedFloatParam() const {
    return type == OpParameter_QuantizedFloatParam ?
      reinterpret_cast<const ace::QuantizedFloatParamT *>(value) : nullptr;
  }
  ace::DepthSpaceParamT *AsDepthSpaceParam() {
    return type == OpParameter_DepthSpaceParam ?
      reinterpret_cast<ace::DepthSpaceParamT *>(value) : nullptr;
  }
  const ace::DepthSpaceParamT *AsDepthSpaceParam() const {
    return type == OpParameter_DepthSpaceParam ?
      reinterpret_cast<const ace::DepthSpaceParamT *>(value) : nullptr;
  }
  ace::EltwiseInt8T *AsEltwiseInt8() {
    return type == OpParameter_EltwiseInt8 ?
      reinterpret_cast<ace::EltwiseInt8T *>(value) : nullptr;
  }
  const ace::EltwiseInt8T *AsEltwiseInt8() const {
    return type == OpParameter_EltwiseInt8 ?
      reinterpret_cast<const ace::EltwiseInt8T *>(value) : nullptr;
  }
  ace::ReverseSequenceParamT *AsReverseSequenceParam() {
    return type == OpParameter_ReverseSequenceParam ?
      reinterpret_cast<ace::ReverseSequenceParamT *>(value) : nullptr;
  }
  const ace::ReverseSequenceParamT *AsReverseSequenceParam() const {
    return type == OpParameter_ReverseSequenceParam ?
      reinterpret_cast<const ace::ReverseSequenceParamT *>(value) : nullptr;
  }
  ace::ExtraT *AsExtra() {
    return type == OpParameter_Extra ?
      reinterpret_cast<ace::ExtraT *>(value) : nullptr;
  }
  const ace::ExtraT *AsExtra() const {
    return type == OpParameter_Extra ?
      reinterpret_cast<const ace::ExtraT *>(value) : nullptr;
  }
  ace::Pool3DT *AsPool3D() {
    return type == OpParameter_Pool3D ?
      reinterpret_cast<ace::Pool3DT *>(value) : nullptr;
  }
  const ace::Pool3DT *AsPool3D() const {
    return type == OpParameter_Pool3D ?
      reinterpret_cast<const ace::Pool3DT *>(value) : nullptr;
  }
  ace::Convolution3DT *AsConvolution3D() {
    return type == OpParameter_Convolution3D ?
      reinterpret_cast<ace::Convolution3DT *>(value) : nullptr;
  }
  const ace::Convolution3DT *AsConvolution3D() const {
    return type == OpParameter_Convolution3D ?
      reinterpret_cast<const ace::Convolution3DT *>(value) : nullptr;
  }
  ace::ELUT *AsELU() {
    return type == OpParameter_ELU ?
      reinterpret_cast<ace::ELUT *>(value) : nullptr;
  }
  const ace::ELUT *AsELU() const {
    return type == OpParameter_ELU ?
      reinterpret_cast<const ace::ELUT *>(value) : nullptr;
  }
  ace::DetectionPostProcessParamT *AsDetectionPostProcessParam() {
    return type == OpParameter_DetectionPostProcessParam ?
      reinterpret_cast<ace::DetectionPostProcessParamT *>(value) : nullptr;
  }
  const ace::DetectionPostProcessParamT *AsDetectionPostProcessParam() const {
    return type == OpParameter_DetectionPostProcessParam ?
      reinterpret_cast<const ace::DetectionPostProcessParamT *>(value) : nullptr;
  }
  ace::OneHotParamT *AsOneHotParam() {
    return type == OpParameter_OneHotParam ?
      reinterpret_cast<ace::OneHotParamT *>(value) : nullptr;
  }
  const ace::OneHotParamT *AsOneHotParam() const {
    return type == OpParameter_OneHotParam ?
      reinterpret_cast<const ace::OneHotParamT *>(value) : nullptr;
  }
  ace::PadParamT *AsPadParam() {
    return type == OpParameter_PadParam ?
      reinterpret_cast<ace::PadParamT *>(value) : nullptr;
  }
  const ace::PadParamT *AsPadParam() const {
    return type == OpParameter_PadParam ?
      reinterpret_cast<const ace::PadParamT *>(value) : nullptr;
  }
  ace::WhileParamT *AsWhileParam() {
    return type == OpParameter_WhileParam ?
      reinterpret_cast<ace::WhileParamT *>(value) : nullptr;
  }
  const ace::WhileParamT *AsWhileParam() const {
    return type == OpParameter_WhileParam ?
      reinterpret_cast<const ace::WhileParamT *>(value) : nullptr;
  }
  ace::IfParamT *AsIfParam() {
    return type == OpParameter_IfParam ?
      reinterpret_cast<ace::IfParamT *>(value) : nullptr;
  }
  const ace::IfParamT *AsIfParam() const {
    return type == OpParameter_IfParam ?
      reinterpret_cast<const ace::IfParamT *>(value) : nullptr;
  }
  ace::RandomUniformT *AsRandomUniform() {
    return type == OpParameter_RandomUniform ?
      reinterpret_cast<ace::RandomUniformT *>(value) : nullptr;
  }
  const ace::RandomUniformT *AsRandomUniform() const {
    return type == OpParameter_RandomUniform ?
      reinterpret_cast<const ace::RandomUniformT *>(value) : nullptr;
  }
  ace::LayerNormT *AsLayerNorm() {
    return type == OpParameter_LayerNorm ?
      reinterpret_cast<ace::LayerNormT *>(value) : nullptr;
  }
  const ace::LayerNormT *AsLayerNorm() const {
    return type == OpParameter_LayerNorm ?
      reinterpret_cast<const ace::LayerNormT *>(value) : nullptr;
  }
  ace::TensorArrayT *AsTensorArray() {
    return type == OpParameter_TensorArray ?
      reinterpret_cast<ace::TensorArrayT *>(value) : nullptr;
  }
  const ace::TensorArrayT *AsTensorArray() const {
    return type == OpParameter_TensorArray ?
      reinterpret_cast<const ace::TensorArrayT *>(value) : nullptr;
  }
  ace::LSTMBlockCellT *AsLSTMBlockCell() {
    return type == OpParameter_LSTMBlockCell ?
      reinterpret_cast<ace::LSTMBlockCellT *>(value) : nullptr;
  }
  const ace::LSTMBlockCellT *AsLSTMBlockCell() const {
    return type == OpParameter_LSTMBlockCell ?
      reinterpret_cast<const ace::LSTMBlockCellT *>(value) : nullptr;
  }
  ace::GridSampleT *AsGridSample() {
    return type == OpParameter_GridSample ?
      reinterpret_cast<ace::GridSampleT *>(value) : nullptr;
  }
  const ace::GridSampleT *AsGridSample() const {
    return type == OpParameter_GridSample ?
      reinterpret_cast<const ace::GridSampleT *>(value) : nullptr;
  }
  ace::LoopParamT *AsLoopParam() {
    return type == OpParameter_LoopParam ?
      reinterpret_cast<ace::LoopParamT *>(value) : nullptr;
  }
  const ace::LoopParamT *AsLoopParam() const {
    return type == OpParameter_LoopParam ?
      reinterpret_cast<const ace::LoopParamT *>(value) : nullptr;
  }
  ace::ImageProcessParamT *AsImageProcessParam() {
    return type == OpParameter_ImageProcessParam ?
      reinterpret_cast<ace::ImageProcessParamT *>(value) : nullptr;
  }
  const ace::ImageProcessParamT *AsImageProcessParam() const {
    return type == OpParameter_ImageProcessParam ?
      reinterpret_cast<const ace::ImageProcessParamT *>(value) : nullptr;
  }
  ace::CumSumT *AsCumSum() {
    return type == OpParameter_CumSum ?
      reinterpret_cast<ace::CumSumT *>(value) : nullptr;
  }
  const ace::CumSumT *AsCumSum() const {
    return type == OpParameter_CumSum ?
      reinterpret_cast<const ace::CumSumT *>(value) : nullptr;
  }
};

bool VerifyOpParameter(flatbuffers::Verifier &verifier, const void *obj, OpParameter type);
bool VerifyOpParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ForwardType : int8_t {
  ForwardType_CPU = 0,
  ForwardType_CUDA = 1,
  ForwardType_METAL = 2,
  ForwardType_OPENCL = 3,
  ForwardType_OPENGLES = 4,
  ForwardType_VULKAN = 5,
  ForwardType_MIN = ForwardType_CPU,
  ForwardType_MAX = ForwardType_VULKAN
};

inline const ForwardType (&EnumValuesForwardType())[6] {
  static const ForwardType values[] = {
    ForwardType_CPU,
    ForwardType_CUDA,
    ForwardType_METAL,
    ForwardType_OPENCL,
    ForwardType_OPENGLES,
    ForwardType_VULKAN
  };
  return values;
}

inline const char * const *EnumNamesForwardType() {
  static const char * const names[7] = {
    "CPU",
    "CUDA",
    "METAL",
    "OPENCL",
    "OPENGLES",
    "VULKAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameForwardType(ForwardType e) {
  if (flatbuffers::IsOutRange(e, ForwardType_CPU, ForwardType_VULKAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesForwardType()[index];
}

enum Usage : int8_t {
  Usage_INFERENCE = 0,
  Usage_TRAIN = 1,
  Usage_INFERENCE_STATIC = 2,
  Usage_MIN = Usage_INFERENCE,
  Usage_MAX = Usage_INFERENCE_STATIC
};

inline const Usage (&EnumValuesUsage())[3] {
  static const Usage values[] = {
    Usage_INFERENCE,
    Usage_TRAIN,
    Usage_INFERENCE_STATIC
  };
  return values;
}

inline const char * const *EnumNamesUsage() {
  static const char * const names[4] = {
    "INFERENCE",
    "TRAIN",
    "INFERENCE_STATIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameUsage(Usage e) {
  if (flatbuffers::IsOutRange(e, Usage_INFERENCE, Usage_INFERENCE_STATIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUsage()[index];
}

struct PluginT : public flatbuffers::NativeTable {
  typedef Plugin TableType;
  std::string type{};
  std::vector<std::unique_ptr<ace::AttributeT>> attr{};
  PluginT() = default;
  PluginT(const PluginT &o);
  PluginT(PluginT&&) FLATBUFFERS_NOEXCEPT = default;
  PluginT &operator=(PluginT o) FLATBUFFERS_NOEXCEPT;
};

struct Plugin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PluginT NativeTableType;
  typedef PluginBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PluginTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ATTR = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  PluginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PluginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Plugin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PluginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PluginBuilder {
  typedef Plugin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Plugin::VT_TYPE, type);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> attr) {
    fbb_.AddOffset(Plugin::VT_ATTR, attr);
  }
  explicit PluginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Plugin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Plugin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Plugin> CreatePlugin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> attr = 0) {
  PluginBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Plugin> CreatePluginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    std::vector<flatbuffers::Offset<ace::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<ace::Attribute>(attr) : 0;
  return ace::CreatePlugin(
      _fbb,
      type__,
      attr__);
}

flatbuffers::Offset<Plugin> CreatePlugin(flatbuffers::FlatBufferBuilder &_fbb, const PluginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExtraT : public flatbuffers::NativeTable {
  typedef Extra TableType;
  std::string type{};
  std::string engine{};
  std::vector<int8_t> info{};
  std::vector<std::unique_ptr<ace::AttributeT>> attr{};
  ExtraT() = default;
  ExtraT(const ExtraT &o);
  ExtraT(ExtraT&&) FLATBUFFERS_NOEXCEPT = default;
  ExtraT &operator=(ExtraT o) FLATBUFFERS_NOEXCEPT;
};

struct Extra FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtraT NativeTableType;
  typedef ExtraBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExtraTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ENGINE = 6,
    VT_INFO = 8,
    VT_ATTR = 10
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *engine() const {
    return GetPointer<const flatbuffers::String *>(VT_ENGINE);
  }
  const flatbuffers::Vector<int8_t> *info() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ENGINE) &&
           verifier.VerifyString(engine()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  ExtraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExtraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Extra> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExtraBuilder {
  typedef Extra Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Extra::VT_TYPE, type);
  }
  void add_engine(flatbuffers::Offset<flatbuffers::String> engine) {
    fbb_.AddOffset(Extra::VT_ENGINE, engine);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<int8_t>> info) {
    fbb_.AddOffset(Extra::VT_INFO, info);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> attr) {
    fbb_.AddOffset(Extra::VT_ATTR, attr);
  }
  explicit ExtraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Extra> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Extra>(end);
    return o;
  }
};

inline flatbuffers::Offset<Extra> CreateExtra(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> engine = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> attr = 0) {
  ExtraBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_info(info);
  builder_.add_engine(engine);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Extra> CreateExtraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *engine = nullptr,
    const std::vector<int8_t> *info = nullptr,
    std::vector<flatbuffers::Offset<ace::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto engine__ = engine ? _fbb.CreateString(engine) : 0;
  auto info__ = info ? _fbb.CreateVector<int8_t>(*info) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<ace::Attribute>(attr) : 0;
  return ace::CreateExtra(
      _fbb,
      type__,
      engine__,
      info__,
      attr__);
}

flatbuffers::Offset<Extra> CreateExtra(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringVecT : public flatbuffers::NativeTable {
  typedef StringVec TableType;
  std::vector<std::string> data{};
};

struct StringVec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringVecT NativeTableType;
  typedef StringVecBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringVecTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
  StringVecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringVecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StringVec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringVecBuilder {
  typedef StringVec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data) {
    fbb_.AddOffset(StringVec::VT_DATA, data);
  }
  explicit StringVecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringVec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringVec>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringVec> CreateStringVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data = 0) {
  StringVecBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringVec> CreateStringVecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*data) : 0;
  return ace::CreateStringVec(
      _fbb,
      data__);
}

flatbuffers::Offset<StringVec> CreateStringVec(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileParamT : public flatbuffers::NativeTable {
  typedef WhileParam TableType;
  std::string cond_graph{};
  std::string body_graph{};
  std::vector<std::unique_ptr<ace::StringVecT>> aliases_inputs{};
  std::vector<std::string> aliases_outputs{};
  std::vector<std::unique_ptr<ace::StringVecT>> aliases_updates{};
  WhileParamT() = default;
  WhileParamT(const WhileParamT &o);
  WhileParamT(WhileParamT&&) FLATBUFFERS_NOEXCEPT = default;
  WhileParamT &operator=(WhileParamT o) FLATBUFFERS_NOEXCEPT;
};

struct WhileParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhileParamT NativeTableType;
  typedef WhileParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhileParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_GRAPH = 4,
    VT_BODY_GRAPH = 6,
    VT_ALIASES_INPUTS = 8,
    VT_ALIASES_OUTPUTS = 10,
    VT_ALIASES_UPDATES = 12
  };
  const flatbuffers::String *cond_graph() const {
    return GetPointer<const flatbuffers::String *>(VT_COND_GRAPH);
  }
  const flatbuffers::String *body_graph() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY_GRAPH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *aliases_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *>(VT_ALIASES_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *aliases_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALIASES_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *aliases_updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *>(VT_ALIASES_UPDATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COND_GRAPH) &&
           verifier.VerifyString(cond_graph()) &&
           VerifyOffset(verifier, VT_BODY_GRAPH) &&
           verifier.VerifyString(body_graph()) &&
           VerifyOffset(verifier, VT_ALIASES_INPUTS) &&
           verifier.VerifyVector(aliases_inputs()) &&
           verifier.VerifyVectorOfTables(aliases_inputs()) &&
           VerifyOffset(verifier, VT_ALIASES_OUTPUTS) &&
           verifier.VerifyVector(aliases_outputs()) &&
           verifier.VerifyVectorOfStrings(aliases_outputs()) &&
           VerifyOffset(verifier, VT_ALIASES_UPDATES) &&
           verifier.VerifyVector(aliases_updates()) &&
           verifier.VerifyVectorOfTables(aliases_updates()) &&
           verifier.EndTable();
  }
  WhileParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WhileParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileParamBuilder {
  typedef WhileParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_graph(flatbuffers::Offset<flatbuffers::String> cond_graph) {
    fbb_.AddOffset(WhileParam::VT_COND_GRAPH, cond_graph);
  }
  void add_body_graph(flatbuffers::Offset<flatbuffers::String> body_graph) {
    fbb_.AddOffset(WhileParam::VT_BODY_GRAPH, body_graph);
  }
  void add_aliases_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_inputs) {
    fbb_.AddOffset(WhileParam::VT_ALIASES_INPUTS, aliases_inputs);
  }
  void add_aliases_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> aliases_outputs) {
    fbb_.AddOffset(WhileParam::VT_ALIASES_OUTPUTS, aliases_outputs);
  }
  void add_aliases_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_updates) {
    fbb_.AddOffset(WhileParam::VT_ALIASES_UPDATES, aliases_updates);
  }
  explicit WhileParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WhileParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileParam> CreateWhileParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cond_graph = 0,
    flatbuffers::Offset<flatbuffers::String> body_graph = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> aliases_outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_updates = 0) {
  WhileParamBuilder builder_(_fbb);
  builder_.add_aliases_updates(aliases_updates);
  builder_.add_aliases_outputs(aliases_outputs);
  builder_.add_aliases_inputs(aliases_inputs);
  builder_.add_body_graph(body_graph);
  builder_.add_cond_graph(cond_graph);
  return builder_.Finish();
}

inline flatbuffers::Offset<WhileParam> CreateWhileParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cond_graph = nullptr,
    const char *body_graph = nullptr,
    const std::vector<flatbuffers::Offset<ace::StringVec>> *aliases_inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *aliases_outputs = nullptr,
    const std::vector<flatbuffers::Offset<ace::StringVec>> *aliases_updates = nullptr) {
  auto cond_graph__ = cond_graph ? _fbb.CreateString(cond_graph) : 0;
  auto body_graph__ = body_graph ? _fbb.CreateString(body_graph) : 0;
  auto aliases_inputs__ = aliases_inputs ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>>(*aliases_inputs) : 0;
  auto aliases_outputs__ = aliases_outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*aliases_outputs) : 0;
  auto aliases_updates__ = aliases_updates ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>>(*aliases_updates) : 0;
  return ace::CreateWhileParam(
      _fbb,
      cond_graph__,
      body_graph__,
      aliases_inputs__,
      aliases_outputs__,
      aliases_updates__);
}

flatbuffers::Offset<WhileParam> CreateWhileParam(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IfParamT : public flatbuffers::NativeTable {
  typedef IfParam TableType;
  std::string then_graph{};
  std::string else_graph{};
  std::vector<std::unique_ptr<ace::StringVecT>> aliases_inputs{};
  std::vector<std::unique_ptr<ace::StringVecT>> aliases_outputs{};
  IfParamT() = default;
  IfParamT(const IfParamT &o);
  IfParamT(IfParamT&&) FLATBUFFERS_NOEXCEPT = default;
  IfParamT &operator=(IfParamT o) FLATBUFFERS_NOEXCEPT;
};

struct IfParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IfParamT NativeTableType;
  typedef IfParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IfParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THEN_GRAPH = 4,
    VT_ELSE_GRAPH = 6,
    VT_ALIASES_INPUTS = 8,
    VT_ALIASES_OUTPUTS = 10
  };
  const flatbuffers::String *then_graph() const {
    return GetPointer<const flatbuffers::String *>(VT_THEN_GRAPH);
  }
  const flatbuffers::String *else_graph() const {
    return GetPointer<const flatbuffers::String *>(VT_ELSE_GRAPH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *aliases_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *>(VT_ALIASES_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *aliases_outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>> *>(VT_ALIASES_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THEN_GRAPH) &&
           verifier.VerifyString(then_graph()) &&
           VerifyOffset(verifier, VT_ELSE_GRAPH) &&
           verifier.VerifyString(else_graph()) &&
           VerifyOffset(verifier, VT_ALIASES_INPUTS) &&
           verifier.VerifyVector(aliases_inputs()) &&
           verifier.VerifyVectorOfTables(aliases_inputs()) &&
           VerifyOffset(verifier, VT_ALIASES_OUTPUTS) &&
           verifier.VerifyVector(aliases_outputs()) &&
           verifier.VerifyVectorOfTables(aliases_outputs()) &&
           verifier.EndTable();
  }
  IfParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IfParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IfParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IfParamBuilder {
  typedef IfParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_graph(flatbuffers::Offset<flatbuffers::String> then_graph) {
    fbb_.AddOffset(IfParam::VT_THEN_GRAPH, then_graph);
  }
  void add_else_graph(flatbuffers::Offset<flatbuffers::String> else_graph) {
    fbb_.AddOffset(IfParam::VT_ELSE_GRAPH, else_graph);
  }
  void add_aliases_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_inputs) {
    fbb_.AddOffset(IfParam::VT_ALIASES_INPUTS, aliases_inputs);
  }
  void add_aliases_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_outputs) {
    fbb_.AddOffset(IfParam::VT_ALIASES_OUTPUTS, aliases_outputs);
  }
  explicit IfParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IfParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfParam> CreateIfParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> then_graph = 0,
    flatbuffers::Offset<flatbuffers::String> else_graph = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::StringVec>>> aliases_outputs = 0) {
  IfParamBuilder builder_(_fbb);
  builder_.add_aliases_outputs(aliases_outputs);
  builder_.add_aliases_inputs(aliases_inputs);
  builder_.add_else_graph(else_graph);
  builder_.add_then_graph(then_graph);
  return builder_.Finish();
}

inline flatbuffers::Offset<IfParam> CreateIfParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *then_graph = nullptr,
    const char *else_graph = nullptr,
    const std::vector<flatbuffers::Offset<ace::StringVec>> *aliases_inputs = nullptr,
    const std::vector<flatbuffers::Offset<ace::StringVec>> *aliases_outputs = nullptr) {
  auto then_graph__ = then_graph ? _fbb.CreateString(then_graph) : 0;
  auto else_graph__ = else_graph ? _fbb.CreateString(else_graph) : 0;
  auto aliases_inputs__ = aliases_inputs ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>>(*aliases_inputs) : 0;
  auto aliases_outputs__ = aliases_outputs ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>>(*aliases_outputs) : 0;
  return ace::CreateIfParam(
      _fbb,
      then_graph__,
      else_graph__,
      aliases_inputs__,
      aliases_outputs__);
}

flatbuffers::Offset<IfParam> CreateIfParam(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionCommandT : public flatbuffers::NativeTable {
  typedef RegionCommand TableType;
  std::unique_ptr<ace::OpT> op{};
  std::vector<int32_t> steps{};
  std::vector<int32_t> size{};
  std::vector<int32_t> indexes{};
  std::vector<std::unique_ptr<ace::ViewT>> view{};
  int32_t fuse = -1;
  std::vector<int32_t> iterIndexes{};
  RegionCommandT() = default;
  RegionCommandT(const RegionCommandT &o);
  RegionCommandT(RegionCommandT&&) FLATBUFFERS_NOEXCEPT = default;
  RegionCommandT &operator=(RegionCommandT o) FLATBUFFERS_NOEXCEPT;
};

struct RegionCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegionCommandT NativeTableType;
  typedef RegionCommandBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegionCommandTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_STEPS = 6,
    VT_SIZE = 8,
    VT_INDEXES = 10,
    VT_VIEW = 12,
    VT_FUSE = 14,
    VT_ITERINDEXES = 16
  };
  const ace::Op *op() const {
    return GetPointer<const ace::Op *>(VT_OP);
  }
  const flatbuffers::Vector<int32_t> *steps() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STEPS);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  const flatbuffers::Vector<int32_t> *indexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INDEXES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::View>> *view() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::View>> *>(VT_VIEW);
  }
  int32_t fuse() const {
    return GetField<int32_t>(VT_FUSE, -1);
  }
  const flatbuffers::Vector<int32_t> *iterIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ITERINDEXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyTable(op()) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           VerifyOffset(verifier, VT_INDEXES) &&
           verifier.VerifyVector(indexes()) &&
           VerifyOffset(verifier, VT_VIEW) &&
           verifier.VerifyVector(view()) &&
           verifier.VerifyVectorOfTables(view()) &&
           VerifyField<int32_t>(verifier, VT_FUSE, 4) &&
           VerifyOffset(verifier, VT_ITERINDEXES) &&
           verifier.VerifyVector(iterIndexes()) &&
           verifier.EndTable();
  }
  RegionCommandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionCommandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegionCommand> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionCommandBuilder {
  typedef RegionCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op(flatbuffers::Offset<ace::Op> op) {
    fbb_.AddOffset(RegionCommand::VT_OP, op);
  }
  void add_steps(flatbuffers::Offset<flatbuffers::Vector<int32_t>> steps) {
    fbb_.AddOffset(RegionCommand::VT_STEPS, steps);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(RegionCommand::VT_SIZE, size);
  }
  void add_indexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> indexes) {
    fbb_.AddOffset(RegionCommand::VT_INDEXES, indexes);
  }
  void add_view(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::View>>> view) {
    fbb_.AddOffset(RegionCommand::VT_VIEW, view);
  }
  void add_fuse(int32_t fuse) {
    fbb_.AddElement<int32_t>(RegionCommand::VT_FUSE, fuse, -1);
  }
  void add_iterIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> iterIndexes) {
    fbb_.AddOffset(RegionCommand::VT_ITERINDEXES, iterIndexes);
  }
  explicit RegionCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RegionCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegionCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegionCommand> CreateRegionCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Op> op = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> steps = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> indexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::View>>> view = 0,
    int32_t fuse = -1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> iterIndexes = 0) {
  RegionCommandBuilder builder_(_fbb);
  builder_.add_iterIndexes(iterIndexes);
  builder_.add_fuse(fuse);
  builder_.add_view(view);
  builder_.add_indexes(indexes);
  builder_.add_size(size);
  builder_.add_steps(steps);
  builder_.add_op(op);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegionCommand> CreateRegionCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Op> op = 0,
    const std::vector<int32_t> *steps = nullptr,
    const std::vector<int32_t> *size = nullptr,
    const std::vector<int32_t> *indexes = nullptr,
    const std::vector<flatbuffers::Offset<ace::View>> *view = nullptr,
    int32_t fuse = -1,
    const std::vector<int32_t> *iterIndexes = nullptr) {
  auto steps__ = steps ? _fbb.CreateVector<int32_t>(*steps) : 0;
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  auto indexes__ = indexes ? _fbb.CreateVector<int32_t>(*indexes) : 0;
  auto view__ = view ? _fbb.CreateVector<flatbuffers::Offset<ace::View>>(*view) : 0;
  auto iterIndexes__ = iterIndexes ? _fbb.CreateVector<int32_t>(*iterIndexes) : 0;
  return ace::CreateRegionCommand(
      _fbb,
      op,
      steps__,
      size__,
      indexes__,
      view__,
      fuse,
      iterIndexes__);
}

flatbuffers::Offset<RegionCommand> CreateRegionCommand(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoopParamT : public flatbuffers::NativeTable {
  typedef LoopParam TableType;
  int32_t tensorNumber = 0;
  std::vector<int32_t> outputIndexes{};
  std::vector<int32_t> inputIndexes{};
  std::vector<std::unique_ptr<ace::TensorDescribeT>> extraTensorInfos{};
  bool parallel = true;
  int32_t loopNumber = 0;
  std::vector<std::unique_ptr<ace::RegionCommandT>> commands{};
  std::vector<std::unique_ptr<ace::RegionCommandT>> initCommand{};
  LoopParamT() = default;
  LoopParamT(const LoopParamT &o);
  LoopParamT(LoopParamT&&) FLATBUFFERS_NOEXCEPT = default;
  LoopParamT &operator=(LoopParamT o) FLATBUFFERS_NOEXCEPT;
};

struct LoopParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoopParamT NativeTableType;
  typedef LoopParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LoopParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORNUMBER = 4,
    VT_OUTPUTINDEXES = 6,
    VT_INPUTINDEXES = 8,
    VT_EXTRATENSORINFOS = 10,
    VT_PARALLEL = 12,
    VT_LOOPNUMBER = 14,
    VT_COMMANDS = 16,
    VT_INITCOMMAND = 18
  };
  int32_t tensorNumber() const {
    return GetField<int32_t>(VT_TENSORNUMBER, 0);
  }
  const flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTINDEXES);
  }
  const flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTINDEXES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>> *extraTensorInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>> *>(VT_EXTRATENSORINFOS);
  }
  bool parallel() const {
    return GetField<uint8_t>(VT_PARALLEL, 1) != 0;
  }
  int32_t loopNumber() const {
    return GetField<int32_t>(VT_LOOPNUMBER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>> *>(VT_COMMANDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>> *initCommand() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>> *>(VT_INITCOMMAND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TENSORNUMBER, 4) &&
           VerifyOffset(verifier, VT_OUTPUTINDEXES) &&
           verifier.VerifyVector(outputIndexes()) &&
           VerifyOffset(verifier, VT_INPUTINDEXES) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyOffset(verifier, VT_EXTRATENSORINFOS) &&
           verifier.VerifyVector(extraTensorInfos()) &&
           verifier.VerifyVectorOfTables(extraTensorInfos()) &&
           VerifyField<uint8_t>(verifier, VT_PARALLEL, 1) &&
           VerifyField<int32_t>(verifier, VT_LOOPNUMBER, 4) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           VerifyOffset(verifier, VT_INITCOMMAND) &&
           verifier.VerifyVector(initCommand()) &&
           verifier.VerifyVectorOfTables(initCommand()) &&
           verifier.EndTable();
  }
  LoopParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoopParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoopParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoopParamBuilder {
  typedef LoopParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensorNumber(int32_t tensorNumber) {
    fbb_.AddElement<int32_t>(LoopParam::VT_TENSORNUMBER, tensorNumber, 0);
  }
  void add_outputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(LoopParam::VT_OUTPUTINDEXES, outputIndexes);
  }
  void add_inputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(LoopParam::VT_INPUTINDEXES, inputIndexes);
  }
  void add_extraTensorInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>>> extraTensorInfos) {
    fbb_.AddOffset(LoopParam::VT_EXTRATENSORINFOS, extraTensorInfos);
  }
  void add_parallel(bool parallel) {
    fbb_.AddElement<uint8_t>(LoopParam::VT_PARALLEL, static_cast<uint8_t>(parallel), 1);
  }
  void add_loopNumber(int32_t loopNumber) {
    fbb_.AddElement<int32_t>(LoopParam::VT_LOOPNUMBER, loopNumber, 0);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>>> commands) {
    fbb_.AddOffset(LoopParam::VT_COMMANDS, commands);
  }
  void add_initCommand(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>>> initCommand) {
    fbb_.AddOffset(LoopParam::VT_INITCOMMAND, initCommand);
  }
  explicit LoopParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LoopParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoopParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoopParam> CreateLoopParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensorNumber = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>>> extraTensorInfos = 0,
    bool parallel = true,
    int32_t loopNumber = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>>> commands = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::RegionCommand>>> initCommand = 0) {
  LoopParamBuilder builder_(_fbb);
  builder_.add_initCommand(initCommand);
  builder_.add_commands(commands);
  builder_.add_loopNumber(loopNumber);
  builder_.add_extraTensorInfos(extraTensorInfos);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_tensorNumber(tensorNumber);
  builder_.add_parallel(parallel);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoopParam> CreateLoopParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensorNumber = 0,
    const std::vector<int32_t> *outputIndexes = nullptr,
    const std::vector<int32_t> *inputIndexes = nullptr,
    const std::vector<flatbuffers::Offset<ace::TensorDescribe>> *extraTensorInfos = nullptr,
    bool parallel = true,
    int32_t loopNumber = 0,
    const std::vector<flatbuffers::Offset<ace::RegionCommand>> *commands = nullptr,
    const std::vector<flatbuffers::Offset<ace::RegionCommand>> *initCommand = nullptr) {
  auto outputIndexes__ = outputIndexes ? _fbb.CreateVector<int32_t>(*outputIndexes) : 0;
  auto inputIndexes__ = inputIndexes ? _fbb.CreateVector<int32_t>(*inputIndexes) : 0;
  auto extraTensorInfos__ = extraTensorInfos ? _fbb.CreateVector<flatbuffers::Offset<ace::TensorDescribe>>(*extraTensorInfos) : 0;
  auto commands__ = commands ? _fbb.CreateVector<flatbuffers::Offset<ace::RegionCommand>>(*commands) : 0;
  auto initCommand__ = initCommand ? _fbb.CreateVector<flatbuffers::Offset<ace::RegionCommand>>(*initCommand) : 0;
  return ace::CreateLoopParam(
      _fbb,
      tensorNumber,
      outputIndexes__,
      inputIndexes__,
      extraTensorInfos__,
      parallel,
      loopNumber,
      commands__,
      initCommand__);
}

flatbuffers::Offset<LoopParam> CreateLoopParam(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpT : public flatbuffers::NativeTable {
  typedef Op TableType;
  std::vector<int32_t> inputIndexes{};
  ace::OpParameterUnion main{};
  std::string name{};
  std::vector<int32_t> outputIndexes{};
  ace::OpType type = ace::OpType_AbsVal;
  ace::DataFormat defaultDimentionFormat = ace::DataFormat_NHWC;
};

struct Op FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpT NativeTableType;
  typedef OpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTINDEXES = 4,
    VT_MAIN_TYPE = 6,
    VT_MAIN = 8,
    VT_NAME = 10,
    VT_OUTPUTINDEXES = 12,
    VT_TYPE = 14,
    VT_DEFAULTDIMENTIONFORMAT = 16
  };
  const flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTINDEXES);
  }
  ace::OpParameter main_type() const {
    return static_cast<ace::OpParameter>(GetField<uint8_t>(VT_MAIN_TYPE, 0));
  }
  const void *main() const {
    return GetPointer<const void *>(VT_MAIN);
  }
  template<typename T> const T *main_as() const;
  const ace::QuantizedAdd *main_as_QuantizedAdd() const {
    return main_type() == ace::OpParameter_QuantizedAdd ? static_cast<const ace::QuantizedAdd *>(main()) : nullptr;
  }
  const ace::ArgMax *main_as_ArgMax() const {
    return main_type() == ace::OpParameter_ArgMax ? static_cast<const ace::ArgMax *>(main()) : nullptr;
  }
  const ace::AsString *main_as_AsString() const {
    return main_type() == ace::OpParameter_AsString ? static_cast<const ace::AsString *>(main()) : nullptr;
  }
  const ace::Axis *main_as_Axis() const {
    return main_type() == ace::OpParameter_Axis ? static_cast<const ace::Axis *>(main()) : nullptr;
  }
  const ace::BatchNorm *main_as_BatchNorm() const {
    return main_type() == ace::OpParameter_BatchNorm ? static_cast<const ace::BatchNorm *>(main()) : nullptr;
  }
  const ace::BinaryOp *main_as_BinaryOp() const {
    return main_type() == ace::OpParameter_BinaryOp ? static_cast<const ace::BinaryOp *>(main()) : nullptr;
  }
  const ace::Blob *main_as_Blob() const {
    return main_type() == ace::OpParameter_Blob ? static_cast<const ace::Blob *>(main()) : nullptr;
  }
  const ace::CastParam *main_as_CastParam() const {
    return main_type() == ace::OpParameter_CastParam ? static_cast<const ace::CastParam *>(main()) : nullptr;
  }
  const ace::Convolution2D *main_as_Convolution2D() const {
    return main_type() == ace::OpParameter_Convolution2D ? static_cast<const ace::Convolution2D *>(main()) : nullptr;
  }
  const ace::Crop *main_as_Crop() const {
    return main_type() == ace::OpParameter_Crop ? static_cast<const ace::Crop *>(main()) : nullptr;
  }
  const ace::CropAndResize *main_as_CropAndResize() const {
    return main_type() == ace::OpParameter_CropAndResize ? static_cast<const ace::CropAndResize *>(main()) : nullptr;
  }
  const ace::Dequantize *main_as_Dequantize() const {
    return main_type() == ace::OpParameter_Dequantize ? static_cast<const ace::Dequantize *>(main()) : nullptr;
  }
  const ace::DetectionOutput *main_as_DetectionOutput() const {
    return main_type() == ace::OpParameter_DetectionOutput ? static_cast<const ace::DetectionOutput *>(main()) : nullptr;
  }
  const ace::Eltwise *main_as_Eltwise() const {
    return main_type() == ace::OpParameter_Eltwise ? static_cast<const ace::Eltwise *>(main()) : nullptr;
  }
  const ace::ExpandDims *main_as_ExpandDims() const {
    return main_type() == ace::OpParameter_ExpandDims ? static_cast<const ace::ExpandDims *>(main()) : nullptr;
  }
  const ace::Fill *main_as_Fill() const {
    return main_type() == ace::OpParameter_Fill ? static_cast<const ace::Fill *>(main()) : nullptr;
  }
  const ace::Flatten *main_as_Flatten() const {
    return main_type() == ace::OpParameter_Flatten ? static_cast<const ace::Flatten *>(main()) : nullptr;
  }
  const ace::Gather *main_as_Gather() const {
    return main_type() == ace::OpParameter_Gather ? static_cast<const ace::Gather *>(main()) : nullptr;
  }
  const ace::GatherV2 *main_as_GatherV2() const {
    return main_type() == ace::OpParameter_GatherV2 ? static_cast<const ace::GatherV2 *>(main()) : nullptr;
  }
  const ace::InnerProduct *main_as_InnerProduct() const {
    return main_type() == ace::OpParameter_InnerProduct ? static_cast<const ace::InnerProduct *>(main()) : nullptr;
  }
  const ace::Input *main_as_Input() const {
    return main_type() == ace::OpParameter_Input ? static_cast<const ace::Input *>(main()) : nullptr;
  }
  const ace::Interp *main_as_Interp() const {
    return main_type() == ace::OpParameter_Interp ? static_cast<const ace::Interp *>(main()) : nullptr;
  }
  const ace::LRN *main_as_LRN() const {
    return main_type() == ace::OpParameter_LRN ? static_cast<const ace::LRN *>(main()) : nullptr;
  }
  const ace::LSTM *main_as_LSTM() const {
    return main_type() == ace::OpParameter_LSTM ? static_cast<const ace::LSTM *>(main()) : nullptr;
  }
  const ace::MatMul *main_as_MatMul() const {
    return main_type() == ace::OpParameter_MatMul ? static_cast<const ace::MatMul *>(main()) : nullptr;
  }
  const ace::NonMaxSuppressionV2 *main_as_NonMaxSuppressionV2() const {
    return main_type() == ace::OpParameter_NonMaxSuppressionV2 ? static_cast<const ace::NonMaxSuppressionV2 *>(main()) : nullptr;
  }
  const ace::Normalize *main_as_Normalize() const {
    return main_type() == ace::OpParameter_Normalize ? static_cast<const ace::Normalize *>(main()) : nullptr;
  }
  const ace::PackParam *main_as_PackParam() const {
    return main_type() == ace::OpParameter_PackParam ? static_cast<const ace::PackParam *>(main()) : nullptr;
  }
  const ace::Permute *main_as_Permute() const {
    return main_type() == ace::OpParameter_Permute ? static_cast<const ace::Permute *>(main()) : nullptr;
  }
  const ace::Plugin *main_as_Plugin() const {
    return main_type() == ace::OpParameter_Plugin ? static_cast<const ace::Plugin *>(main()) : nullptr;
  }
  const ace::Pool *main_as_Pool() const {
    return main_type() == ace::OpParameter_Pool ? static_cast<const ace::Pool *>(main()) : nullptr;
  }
  const ace::PRelu *main_as_PRelu() const {
    return main_type() == ace::OpParameter_PRelu ? static_cast<const ace::PRelu *>(main()) : nullptr;
  }
  const ace::PriorBox *main_as_PriorBox() const {
    return main_type() == ace::OpParameter_PriorBox ? static_cast<const ace::PriorBox *>(main()) : nullptr;
  }
  const ace::Proposal *main_as_Proposal() const {
    return main_type() == ace::OpParameter_Proposal ? static_cast<const ace::Proposal *>(main()) : nullptr;
  }
  const ace::QuantizedAvgPool *main_as_QuantizedAvgPool() const {
    return main_type() == ace::OpParameter_QuantizedAvgPool ? static_cast<const ace::QuantizedAvgPool *>(main()) : nullptr;
  }
  const ace::QuantizedBiasAdd *main_as_QuantizedBiasAdd() const {
    return main_type() == ace::OpParameter_QuantizedBiasAdd ? static_cast<const ace::QuantizedBiasAdd *>(main()) : nullptr;
  }
  const ace::QuantizedConcat *main_as_QuantizedConcat() const {
    return main_type() == ace::OpParameter_QuantizedConcat ? static_cast<const ace::QuantizedConcat *>(main()) : nullptr;
  }
  const ace::QuantizedLogistic *main_as_QuantizedLogistic() const {
    return main_type() == ace::OpParameter_QuantizedLogistic ? static_cast<const ace::QuantizedLogistic *>(main()) : nullptr;
  }
  const ace::QuantizedMatMul *main_as_QuantizedMatMul() const {
    return main_type() == ace::OpParameter_QuantizedMatMul ? static_cast<const ace::QuantizedMatMul *>(main()) : nullptr;
  }
  const ace::QuantizedMaxPool *main_as_QuantizedMaxPool() const {
    return main_type() == ace::OpParameter_QuantizedMaxPool ? static_cast<const ace::QuantizedMaxPool *>(main()) : nullptr;
  }
  const ace::QuantizedRelu *main_as_QuantizedRelu() const {
    return main_type() == ace::OpParameter_QuantizedRelu ? static_cast<const ace::QuantizedRelu *>(main()) : nullptr;
  }
  const ace::QuantizedRelu6 *main_as_QuantizedRelu6() const {
    return main_type() == ace::OpParameter_QuantizedRelu6 ? static_cast<const ace::QuantizedRelu6 *>(main()) : nullptr;
  }
  const ace::QuantizedReshape *main_as_QuantizedReshape() const {
    return main_type() == ace::OpParameter_QuantizedReshape ? static_cast<const ace::QuantizedReshape *>(main()) : nullptr;
  }
  const ace::QuantizedSoftmax *main_as_QuantizedSoftmax() const {
    return main_type() == ace::OpParameter_QuantizedSoftmax ? static_cast<const ace::QuantizedSoftmax *>(main()) : nullptr;
  }
  const ace::QuantizeMaxMin *main_as_QuantizeMaxMin() const {
    return main_type() == ace::OpParameter_QuantizeMaxMin ? static_cast<const ace::QuantizeMaxMin *>(main()) : nullptr;
  }
  const ace::QuantizeV2 *main_as_QuantizeV2() const {
    return main_type() == ace::OpParameter_QuantizeV2 ? static_cast<const ace::QuantizeV2 *>(main()) : nullptr;
  }
  const ace::Range *main_as_Range() const {
    return main_type() == ace::OpParameter_Range ? static_cast<const ace::Range *>(main()) : nullptr;
  }
  const ace::Rank *main_as_Rank() const {
    return main_type() == ace::OpParameter_Rank ? static_cast<const ace::Rank *>(main()) : nullptr;
  }
  const ace::ReduceJoin *main_as_ReduceJoin() const {
    return main_type() == ace::OpParameter_ReduceJoin ? static_cast<const ace::ReduceJoin *>(main()) : nullptr;
  }
  const ace::ReductionParam *main_as_ReductionParam() const {
    return main_type() == ace::OpParameter_ReductionParam ? static_cast<const ace::ReductionParam *>(main()) : nullptr;
  }
  const ace::Relu *main_as_Relu() const {
    return main_type() == ace::OpParameter_Relu ? static_cast<const ace::Relu *>(main()) : nullptr;
  }
  const ace::Relu6 *main_as_Relu6() const {
    return main_type() == ace::OpParameter_Relu6 ? static_cast<const ace::Relu6 *>(main()) : nullptr;
  }
  const ace::RequantizationRange *main_as_RequantizationRange() const {
    return main_type() == ace::OpParameter_RequantizationRange ? static_cast<const ace::RequantizationRange *>(main()) : nullptr;
  }
  const ace::Requantize *main_as_Requantize() const {
    return main_type() == ace::OpParameter_Requantize ? static_cast<const ace::Requantize *>(main()) : nullptr;
  }
  const ace::Reshape *main_as_Reshape() const {
    return main_type() == ace::OpParameter_Reshape ? static_cast<const ace::Reshape *>(main()) : nullptr;
  }
  const ace::Resize *main_as_Resize() const {
    return main_type() == ace::OpParameter_Resize ? static_cast<const ace::Resize *>(main()) : nullptr;
  }
  const ace::RoiParameters *main_as_RoiParameters() const {
    return main_type() == ace::OpParameter_RoiParameters ? static_cast<const ace::RoiParameters *>(main()) : nullptr;
  }
  const ace::Scale *main_as_Scale() const {
    return main_type() == ace::OpParameter_Scale ? static_cast<const ace::Scale *>(main()) : nullptr;
  }
  const ace::Selu *main_as_Selu() const {
    return main_type() == ace::OpParameter_Selu ? static_cast<const ace::Selu *>(main()) : nullptr;
  }
  const ace::Size *main_as_Size() const {
    return main_type() == ace::OpParameter_Size ? static_cast<const ace::Size *>(main()) : nullptr;
  }
  const ace::Slice *main_as_Slice() const {
    return main_type() == ace::OpParameter_Slice ? static_cast<const ace::Slice *>(main()) : nullptr;
  }
  const ace::SliceTf *main_as_SliceTf() const {
    return main_type() == ace::OpParameter_SliceTf ? static_cast<const ace::SliceTf *>(main()) : nullptr;
  }
  const ace::SpaceBatch *main_as_SpaceBatch() const {
    return main_type() == ace::OpParameter_SpaceBatch ? static_cast<const ace::SpaceBatch *>(main()) : nullptr;
  }
  const ace::SqueezeParam *main_as_SqueezeParam() const {
    return main_type() == ace::OpParameter_SqueezeParam ? static_cast<const ace::SqueezeParam *>(main()) : nullptr;
  }
  const ace::StridedSliceParam *main_as_StridedSliceParam() const {
    return main_type() == ace::OpParameter_StridedSliceParam ? static_cast<const ace::StridedSliceParam *>(main()) : nullptr;
  }
  const ace::TensorConvertInfo *main_as_TensorConvertInfo() const {
    return main_type() == ace::OpParameter_TensorConvertInfo ? static_cast<const ace::TensorConvertInfo *>(main()) : nullptr;
  }
  const ace::TfQuantizedConv2D *main_as_TfQuantizedConv2D() const {
    return main_type() == ace::OpParameter_TfQuantizedConv2D ? static_cast<const ace::TfQuantizedConv2D *>(main()) : nullptr;
  }
  const ace::TopKV2 *main_as_TopKV2() const {
    return main_type() == ace::OpParameter_TopKV2 ? static_cast<const ace::TopKV2 *>(main()) : nullptr;
  }
  const ace::Transpose *main_as_Transpose() const {
    return main_type() == ace::OpParameter_Transpose ? static_cast<const ace::Transpose *>(main()) : nullptr;
  }
  const ace::UnaryOp *main_as_UnaryOp() const {
    return main_type() == ace::OpParameter_UnaryOp ? static_cast<const ace::UnaryOp *>(main()) : nullptr;
  }
  const ace::MomentsParam *main_as_MomentsParam() const {
    return main_type() == ace::OpParameter_MomentsParam ? static_cast<const ace::MomentsParam *>(main()) : nullptr;
  }
  const ace::RNNParam *main_as_RNNParam() const {
    return main_type() == ace::OpParameter_RNNParam ? static_cast<const ace::RNNParam *>(main()) : nullptr;
  }
  const ace::BatchMatMulParam *main_as_BatchMatMulParam() const {
    return main_type() == ace::OpParameter_BatchMatMulParam ? static_cast<const ace::BatchMatMulParam *>(main()) : nullptr;
  }
  const ace::QuantizedFloatParam *main_as_QuantizedFloatParam() const {
    return main_type() == ace::OpParameter_QuantizedFloatParam ? static_cast<const ace::QuantizedFloatParam *>(main()) : nullptr;
  }
  const ace::DepthSpaceParam *main_as_DepthSpaceParam() const {
    return main_type() == ace::OpParameter_DepthSpaceParam ? static_cast<const ace::DepthSpaceParam *>(main()) : nullptr;
  }
  const ace::EltwiseInt8 *main_as_EltwiseInt8() const {
    return main_type() == ace::OpParameter_EltwiseInt8 ? static_cast<const ace::EltwiseInt8 *>(main()) : nullptr;
  }
  const ace::ReverseSequenceParam *main_as_ReverseSequenceParam() const {
    return main_type() == ace::OpParameter_ReverseSequenceParam ? static_cast<const ace::ReverseSequenceParam *>(main()) : nullptr;
  }
  const ace::Extra *main_as_Extra() const {
    return main_type() == ace::OpParameter_Extra ? static_cast<const ace::Extra *>(main()) : nullptr;
  }
  const ace::Pool3D *main_as_Pool3D() const {
    return main_type() == ace::OpParameter_Pool3D ? static_cast<const ace::Pool3D *>(main()) : nullptr;
  }
  const ace::Convolution3D *main_as_Convolution3D() const {
    return main_type() == ace::OpParameter_Convolution3D ? static_cast<const ace::Convolution3D *>(main()) : nullptr;
  }
  const ace::ELU *main_as_ELU() const {
    return main_type() == ace::OpParameter_ELU ? static_cast<const ace::ELU *>(main()) : nullptr;
  }
  const ace::DetectionPostProcessParam *main_as_DetectionPostProcessParam() const {
    return main_type() == ace::OpParameter_DetectionPostProcessParam ? static_cast<const ace::DetectionPostProcessParam *>(main()) : nullptr;
  }
  const ace::OneHotParam *main_as_OneHotParam() const {
    return main_type() == ace::OpParameter_OneHotParam ? static_cast<const ace::OneHotParam *>(main()) : nullptr;
  }
  const ace::PadParam *main_as_PadParam() const {
    return main_type() == ace::OpParameter_PadParam ? static_cast<const ace::PadParam *>(main()) : nullptr;
  }
  const ace::WhileParam *main_as_WhileParam() const {
    return main_type() == ace::OpParameter_WhileParam ? static_cast<const ace::WhileParam *>(main()) : nullptr;
  }
  const ace::IfParam *main_as_IfParam() const {
    return main_type() == ace::OpParameter_IfParam ? static_cast<const ace::IfParam *>(main()) : nullptr;
  }
  const ace::RandomUniform *main_as_RandomUniform() const {
    return main_type() == ace::OpParameter_RandomUniform ? static_cast<const ace::RandomUniform *>(main()) : nullptr;
  }
  const ace::LayerNorm *main_as_LayerNorm() const {
    return main_type() == ace::OpParameter_LayerNorm ? static_cast<const ace::LayerNorm *>(main()) : nullptr;
  }
  const ace::TensorArray *main_as_TensorArray() const {
    return main_type() == ace::OpParameter_TensorArray ? static_cast<const ace::TensorArray *>(main()) : nullptr;
  }
  const ace::LSTMBlockCell *main_as_LSTMBlockCell() const {
    return main_type() == ace::OpParameter_LSTMBlockCell ? static_cast<const ace::LSTMBlockCell *>(main()) : nullptr;
  }
  const ace::GridSample *main_as_GridSample() const {
    return main_type() == ace::OpParameter_GridSample ? static_cast<const ace::GridSample *>(main()) : nullptr;
  }
  const ace::LoopParam *main_as_LoopParam() const {
    return main_type() == ace::OpParameter_LoopParam ? static_cast<const ace::LoopParam *>(main()) : nullptr;
  }
  const ace::ImageProcessParam *main_as_ImageProcessParam() const {
    return main_type() == ace::OpParameter_ImageProcessParam ? static_cast<const ace::ImageProcessParam *>(main()) : nullptr;
  }
  const ace::CumSum *main_as_CumSum() const {
    return main_type() == ace::OpParameter_CumSum ? static_cast<const ace::CumSum *>(main()) : nullptr;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTINDEXES);
  }
  ace::OpType type() const {
    return static_cast<ace::OpType>(GetField<int32_t>(VT_TYPE, 0));
  }
  ace::DataFormat defaultDimentionFormat() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_DEFAULTDIMENTIONFORMAT, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTINDEXES) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyField<uint8_t>(verifier, VT_MAIN_TYPE, 1) &&
           VerifyOffset(verifier, VT_MAIN) &&
           VerifyOpParameter(verifier, main(), main_type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEXES) &&
           verifier.VerifyVector(outputIndexes()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<int8_t>(verifier, VT_DEFAULTDIMENTIONFORMAT, 1) &&
           verifier.EndTable();
  }
  OpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Op> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ace::QuantizedAdd *Op::main_as<ace::QuantizedAdd>() const {
  return main_as_QuantizedAdd();
}

template<> inline const ace::ArgMax *Op::main_as<ace::ArgMax>() const {
  return main_as_ArgMax();
}

template<> inline const ace::AsString *Op::main_as<ace::AsString>() const {
  return main_as_AsString();
}

template<> inline const ace::Axis *Op::main_as<ace::Axis>() const {
  return main_as_Axis();
}

template<> inline const ace::BatchNorm *Op::main_as<ace::BatchNorm>() const {
  return main_as_BatchNorm();
}

template<> inline const ace::BinaryOp *Op::main_as<ace::BinaryOp>() const {
  return main_as_BinaryOp();
}

template<> inline const ace::Blob *Op::main_as<ace::Blob>() const {
  return main_as_Blob();
}

template<> inline const ace::CastParam *Op::main_as<ace::CastParam>() const {
  return main_as_CastParam();
}

template<> inline const ace::Convolution2D *Op::main_as<ace::Convolution2D>() const {
  return main_as_Convolution2D();
}

template<> inline const ace::Crop *Op::main_as<ace::Crop>() const {
  return main_as_Crop();
}

template<> inline const ace::CropAndResize *Op::main_as<ace::CropAndResize>() const {
  return main_as_CropAndResize();
}

template<> inline const ace::Dequantize *Op::main_as<ace::Dequantize>() const {
  return main_as_Dequantize();
}

template<> inline const ace::DetectionOutput *Op::main_as<ace::DetectionOutput>() const {
  return main_as_DetectionOutput();
}

template<> inline const ace::Eltwise *Op::main_as<ace::Eltwise>() const {
  return main_as_Eltwise();
}

template<> inline const ace::ExpandDims *Op::main_as<ace::ExpandDims>() const {
  return main_as_ExpandDims();
}

template<> inline const ace::Fill *Op::main_as<ace::Fill>() const {
  return main_as_Fill();
}

template<> inline const ace::Flatten *Op::main_as<ace::Flatten>() const {
  return main_as_Flatten();
}

template<> inline const ace::Gather *Op::main_as<ace::Gather>() const {
  return main_as_Gather();
}

template<> inline const ace::GatherV2 *Op::main_as<ace::GatherV2>() const {
  return main_as_GatherV2();
}

template<> inline const ace::InnerProduct *Op::main_as<ace::InnerProduct>() const {
  return main_as_InnerProduct();
}

template<> inline const ace::Input *Op::main_as<ace::Input>() const {
  return main_as_Input();
}

template<> inline const ace::Interp *Op::main_as<ace::Interp>() const {
  return main_as_Interp();
}

template<> inline const ace::LRN *Op::main_as<ace::LRN>() const {
  return main_as_LRN();
}

template<> inline const ace::LSTM *Op::main_as<ace::LSTM>() const {
  return main_as_LSTM();
}

template<> inline const ace::MatMul *Op::main_as<ace::MatMul>() const {
  return main_as_MatMul();
}

template<> inline const ace::NonMaxSuppressionV2 *Op::main_as<ace::NonMaxSuppressionV2>() const {
  return main_as_NonMaxSuppressionV2();
}

template<> inline const ace::Normalize *Op::main_as<ace::Normalize>() const {
  return main_as_Normalize();
}

template<> inline const ace::PackParam *Op::main_as<ace::PackParam>() const {
  return main_as_PackParam();
}

template<> inline const ace::Permute *Op::main_as<ace::Permute>() const {
  return main_as_Permute();
}

template<> inline const ace::Plugin *Op::main_as<ace::Plugin>() const {
  return main_as_Plugin();
}

template<> inline const ace::Pool *Op::main_as<ace::Pool>() const {
  return main_as_Pool();
}

template<> inline const ace::PRelu *Op::main_as<ace::PRelu>() const {
  return main_as_PRelu();
}

template<> inline const ace::PriorBox *Op::main_as<ace::PriorBox>() const {
  return main_as_PriorBox();
}

template<> inline const ace::Proposal *Op::main_as<ace::Proposal>() const {
  return main_as_Proposal();
}

template<> inline const ace::QuantizedAvgPool *Op::main_as<ace::QuantizedAvgPool>() const {
  return main_as_QuantizedAvgPool();
}

template<> inline const ace::QuantizedBiasAdd *Op::main_as<ace::QuantizedBiasAdd>() const {
  return main_as_QuantizedBiasAdd();
}

template<> inline const ace::QuantizedConcat *Op::main_as<ace::QuantizedConcat>() const {
  return main_as_QuantizedConcat();
}

template<> inline const ace::QuantizedLogistic *Op::main_as<ace::QuantizedLogistic>() const {
  return main_as_QuantizedLogistic();
}

template<> inline const ace::QuantizedMatMul *Op::main_as<ace::QuantizedMatMul>() const {
  return main_as_QuantizedMatMul();
}

template<> inline const ace::QuantizedMaxPool *Op::main_as<ace::QuantizedMaxPool>() const {
  return main_as_QuantizedMaxPool();
}

template<> inline const ace::QuantizedRelu *Op::main_as<ace::QuantizedRelu>() const {
  return main_as_QuantizedRelu();
}

template<> inline const ace::QuantizedRelu6 *Op::main_as<ace::QuantizedRelu6>() const {
  return main_as_QuantizedRelu6();
}

template<> inline const ace::QuantizedReshape *Op::main_as<ace::QuantizedReshape>() const {
  return main_as_QuantizedReshape();
}

template<> inline const ace::QuantizedSoftmax *Op::main_as<ace::QuantizedSoftmax>() const {
  return main_as_QuantizedSoftmax();
}

template<> inline const ace::QuantizeMaxMin *Op::main_as<ace::QuantizeMaxMin>() const {
  return main_as_QuantizeMaxMin();
}

template<> inline const ace::QuantizeV2 *Op::main_as<ace::QuantizeV2>() const {
  return main_as_QuantizeV2();
}

template<> inline const ace::Range *Op::main_as<ace::Range>() const {
  return main_as_Range();
}

template<> inline const ace::Rank *Op::main_as<ace::Rank>() const {
  return main_as_Rank();
}

template<> inline const ace::ReduceJoin *Op::main_as<ace::ReduceJoin>() const {
  return main_as_ReduceJoin();
}

template<> inline const ace::ReductionParam *Op::main_as<ace::ReductionParam>() const {
  return main_as_ReductionParam();
}

template<> inline const ace::Relu *Op::main_as<ace::Relu>() const {
  return main_as_Relu();
}

template<> inline const ace::Relu6 *Op::main_as<ace::Relu6>() const {
  return main_as_Relu6();
}

template<> inline const ace::RequantizationRange *Op::main_as<ace::RequantizationRange>() const {
  return main_as_RequantizationRange();
}

template<> inline const ace::Requantize *Op::main_as<ace::Requantize>() const {
  return main_as_Requantize();
}

template<> inline const ace::Reshape *Op::main_as<ace::Reshape>() const {
  return main_as_Reshape();
}

template<> inline const ace::Resize *Op::main_as<ace::Resize>() const {
  return main_as_Resize();
}

template<> inline const ace::RoiParameters *Op::main_as<ace::RoiParameters>() const {
  return main_as_RoiParameters();
}

template<> inline const ace::Scale *Op::main_as<ace::Scale>() const {
  return main_as_Scale();
}

template<> inline const ace::Selu *Op::main_as<ace::Selu>() const {
  return main_as_Selu();
}

template<> inline const ace::Size *Op::main_as<ace::Size>() const {
  return main_as_Size();
}

template<> inline const ace::Slice *Op::main_as<ace::Slice>() const {
  return main_as_Slice();
}

template<> inline const ace::SliceTf *Op::main_as<ace::SliceTf>() const {
  return main_as_SliceTf();
}

template<> inline const ace::SpaceBatch *Op::main_as<ace::SpaceBatch>() const {
  return main_as_SpaceBatch();
}

template<> inline const ace::SqueezeParam *Op::main_as<ace::SqueezeParam>() const {
  return main_as_SqueezeParam();
}

template<> inline const ace::StridedSliceParam *Op::main_as<ace::StridedSliceParam>() const {
  return main_as_StridedSliceParam();
}

template<> inline const ace::TensorConvertInfo *Op::main_as<ace::TensorConvertInfo>() const {
  return main_as_TensorConvertInfo();
}

template<> inline const ace::TfQuantizedConv2D *Op::main_as<ace::TfQuantizedConv2D>() const {
  return main_as_TfQuantizedConv2D();
}

template<> inline const ace::TopKV2 *Op::main_as<ace::TopKV2>() const {
  return main_as_TopKV2();
}

template<> inline const ace::Transpose *Op::main_as<ace::Transpose>() const {
  return main_as_Transpose();
}

template<> inline const ace::UnaryOp *Op::main_as<ace::UnaryOp>() const {
  return main_as_UnaryOp();
}

template<> inline const ace::MomentsParam *Op::main_as<ace::MomentsParam>() const {
  return main_as_MomentsParam();
}

template<> inline const ace::RNNParam *Op::main_as<ace::RNNParam>() const {
  return main_as_RNNParam();
}

template<> inline const ace::BatchMatMulParam *Op::main_as<ace::BatchMatMulParam>() const {
  return main_as_BatchMatMulParam();
}

template<> inline const ace::QuantizedFloatParam *Op::main_as<ace::QuantizedFloatParam>() const {
  return main_as_QuantizedFloatParam();
}

template<> inline const ace::DepthSpaceParam *Op::main_as<ace::DepthSpaceParam>() const {
  return main_as_DepthSpaceParam();
}

template<> inline const ace::EltwiseInt8 *Op::main_as<ace::EltwiseInt8>() const {
  return main_as_EltwiseInt8();
}

template<> inline const ace::ReverseSequenceParam *Op::main_as<ace::ReverseSequenceParam>() const {
  return main_as_ReverseSequenceParam();
}

template<> inline const ace::Extra *Op::main_as<ace::Extra>() const {
  return main_as_Extra();
}

template<> inline const ace::Pool3D *Op::main_as<ace::Pool3D>() const {
  return main_as_Pool3D();
}

template<> inline const ace::Convolution3D *Op::main_as<ace::Convolution3D>() const {
  return main_as_Convolution3D();
}

template<> inline const ace::ELU *Op::main_as<ace::ELU>() const {
  return main_as_ELU();
}

template<> inline const ace::DetectionPostProcessParam *Op::main_as<ace::DetectionPostProcessParam>() const {
  return main_as_DetectionPostProcessParam();
}

template<> inline const ace::OneHotParam *Op::main_as<ace::OneHotParam>() const {
  return main_as_OneHotParam();
}

template<> inline const ace::PadParam *Op::main_as<ace::PadParam>() const {
  return main_as_PadParam();
}

template<> inline const ace::WhileParam *Op::main_as<ace::WhileParam>() const {
  return main_as_WhileParam();
}

template<> inline const ace::IfParam *Op::main_as<ace::IfParam>() const {
  return main_as_IfParam();
}

template<> inline const ace::RandomUniform *Op::main_as<ace::RandomUniform>() const {
  return main_as_RandomUniform();
}

template<> inline const ace::LayerNorm *Op::main_as<ace::LayerNorm>() const {
  return main_as_LayerNorm();
}

template<> inline const ace::TensorArray *Op::main_as<ace::TensorArray>() const {
  return main_as_TensorArray();
}

template<> inline const ace::LSTMBlockCell *Op::main_as<ace::LSTMBlockCell>() const {
  return main_as_LSTMBlockCell();
}

template<> inline const ace::GridSample *Op::main_as<ace::GridSample>() const {
  return main_as_GridSample();
}

template<> inline const ace::LoopParam *Op::main_as<ace::LoopParam>() const {
  return main_as_LoopParam();
}

template<> inline const ace::ImageProcessParam *Op::main_as<ace::ImageProcessParam>() const {
  return main_as_ImageProcessParam();
}

template<> inline const ace::CumSum *Op::main_as<ace::CumSum>() const {
  return main_as_CumSum();
}

struct OpBuilder {
  typedef Op Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(Op::VT_INPUTINDEXES, inputIndexes);
  }
  void add_main_type(ace::OpParameter main_type) {
    fbb_.AddElement<uint8_t>(Op::VT_MAIN_TYPE, static_cast<uint8_t>(main_type), 0);
  }
  void add_main(flatbuffers::Offset<void> main) {
    fbb_.AddOffset(Op::VT_MAIN, main);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Op::VT_NAME, name);
  }
  void add_outputIndexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(Op::VT_OUTPUTINDEXES, outputIndexes);
  }
  void add_type(ace::OpType type) {
    fbb_.AddElement<int32_t>(Op::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_defaultDimentionFormat(ace::DataFormat defaultDimentionFormat) {
    fbb_.AddElement<int8_t>(Op::VT_DEFAULTDIMENTIONFORMAT, static_cast<int8_t>(defaultDimentionFormat), 1);
  }
  explicit OpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Op> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Op>(end);
    return o;
  }
};

inline flatbuffers::Offset<Op> CreateOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputIndexes = 0,
    ace::OpParameter main_type = ace::OpParameter_NONE,
    flatbuffers::Offset<void> main = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputIndexes = 0,
    ace::OpType type = ace::OpType_AbsVal,
    ace::DataFormat defaultDimentionFormat = ace::DataFormat_NHWC) {
  OpBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_name(name);
  builder_.add_main(main);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_defaultDimentionFormat(defaultDimentionFormat);
  builder_.add_main_type(main_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Op> CreateOpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *inputIndexes = nullptr,
    ace::OpParameter main_type = ace::OpParameter_NONE,
    flatbuffers::Offset<void> main = 0,
    const char *name = nullptr,
    const std::vector<int32_t> *outputIndexes = nullptr,
    ace::OpType type = ace::OpType_AbsVal,
    ace::DataFormat defaultDimentionFormat = ace::DataFormat_NHWC) {
  auto inputIndexes__ = inputIndexes ? _fbb.CreateVector<int32_t>(*inputIndexes) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto outputIndexes__ = outputIndexes ? _fbb.CreateVector<int32_t>(*outputIndexes) : 0;
  return ace::CreateOp(
      _fbb,
      inputIndexes__,
      main_type,
      main,
      name__,
      outputIndexes__,
      type,
      defaultDimentionFormat);
}

flatbuffers::Offset<Op> CreateOp(flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ViewT : public flatbuffers::NativeTable {
  typedef View TableType;
  int32_t offset = 0;
  std::vector<int32_t> stride{};
};

struct View FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewT NativeTableType;
  typedef ViewBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ViewTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_STRIDE = 6
  };
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           verifier.EndTable();
  }
  ViewT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ViewT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<View> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ViewBuilder {
  typedef View Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(View::VT_OFFSET, offset, 0);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(View::VT_STRIDE, stride);
  }
  explicit ViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<View> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<View>(end);
    return o;
  }
};

inline flatbuffers::Offset<View> CreateView(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0) {
  ViewBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_offset(offset);
  return builder_.Finish();
}

inline flatbuffers::Offset<View> CreateViewDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    const std::vector<int32_t> *stride = nullptr) {
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return ace::CreateView(
      _fbb,
      offset,
      stride__);
}

flatbuffers::Offset<View> CreateView(flatbuffers::FlatBufferBuilder &_fbb, const ViewT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionT : public flatbuffers::NativeTable {
  typedef Region TableType;
  std::unique_ptr<ace::ViewT> src{};
  std::unique_ptr<ace::ViewT> dst{};
  std::vector<int32_t> size{};
  int32_t origin = 0;
  RegionT() = default;
  RegionT(const RegionT &o);
  RegionT(RegionT&&) FLATBUFFERS_NOEXCEPT = default;
  RegionT &operator=(RegionT o) FLATBUFFERS_NOEXCEPT;
};

struct Region FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegionT NativeTableType;
  typedef RegionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC = 4,
    VT_DST = 6,
    VT_SIZE = 8,
    VT_ORIGIN = 10
  };
  const ace::View *src() const {
    return GetPointer<const ace::View *>(VT_SRC);
  }
  const ace::View *dst() const {
    return GetPointer<const ace::View *>(VT_DST);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  int32_t origin() const {
    return GetField<int32_t>(VT_ORIGIN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.VerifyTable(src()) &&
           VerifyOffset(verifier, VT_DST) &&
           verifier.VerifyTable(dst()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           VerifyField<int32_t>(verifier, VT_ORIGIN, 4) &&
           verifier.EndTable();
  }
  RegionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Region> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionBuilder {
  typedef Region Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<ace::View> src) {
    fbb_.AddOffset(Region::VT_SRC, src);
  }
  void add_dst(flatbuffers::Offset<ace::View> dst) {
    fbb_.AddOffset(Region::VT_DST, dst);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Region::VT_SIZE, size);
  }
  void add_origin(int32_t origin) {
    fbb_.AddElement<int32_t>(Region::VT_ORIGIN, origin, 0);
  }
  explicit RegionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Region> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Region>(end);
    return o;
  }
};

inline flatbuffers::Offset<Region> CreateRegion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::View> src = 0,
    flatbuffers::Offset<ace::View> dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    int32_t origin = 0) {
  RegionBuilder builder_(_fbb);
  builder_.add_origin(origin);
  builder_.add_size(size);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Region> CreateRegionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::View> src = 0,
    flatbuffers::Offset<ace::View> dst = 0,
    const std::vector<int32_t> *size = nullptr,
    int32_t origin = 0) {
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  return ace::CreateRegion(
      _fbb,
      src,
      dst,
      size__,
      origin);
}

flatbuffers::Offset<Region> CreateRegion(flatbuffers::FlatBufferBuilder &_fbb, const RegionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorDescribeT : public flatbuffers::NativeTable {
  typedef TensorDescribe TableType;
  std::unique_ptr<ace::BlobT> blob{};
  int32_t index = 0;
  std::string name{};
  std::vector<std::unique_ptr<ace::RegionT>> regions{};
  std::unique_ptr<ace::TensorQuantInfoT> quantInfo{};
  TensorDescribeT() = default;
  TensorDescribeT(const TensorDescribeT &o);
  TensorDescribeT(TensorDescribeT&&) FLATBUFFERS_NOEXCEPT = default;
  TensorDescribeT &operator=(TensorDescribeT o) FLATBUFFERS_NOEXCEPT;
};

struct TensorDescribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorDescribeT NativeTableType;
  typedef TensorDescribeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorDescribeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOB = 4,
    VT_INDEX = 6,
    VT_NAME = 8,
    VT_REGIONS = 10,
    VT_QUANTINFO = 12
  };
  const ace::Blob *blob() const {
    return GetPointer<const ace::Blob *>(VT_BLOB);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Region>> *regions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Region>> *>(VT_REGIONS);
  }
  const ace::TensorQuantInfo *quantInfo() const {
    return GetPointer<const ace::TensorQuantInfo *>(VT_QUANTINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOB) &&
           verifier.VerifyTable(blob()) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REGIONS) &&
           verifier.VerifyVector(regions()) &&
           verifier.VerifyVectorOfTables(regions()) &&
           VerifyOffset(verifier, VT_QUANTINFO) &&
           verifier.VerifyTable(quantInfo()) &&
           verifier.EndTable();
  }
  TensorDescribeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorDescribeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorDescribe> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorDescribeBuilder {
  typedef TensorDescribe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blob(flatbuffers::Offset<ace::Blob> blob) {
    fbb_.AddOffset(TensorDescribe::VT_BLOB, blob);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(TensorDescribe::VT_INDEX, index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorDescribe::VT_NAME, name);
  }
  void add_regions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Region>>> regions) {
    fbb_.AddOffset(TensorDescribe::VT_REGIONS, regions);
  }
  void add_quantInfo(flatbuffers::Offset<ace::TensorQuantInfo> quantInfo) {
    fbb_.AddOffset(TensorDescribe::VT_QUANTINFO, quantInfo);
  }
  explicit TensorDescribeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorDescribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorDescribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Blob> blob = 0,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Region>>> regions = 0,
    flatbuffers::Offset<ace::TensorQuantInfo> quantInfo = 0) {
  TensorDescribeBuilder builder_(_fbb);
  builder_.add_quantInfo(quantInfo);
  builder_.add_regions(regions);
  builder_.add_name(name);
  builder_.add_index(index);
  builder_.add_blob(blob);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Blob> blob = 0,
    int32_t index = 0,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<ace::Region>> *regions = nullptr,
    flatbuffers::Offset<ace::TensorQuantInfo> quantInfo = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto regions__ = regions ? _fbb.CreateVector<flatbuffers::Offset<ace::Region>>(*regions) : 0;
  return ace::CreateTensorDescribe(
      _fbb,
      blob,
      index,
      name__,
      regions__,
      quantInfo);
}

flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphProtoT : public flatbuffers::NativeTable {
  typedef SubGraphProto TableType;
  std::string name{};
  std::vector<int32_t> inputs{};
  std::vector<int32_t> outputs{};
  std::vector<std::string> tensors{};
  std::vector<std::unique_ptr<ace::OpT>> nodes{};
  std::vector<std::unique_ptr<ace::TensorDescribeT>> extraTensorDescribe{};
  SubGraphProtoT() = default;
  SubGraphProtoT(const SubGraphProtoT &o);
  SubGraphProtoT(SubGraphProtoT&&) FLATBUFFERS_NOEXCEPT = default;
  SubGraphProtoT &operator=(SubGraphProtoT o) FLATBUFFERS_NOEXCEPT;
};

struct SubGraphProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphProtoT NativeTableType;
  typedef SubGraphProtoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGraphProtoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_TENSORS = 10,
    VT_NODES = 12,
    VT_EXTRATENSORDESCRIBE = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Op>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Op>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>> *extraTensorDescribe() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>> *>(VT_EXTRATENSORDESCRIBE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfStrings(tensors()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_EXTRATENSORDESCRIBE) &&
           verifier.VerifyVector(extraTensorDescribe()) &&
           verifier.VerifyVectorOfTables(extraTensorDescribe()) &&
           verifier.EndTable();
  }
  SubGraphProtoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraphProto> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphProtoBuilder {
  typedef SubGraphProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraphProto::VT_NAME, name);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraphProto::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraphProto::VT_OUTPUTS, outputs);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors) {
    fbb_.AddOffset(SubGraphProto::VT_TENSORS, tensors);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Op>>> nodes) {
    fbb_.AddOffset(SubGraphProto::VT_NODES, nodes);
  }
  void add_extraTensorDescribe(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>>> extraTensorDescribe) {
    fbb_.AddOffset(SubGraphProto::VT_EXTRATENSORDESCRIBE, extraTensorDescribe);
  }
  explicit SubGraphProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGraphProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraphProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Op>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>>> extraTensorDescribe = 0) {
  SubGraphProtoBuilder builder_(_fbb);
  builder_.add_extraTensorDescribe(extraTensorDescribe);
  builder_.add_nodes(nodes);
  builder_.add_tensors(tensors);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tensors = nullptr,
    const std::vector<flatbuffers::Offset<ace::Op>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<ace::TensorDescribe>> *extraTensorDescribe = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tensors) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<ace::Op>>(*nodes) : 0;
  auto extraTensorDescribe__ = extraTensorDescribe ? _fbb.CreateVector<flatbuffers::Offset<ace::TensorDescribe>>(*extraTensorDescribe) : 0;
  return ace::CreateSubGraphProto(
      _fbb,
      name__,
      inputs__,
      outputs__,
      tensors__,
      nodes__,
      extraTensorDescribe__);
}

flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorQuantInfoT : public flatbuffers::NativeTable {
  typedef TensorQuantInfo TableType;
  float scale = 0.0f;
  float zero = 0.0f;
  float min = -128.0f;
  float max = 127.0f;
  ace::DataType type = ace::DataType_DT_INVALID;
};

struct TensorQuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorQuantInfoT NativeTableType;
  typedef TensorQuantInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorQuantInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZERO = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_TYPE = 12
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float zero() const {
    return GetField<float>(VT_ZERO, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, -128.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 127.0f);
  }
  ace::DataType type() const {
    return static_cast<ace::DataType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<float>(verifier, VT_ZERO, 4) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
  TensorQuantInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorQuantInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorQuantInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorQuantInfoBuilder {
  typedef TensorQuantInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_SCALE, scale, 0.0f);
  }
  void add_zero(float zero) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_ZERO, zero, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_MIN, min, -128.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_MAX, max, 127.0f);
  }
  void add_type(ace::DataType type) {
    fbb_.AddElement<int32_t>(TensorQuantInfo::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit TensorQuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorQuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorQuantInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float zero = 0.0f,
    float min = -128.0f,
    float max = 127.0f,
    ace::DataType type = ace::DataType_DT_INVALID) {
  TensorQuantInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_zero(zero);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NetT : public flatbuffers::NativeTable {
  typedef Net TableType;
  std::string bizCode{};
  std::vector<std::unique_ptr<ace::TensorDescribeT>> extraTensorDescribe{};
  std::unique_ptr<ace::ExtraInfoT> extraInfo{};
  std::vector<std::unique_ptr<ace::OpT>> oplists{};
  std::vector<std::string> outputName{};
  ace::ForwardType preferForwardType = ace::ForwardType_CPU;
  ace::NetSource sourceType = ace::NetSource_CAFFE;
  std::vector<std::string> tensorName{};
  int32_t tensorNumber = 0;
  ace::Usage usage = ace::Usage_INFERENCE;
  std::vector<std::unique_ptr<ace::SubGraphProtoT>> subgraphs{};
  std::string uuid{};
  NetT() = default;
  NetT(const NetT &o);
  NetT(NetT&&) FLATBUFFERS_NOEXCEPT = default;
  NetT &operator=(NetT o) FLATBUFFERS_NOEXCEPT;
};

struct Net FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetT NativeTableType;
  typedef NetBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NetTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIZCODE = 4,
    VT_EXTRATENSORDESCRIBE = 6,
    VT_EXTRAINFO = 8,
    VT_OPLISTS = 10,
    VT_OUTPUTNAME = 12,
    VT_PREFERFORWARDTYPE = 14,
    VT_SOURCETYPE = 16,
    VT_TENSORNAME = 18,
    VT_TENSORNUMBER = 20,
    VT_USAGE = 22,
    VT_SUBGRAPHS = 24,
    VT_UUID = 26
  };
  const flatbuffers::String *bizCode() const {
    return GetPointer<const flatbuffers::String *>(VT_BIZCODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>> *extraTensorDescribe() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>> *>(VT_EXTRATENSORDESCRIBE);
  }
  const ace::ExtraInfo *extraInfo() const {
    return GetPointer<const ace::ExtraInfo *>(VT_EXTRAINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Op>> *oplists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Op>> *>(VT_OPLISTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputName() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTNAME);
  }
  ace::ForwardType preferForwardType() const {
    return static_cast<ace::ForwardType>(GetField<int8_t>(VT_PREFERFORWARDTYPE, 0));
  }
  ace::NetSource sourceType() const {
    return static_cast<ace::NetSource>(GetField<int8_t>(VT_SOURCETYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensorName() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TENSORNAME);
  }
  int32_t tensorNumber() const {
    return GetField<int32_t>(VT_TENSORNUMBER, 0);
  }
  ace::Usage usage() const {
    return static_cast<ace::Usage>(GetField<int8_t>(VT_USAGE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::SubGraphProto>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::SubGraphProto>> *>(VT_SUBGRAPHS);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BIZCODE) &&
           verifier.VerifyString(bizCode()) &&
           VerifyOffset(verifier, VT_EXTRATENSORDESCRIBE) &&
           verifier.VerifyVector(extraTensorDescribe()) &&
           verifier.VerifyVectorOfTables(extraTensorDescribe()) &&
           VerifyOffset(verifier, VT_EXTRAINFO) &&
           verifier.VerifyTable(extraInfo()) &&
           VerifyOffset(verifier, VT_OPLISTS) &&
           verifier.VerifyVector(oplists()) &&
           verifier.VerifyVectorOfTables(oplists()) &&
           VerifyOffset(verifier, VT_OUTPUTNAME) &&
           verifier.VerifyVector(outputName()) &&
           verifier.VerifyVectorOfStrings(outputName()) &&
           VerifyField<int8_t>(verifier, VT_PREFERFORWARDTYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_SOURCETYPE, 1) &&
           VerifyOffset(verifier, VT_TENSORNAME) &&
           verifier.VerifyVector(tensorName()) &&
           verifier.VerifyVectorOfStrings(tensorName()) &&
           VerifyField<int32_t>(verifier, VT_TENSORNUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_USAGE, 1) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           verifier.EndTable();
  }
  NetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Net> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetBuilder {
  typedef Net Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bizCode(flatbuffers::Offset<flatbuffers::String> bizCode) {
    fbb_.AddOffset(Net::VT_BIZCODE, bizCode);
  }
  void add_extraTensorDescribe(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>>> extraTensorDescribe) {
    fbb_.AddOffset(Net::VT_EXTRATENSORDESCRIBE, extraTensorDescribe);
  }
  void add_extraInfo(flatbuffers::Offset<ace::ExtraInfo> extraInfo) {
    fbb_.AddOffset(Net::VT_EXTRAINFO, extraInfo);
  }
  void add_oplists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Op>>> oplists) {
    fbb_.AddOffset(Net::VT_OPLISTS, oplists);
  }
  void add_outputName(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputName) {
    fbb_.AddOffset(Net::VT_OUTPUTNAME, outputName);
  }
  void add_preferForwardType(ace::ForwardType preferForwardType) {
    fbb_.AddElement<int8_t>(Net::VT_PREFERFORWARDTYPE, static_cast<int8_t>(preferForwardType), 0);
  }
  void add_sourceType(ace::NetSource sourceType) {
    fbb_.AddElement<int8_t>(Net::VT_SOURCETYPE, static_cast<int8_t>(sourceType), 0);
  }
  void add_tensorName(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensorName) {
    fbb_.AddOffset(Net::VT_TENSORNAME, tensorName);
  }
  void add_tensorNumber(int32_t tensorNumber) {
    fbb_.AddElement<int32_t>(Net::VT_TENSORNUMBER, tensorNumber, 0);
  }
  void add_usage(ace::Usage usage) {
    fbb_.AddElement<int8_t>(Net::VT_USAGE, static_cast<int8_t>(usage), 0);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::SubGraphProto>>> subgraphs) {
    fbb_.AddOffset(Net::VT_SUBGRAPHS, subgraphs);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Net::VT_UUID, uuid);
  }
  explicit NetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Net> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Net>(end);
    return o;
  }
};

inline flatbuffers::Offset<Net> CreateNet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> bizCode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::TensorDescribe>>> extraTensorDescribe = 0,
    flatbuffers::Offset<ace::ExtraInfo> extraInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Op>>> oplists = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputName = 0,
    ace::ForwardType preferForwardType = ace::ForwardType_CPU,
    ace::NetSource sourceType = ace::NetSource_CAFFE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensorName = 0,
    int32_t tensorNumber = 0,
    ace::Usage usage = ace::Usage_INFERENCE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::SubGraphProto>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  NetBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_subgraphs(subgraphs);
  builder_.add_tensorNumber(tensorNumber);
  builder_.add_tensorName(tensorName);
  builder_.add_outputName(outputName);
  builder_.add_oplists(oplists);
  builder_.add_extraInfo(extraInfo);
  builder_.add_extraTensorDescribe(extraTensorDescribe);
  builder_.add_bizCode(bizCode);
  builder_.add_usage(usage);
  builder_.add_sourceType(sourceType);
  builder_.add_preferForwardType(preferForwardType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Net> CreateNetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *bizCode = nullptr,
    const std::vector<flatbuffers::Offset<ace::TensorDescribe>> *extraTensorDescribe = nullptr,
    flatbuffers::Offset<ace::ExtraInfo> extraInfo = 0,
    const std::vector<flatbuffers::Offset<ace::Op>> *oplists = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputName = nullptr,
    ace::ForwardType preferForwardType = ace::ForwardType_CPU,
    ace::NetSource sourceType = ace::NetSource_CAFFE,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tensorName = nullptr,
    int32_t tensorNumber = 0,
    ace::Usage usage = ace::Usage_INFERENCE,
    const std::vector<flatbuffers::Offset<ace::SubGraphProto>> *subgraphs = nullptr,
    const char *uuid = nullptr) {
  auto bizCode__ = bizCode ? _fbb.CreateString(bizCode) : 0;
  auto extraTensorDescribe__ = extraTensorDescribe ? _fbb.CreateVector<flatbuffers::Offset<ace::TensorDescribe>>(*extraTensorDescribe) : 0;
  auto oplists__ = oplists ? _fbb.CreateVector<flatbuffers::Offset<ace::Op>>(*oplists) : 0;
  auto outputName__ = outputName ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputName) : 0;
  auto tensorName__ = tensorName ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tensorName) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<ace::SubGraphProto>>(*subgraphs) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  return ace::CreateNet(
      _fbb,
      bizCode__,
      extraTensorDescribe__,
      extraInfo,
      oplists__,
      outputName__,
      preferForwardType,
      sourceType,
      tensorName__,
      tensorNumber,
      usage,
      subgraphs__,
      uuid__);
}

flatbuffers::Offset<Net> CreateNet(flatbuffers::FlatBufferBuilder &_fbb, const NetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PluginT::PluginT(const PluginT &o)
      : type(o.type) {
  attr.reserve(o.attr.size());
  for (const auto &attr_ : o.attr) { attr.emplace_back((attr_) ? new ace::AttributeT(*attr_) : nullptr); }
}

inline PluginT &PluginT::operator=(PluginT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(attr, o.attr);
  return *this;
}

inline PluginT *Plugin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PluginT>(new PluginT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Plugin::UnPackTo(PluginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<ace::AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Plugin> Plugin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PluginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlugin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Plugin> CreatePlugin(flatbuffers::FlatBufferBuilder &_fbb, const PluginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PluginT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreatePlugin(
      _fbb,
      _type,
      _attr);
}

inline ExtraT::ExtraT(const ExtraT &o)
      : type(o.type),
        engine(o.engine),
        info(o.info) {
  attr.reserve(o.attr.size());
  for (const auto &attr_ : o.attr) { attr.emplace_back((attr_) ? new ace::AttributeT(*attr_) : nullptr); }
}

inline ExtraT &ExtraT::operator=(ExtraT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(engine, o.engine);
  std::swap(info, o.info);
  std::swap(attr, o.attr);
  return *this;
}

inline ExtraT *Extra::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExtraT>(new ExtraT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Extra::UnPackTo(ExtraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = engine(); if (_e) _o->engine = _e->str(); }
  { auto _e = info(); if (_e) { _o->info.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->info.begin()); } }
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<ace::AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Extra> Extra::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExtra(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Extra> CreateExtra(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExtraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _engine = _o->engine.empty() ? 0 : _fbb.CreateString(_o->engine);
  auto _info = _o->info.size() ? _fbb.CreateVector(_o->info) : 0;
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateExtra(
      _fbb,
      _type,
      _engine,
      _info,
      _attr);
}

inline StringVecT *StringVec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StringVecT>(new StringVecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringVec::UnPackTo(StringVecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<StringVec> StringVec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringVec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringVec> CreateStringVec(flatbuffers::FlatBufferBuilder &_fbb, const StringVecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StringVecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVectorOfStrings(_o->data) : 0;
  return ace::CreateStringVec(
      _fbb,
      _data);
}

inline WhileParamT::WhileParamT(const WhileParamT &o)
      : cond_graph(o.cond_graph),
        body_graph(o.body_graph),
        aliases_outputs(o.aliases_outputs) {
  aliases_inputs.reserve(o.aliases_inputs.size());
  for (const auto &aliases_inputs_ : o.aliases_inputs) { aliases_inputs.emplace_back((aliases_inputs_) ? new ace::StringVecT(*aliases_inputs_) : nullptr); }
  aliases_updates.reserve(o.aliases_updates.size());
  for (const auto &aliases_updates_ : o.aliases_updates) { aliases_updates.emplace_back((aliases_updates_) ? new ace::StringVecT(*aliases_updates_) : nullptr); }
}

inline WhileParamT &WhileParamT::operator=(WhileParamT o) FLATBUFFERS_NOEXCEPT {
  std::swap(cond_graph, o.cond_graph);
  std::swap(body_graph, o.body_graph);
  std::swap(aliases_inputs, o.aliases_inputs);
  std::swap(aliases_outputs, o.aliases_outputs);
  std::swap(aliases_updates, o.aliases_updates);
  return *this;
}

inline WhileParamT *WhileParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WhileParamT>(new WhileParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WhileParam::UnPackTo(WhileParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cond_graph(); if (_e) _o->cond_graph = _e->str(); }
  { auto _e = body_graph(); if (_e) _o->body_graph = _e->str(); }
  { auto _e = aliases_inputs(); if (_e) { _o->aliases_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_inputs[_i] = std::unique_ptr<ace::StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = aliases_outputs(); if (_e) { _o->aliases_outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_outputs[_i] = _e->Get(_i)->str(); } } }
  { auto _e = aliases_updates(); if (_e) { _o->aliases_updates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_updates[_i] = std::unique_ptr<ace::StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<WhileParam> WhileParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhileParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WhileParam> CreateWhileParam(flatbuffers::FlatBufferBuilder &_fbb, const WhileParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhileParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cond_graph = _o->cond_graph.empty() ? 0 : _fbb.CreateString(_o->cond_graph);
  auto _body_graph = _o->body_graph.empty() ? 0 : _fbb.CreateString(_o->body_graph);
  auto _aliases_inputs = _o->aliases_inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>> (_o->aliases_inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _aliases_outputs = _o->aliases_outputs.size() ? _fbb.CreateVectorOfStrings(_o->aliases_outputs) : 0;
  auto _aliases_updates = _o->aliases_updates.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>> (_o->aliases_updates.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_updates[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateWhileParam(
      _fbb,
      _cond_graph,
      _body_graph,
      _aliases_inputs,
      _aliases_outputs,
      _aliases_updates);
}

inline IfParamT::IfParamT(const IfParamT &o)
      : then_graph(o.then_graph),
        else_graph(o.else_graph) {
  aliases_inputs.reserve(o.aliases_inputs.size());
  for (const auto &aliases_inputs_ : o.aliases_inputs) { aliases_inputs.emplace_back((aliases_inputs_) ? new ace::StringVecT(*aliases_inputs_) : nullptr); }
  aliases_outputs.reserve(o.aliases_outputs.size());
  for (const auto &aliases_outputs_ : o.aliases_outputs) { aliases_outputs.emplace_back((aliases_outputs_) ? new ace::StringVecT(*aliases_outputs_) : nullptr); }
}

inline IfParamT &IfParamT::operator=(IfParamT o) FLATBUFFERS_NOEXCEPT {
  std::swap(then_graph, o.then_graph);
  std::swap(else_graph, o.else_graph);
  std::swap(aliases_inputs, o.aliases_inputs);
  std::swap(aliases_outputs, o.aliases_outputs);
  return *this;
}

inline IfParamT *IfParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IfParamT>(new IfParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IfParam::UnPackTo(IfParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = then_graph(); if (_e) _o->then_graph = _e->str(); }
  { auto _e = else_graph(); if (_e) _o->else_graph = _e->str(); }
  { auto _e = aliases_inputs(); if (_e) { _o->aliases_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_inputs[_i] = std::unique_ptr<ace::StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = aliases_outputs(); if (_e) { _o->aliases_outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aliases_outputs[_i] = std::unique_ptr<ace::StringVecT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<IfParam> IfParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIfParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IfParam> CreateIfParam(flatbuffers::FlatBufferBuilder &_fbb, const IfParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IfParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _then_graph = _o->then_graph.empty() ? 0 : _fbb.CreateString(_o->then_graph);
  auto _else_graph = _o->else_graph.empty() ? 0 : _fbb.CreateString(_o->else_graph);
  auto _aliases_inputs = _o->aliases_inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>> (_o->aliases_inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _aliases_outputs = _o->aliases_outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::StringVec>> (_o->aliases_outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateStringVec(*__va->__fbb, __va->__o->aliases_outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateIfParam(
      _fbb,
      _then_graph,
      _else_graph,
      _aliases_inputs,
      _aliases_outputs);
}

inline RegionCommandT::RegionCommandT(const RegionCommandT &o)
      : op((o.op) ? new ace::OpT(*o.op) : nullptr),
        steps(o.steps),
        size(o.size),
        indexes(o.indexes),
        fuse(o.fuse),
        iterIndexes(o.iterIndexes) {
  view.reserve(o.view.size());
  for (const auto &view_ : o.view) { view.emplace_back((view_) ? new ace::ViewT(*view_) : nullptr); }
}

inline RegionCommandT &RegionCommandT::operator=(RegionCommandT o) FLATBUFFERS_NOEXCEPT {
  std::swap(op, o.op);
  std::swap(steps, o.steps);
  std::swap(size, o.size);
  std::swap(indexes, o.indexes);
  std::swap(view, o.view);
  std::swap(fuse, o.fuse);
  std::swap(iterIndexes, o.iterIndexes);
  return *this;
}

inline RegionCommandT *RegionCommand::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RegionCommandT>(new RegionCommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegionCommand::UnPackTo(RegionCommandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op(); if (_e) _o->op = std::unique_ptr<ace::OpT>(_e->UnPack(_resolver)); }
  { auto _e = steps(); if (_e) { _o->steps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->steps[_i] = _e->Get(_i); } } }
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } }
  { auto _e = indexes(); if (_e) { _o->indexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indexes[_i] = _e->Get(_i); } } }
  { auto _e = view(); if (_e) { _o->view.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->view[_i] = std::unique_ptr<ace::ViewT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = fuse(); _o->fuse = _e; }
  { auto _e = iterIndexes(); if (_e) { _o->iterIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->iterIndexes[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<RegionCommand> RegionCommand::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegionCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegionCommand> CreateRegionCommand(flatbuffers::FlatBufferBuilder &_fbb, const RegionCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegionCommandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op = _o->op ? CreateOp(_fbb, _o->op.get(), _rehasher) : 0;
  auto _steps = _o->steps.size() ? _fbb.CreateVector(_o->steps) : 0;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _indexes = _o->indexes.size() ? _fbb.CreateVector(_o->indexes) : 0;
  auto _view = _o->view.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::View>> (_o->view.size(), [](size_t i, _VectorArgs *__va) { return CreateView(*__va->__fbb, __va->__o->view[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _fuse = _o->fuse;
  auto _iterIndexes = _o->iterIndexes.size() ? _fbb.CreateVector(_o->iterIndexes) : 0;
  return ace::CreateRegionCommand(
      _fbb,
      _op,
      _steps,
      _size,
      _indexes,
      _view,
      _fuse,
      _iterIndexes);
}

inline LoopParamT::LoopParamT(const LoopParamT &o)
      : tensorNumber(o.tensorNumber),
        outputIndexes(o.outputIndexes),
        inputIndexes(o.inputIndexes),
        parallel(o.parallel),
        loopNumber(o.loopNumber) {
  extraTensorInfos.reserve(o.extraTensorInfos.size());
  for (const auto &extraTensorInfos_ : o.extraTensorInfos) { extraTensorInfos.emplace_back((extraTensorInfos_) ? new ace::TensorDescribeT(*extraTensorInfos_) : nullptr); }
  commands.reserve(o.commands.size());
  for (const auto &commands_ : o.commands) { commands.emplace_back((commands_) ? new ace::RegionCommandT(*commands_) : nullptr); }
  initCommand.reserve(o.initCommand.size());
  for (const auto &initCommand_ : o.initCommand) { initCommand.emplace_back((initCommand_) ? new ace::RegionCommandT(*initCommand_) : nullptr); }
}

inline LoopParamT &LoopParamT::operator=(LoopParamT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tensorNumber, o.tensorNumber);
  std::swap(outputIndexes, o.outputIndexes);
  std::swap(inputIndexes, o.inputIndexes);
  std::swap(extraTensorInfos, o.extraTensorInfos);
  std::swap(parallel, o.parallel);
  std::swap(loopNumber, o.loopNumber);
  std::swap(commands, o.commands);
  std::swap(initCommand, o.initCommand);
  return *this;
}

inline LoopParamT *LoopParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LoopParamT>(new LoopParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoopParam::UnPackTo(LoopParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensorNumber(); _o->tensorNumber = _e; }
  { auto _e = outputIndexes(); if (_e) { _o->outputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndexes[_i] = _e->Get(_i); } } }
  { auto _e = inputIndexes(); if (_e) { _o->inputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndexes[_i] = _e->Get(_i); } } }
  { auto _e = extraTensorInfos(); if (_e) { _o->extraTensorInfos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraTensorInfos[_i] = std::unique_ptr<ace::TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = parallel(); _o->parallel = _e; }
  { auto _e = loopNumber(); _o->loopNumber = _e; }
  { auto _e = commands(); if (_e) { _o->commands.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commands[_i] = std::unique_ptr<ace::RegionCommandT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = initCommand(); if (_e) { _o->initCommand.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->initCommand[_i] = std::unique_ptr<ace::RegionCommandT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<LoopParam> LoopParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoopParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoopParam> CreateLoopParam(flatbuffers::FlatBufferBuilder &_fbb, const LoopParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoopParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensorNumber = _o->tensorNumber;
  auto _outputIndexes = _o->outputIndexes.size() ? _fbb.CreateVector(_o->outputIndexes) : 0;
  auto _inputIndexes = _o->inputIndexes.size() ? _fbb.CreateVector(_o->inputIndexes) : 0;
  auto _extraTensorInfos = _o->extraTensorInfos.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::TensorDescribe>> (_o->extraTensorInfos.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extraTensorInfos[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _parallel = _o->parallel;
  auto _loopNumber = _o->loopNumber;
  auto _commands = _o->commands.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::RegionCommand>> (_o->commands.size(), [](size_t i, _VectorArgs *__va) { return CreateRegionCommand(*__va->__fbb, __va->__o->commands[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _initCommand = _o->initCommand.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::RegionCommand>> (_o->initCommand.size(), [](size_t i, _VectorArgs *__va) { return CreateRegionCommand(*__va->__fbb, __va->__o->initCommand[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateLoopParam(
      _fbb,
      _tensorNumber,
      _outputIndexes,
      _inputIndexes,
      _extraTensorInfos,
      _parallel,
      _loopNumber,
      _commands,
      _initCommand);
}

inline OpT *Op::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OpT>(new OpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Op::UnPackTo(OpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = inputIndexes(); if (_e) { _o->inputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndexes[_i] = _e->Get(_i); } } }
  { auto _e = main_type(); _o->main.type = _e; }
  { auto _e = main(); if (_e) _o->main.value = ace::OpParameterUnion::UnPack(_e, main_type(), _resolver); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = outputIndexes(); if (_e) { _o->outputIndexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndexes[_i] = _e->Get(_i); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = defaultDimentionFormat(); _o->defaultDimentionFormat = _e; }
}

inline flatbuffers::Offset<Op> Op::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Op> CreateOp(flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _inputIndexes = _o->inputIndexes.size() ? _fbb.CreateVector(_o->inputIndexes) : 0;
  auto _main_type = _o->main.type;
  auto _main = _o->main.Pack(_fbb);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _outputIndexes = _o->outputIndexes.size() ? _fbb.CreateVector(_o->outputIndexes) : 0;
  auto _type = _o->type;
  auto _defaultDimentionFormat = _o->defaultDimentionFormat;
  return ace::CreateOp(
      _fbb,
      _inputIndexes,
      _main_type,
      _main,
      _name,
      _outputIndexes,
      _type,
      _defaultDimentionFormat);
}

inline ViewT *View::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ViewT>(new ViewT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void View::UnPackTo(ViewT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<View> View::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateView(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<View> CreateView(flatbuffers::FlatBufferBuilder &_fbb, const ViewT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ViewT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset = _o->offset;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  return ace::CreateView(
      _fbb,
      _offset,
      _stride);
}

inline RegionT::RegionT(const RegionT &o)
      : src((o.src) ? new ace::ViewT(*o.src) : nullptr),
        dst((o.dst) ? new ace::ViewT(*o.dst) : nullptr),
        size(o.size),
        origin(o.origin) {
}

inline RegionT &RegionT::operator=(RegionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(src, o.src);
  std::swap(dst, o.dst);
  std::swap(size, o.size);
  std::swap(origin, o.origin);
  return *this;
}

inline RegionT *Region::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RegionT>(new RegionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Region::UnPackTo(RegionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = src(); if (_e) _o->src = std::unique_ptr<ace::ViewT>(_e->UnPack(_resolver)); }
  { auto _e = dst(); if (_e) _o->dst = std::unique_ptr<ace::ViewT>(_e->UnPack(_resolver)); }
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } }
  { auto _e = origin(); _o->origin = _e; }
}

inline flatbuffers::Offset<Region> Region::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Region> CreateRegion(flatbuffers::FlatBufferBuilder &_fbb, const RegionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _src = _o->src ? CreateView(_fbb, _o->src.get(), _rehasher) : 0;
  auto _dst = _o->dst ? CreateView(_fbb, _o->dst.get(), _rehasher) : 0;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _origin = _o->origin;
  return ace::CreateRegion(
      _fbb,
      _src,
      _dst,
      _size,
      _origin);
}

inline TensorDescribeT::TensorDescribeT(const TensorDescribeT &o)
      : blob((o.blob) ? new ace::BlobT(*o.blob) : nullptr),
        index(o.index),
        name(o.name),
        quantInfo((o.quantInfo) ? new ace::TensorQuantInfoT(*o.quantInfo) : nullptr) {
  regions.reserve(o.regions.size());
  for (const auto &regions_ : o.regions) { regions.emplace_back((regions_) ? new ace::RegionT(*regions_) : nullptr); }
}

inline TensorDescribeT &TensorDescribeT::operator=(TensorDescribeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(blob, o.blob);
  std::swap(index, o.index);
  std::swap(name, o.name);
  std::swap(regions, o.regions);
  std::swap(quantInfo, o.quantInfo);
  return *this;
}

inline TensorDescribeT *TensorDescribe::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorDescribeT>(new TensorDescribeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorDescribe::UnPackTo(TensorDescribeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blob(); if (_e) _o->blob = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = index(); _o->index = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = regions(); if (_e) { _o->regions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regions[_i] = std::unique_ptr<ace::RegionT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = quantInfo(); if (_e) _o->quantInfo = std::unique_ptr<ace::TensorQuantInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<TensorDescribe> TensorDescribe::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorDescribe(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorDescribeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blob = _o->blob ? CreateBlob(_fbb, _o->blob.get(), _rehasher) : 0;
  auto _index = _o->index;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _regions = _o->regions.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Region>> (_o->regions.size(), [](size_t i, _VectorArgs *__va) { return CreateRegion(*__va->__fbb, __va->__o->regions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _quantInfo = _o->quantInfo ? CreateTensorQuantInfo(_fbb, _o->quantInfo.get(), _rehasher) : 0;
  return ace::CreateTensorDescribe(
      _fbb,
      _blob,
      _index,
      _name,
      _regions,
      _quantInfo);
}

inline SubGraphProtoT::SubGraphProtoT(const SubGraphProtoT &o)
      : name(o.name),
        inputs(o.inputs),
        outputs(o.outputs),
        tensors(o.tensors) {
  nodes.reserve(o.nodes.size());
  for (const auto &nodes_ : o.nodes) { nodes.emplace_back((nodes_) ? new ace::OpT(*nodes_) : nullptr); }
  extraTensorDescribe.reserve(o.extraTensorDescribe.size());
  for (const auto &extraTensorDescribe_ : o.extraTensorDescribe) { extraTensorDescribe.emplace_back((extraTensorDescribe_) ? new ace::TensorDescribeT(*extraTensorDescribe_) : nullptr); }
}

inline SubGraphProtoT &SubGraphProtoT::operator=(SubGraphProtoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(inputs, o.inputs);
  std::swap(outputs, o.outputs);
  std::swap(tensors, o.tensors);
  std::swap(nodes, o.nodes);
  std::swap(extraTensorDescribe, o.extraTensorDescribe);
  return *this;
}

inline SubGraphProtoT *SubGraphProto::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubGraphProtoT>(new SubGraphProtoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGraphProto::UnPackTo(SubGraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = _e->Get(_i)->str(); } } }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<ace::OpT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extraTensorDescribe(); if (_e) { _o->extraTensorDescribe.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraTensorDescribe[_i] = std::unique_ptr<ace::TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<SubGraphProto> SubGraphProto::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraphProto(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphProtoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVectorOfStrings(_o->tensors) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Op>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extraTensorDescribe = _o->extraTensorDescribe.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::TensorDescribe>> (_o->extraTensorDescribe.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extraTensorDescribe[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateSubGraphProto(
      _fbb,
      _name,
      _inputs,
      _outputs,
      _tensors,
      _nodes,
      _extraTensorDescribe);
}

inline TensorQuantInfoT *TensorQuantInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorQuantInfoT>(new TensorQuantInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorQuantInfo::UnPackTo(TensorQuantInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = zero(); _o->zero = _e; }
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<TensorQuantInfo> TensorQuantInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorQuantInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorQuantInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _zero = _o->zero;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _type = _o->type;
  return ace::CreateTensorQuantInfo(
      _fbb,
      _scale,
      _zero,
      _min,
      _max,
      _type);
}

inline NetT::NetT(const NetT &o)
      : bizCode(o.bizCode),
        extraInfo((o.extraInfo) ? new ace::ExtraInfoT(*o.extraInfo) : nullptr),
        outputName(o.outputName),
        preferForwardType(o.preferForwardType),
        sourceType(o.sourceType),
        tensorName(o.tensorName),
        tensorNumber(o.tensorNumber),
        usage(o.usage),
        uuid(o.uuid) {
  extraTensorDescribe.reserve(o.extraTensorDescribe.size());
  for (const auto &extraTensorDescribe_ : o.extraTensorDescribe) { extraTensorDescribe.emplace_back((extraTensorDescribe_) ? new ace::TensorDescribeT(*extraTensorDescribe_) : nullptr); }
  oplists.reserve(o.oplists.size());
  for (const auto &oplists_ : o.oplists) { oplists.emplace_back((oplists_) ? new ace::OpT(*oplists_) : nullptr); }
  subgraphs.reserve(o.subgraphs.size());
  for (const auto &subgraphs_ : o.subgraphs) { subgraphs.emplace_back((subgraphs_) ? new ace::SubGraphProtoT(*subgraphs_) : nullptr); }
}

inline NetT &NetT::operator=(NetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(bizCode, o.bizCode);
  std::swap(extraTensorDescribe, o.extraTensorDescribe);
  std::swap(extraInfo, o.extraInfo);
  std::swap(oplists, o.oplists);
  std::swap(outputName, o.outputName);
  std::swap(preferForwardType, o.preferForwardType);
  std::swap(sourceType, o.sourceType);
  std::swap(tensorName, o.tensorName);
  std::swap(tensorNumber, o.tensorNumber);
  std::swap(usage, o.usage);
  std::swap(subgraphs, o.subgraphs);
  std::swap(uuid, o.uuid);
  return *this;
}

inline NetT *Net::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NetT>(new NetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Net::UnPackTo(NetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bizCode(); if (_e) _o->bizCode = _e->str(); }
  { auto _e = extraTensorDescribe(); if (_e) { _o->extraTensorDescribe.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraTensorDescribe[_i] = std::unique_ptr<ace::TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extraInfo(); if (_e) _o->extraInfo = std::unique_ptr<ace::ExtraInfoT>(_e->UnPack(_resolver)); }
  { auto _e = oplists(); if (_e) { _o->oplists.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->oplists[_i] = std::unique_ptr<ace::OpT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = outputName(); if (_e) { _o->outputName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputName[_i] = _e->Get(_i)->str(); } } }
  { auto _e = preferForwardType(); _o->preferForwardType = _e; }
  { auto _e = sourceType(); _o->sourceType = _e; }
  { auto _e = tensorName(); if (_e) { _o->tensorName.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorName[_i] = _e->Get(_i)->str(); } } }
  { auto _e = tensorNumber(); _o->tensorNumber = _e; }
  { auto _e = usage(); _o->usage = _e; }
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subgraphs[_i] = std::unique_ptr<ace::SubGraphProtoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); }
}

inline flatbuffers::Offset<Net> Net::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Net> CreateNet(flatbuffers::FlatBufferBuilder &_fbb, const NetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bizCode = _o->bizCode.empty() ? 0 : _fbb.CreateString(_o->bizCode);
  auto _extraTensorDescribe = _o->extraTensorDescribe.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::TensorDescribe>> (_o->extraTensorDescribe.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extraTensorDescribe[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extraInfo = _o->extraInfo ? CreateExtraInfo(_fbb, _o->extraInfo.get(), _rehasher) : 0;
  auto _oplists = _o->oplists.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Op>> (_o->oplists.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->oplists[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputName = _o->outputName.size() ? _fbb.CreateVectorOfStrings(_o->outputName) : 0;
  auto _preferForwardType = _o->preferForwardType;
  auto _sourceType = _o->sourceType;
  auto _tensorName = _o->tensorName.size() ? _fbb.CreateVectorOfStrings(_o->tensorName) : 0;
  auto _tensorNumber = _o->tensorNumber;
  auto _usage = _o->usage;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::SubGraphProto>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraphProto(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _uuid = _o->uuid.empty() ? 0 : _fbb.CreateString(_o->uuid);
  return ace::CreateNet(
      _fbb,
      _bizCode,
      _extraTensorDescribe,
      _extraInfo,
      _oplists,
      _outputName,
      _preferForwardType,
      _sourceType,
      _tensorName,
      _tensorNumber,
      _usage,
      _subgraphs,
      _uuid);
}

inline bool VerifyOpParameter(flatbuffers::Verifier &verifier, const void *obj, OpParameter type) {
  switch (type) {
    case OpParameter_NONE: {
      return true;
    }
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const ace::QuantizedAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const ace::ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const ace::AsString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const ace::Axis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const ace::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const ace::BinaryOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const ace::Blob *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const ace::CastParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const ace::Convolution2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const ace::Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const ace::CropAndResize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const ace::Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const ace::DetectionOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const ace::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const ace::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const ace::Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const ace::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const ace::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const ace::GatherV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const ace::InnerProduct *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const ace::Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const ace::Interp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const ace::LRN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const ace::LSTM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const ace::MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const ace::NonMaxSuppressionV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const ace::Normalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const ace::PackParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const ace::Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const ace::Plugin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const ace::Pool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const ace::PRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const ace::PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const ace::Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const ace::QuantizedAvgPool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const ace::QuantizedBiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const ace::QuantizedConcat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const ace::QuantizedLogistic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const ace::QuantizedMatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const ace::QuantizedMaxPool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const ace::QuantizedRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const ace::QuantizedRelu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const ace::QuantizedReshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const ace::QuantizedSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const ace::QuantizeMaxMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const ace::QuantizeV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const ace::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const ace::Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const ace::ReduceJoin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const ace::ReductionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const ace::Relu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const ace::Relu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const ace::RequantizationRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const ace::Requantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const ace::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const ace::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const ace::RoiParameters *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const ace::Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const ace::Selu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const ace::Size *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const ace::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const ace::SliceTf *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const ace::SpaceBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const ace::SqueezeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const ace::StridedSliceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const ace::TensorConvertInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const ace::TfQuantizedConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const ace::TopKV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const ace::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const ace::UnaryOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const ace::MomentsParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const ace::RNNParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const ace::BatchMatMulParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const ace::QuantizedFloatParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const ace::DepthSpaceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const ace::EltwiseInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const ace::ReverseSequenceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const ace::Extra *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const ace::Pool3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const ace::Convolution3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const ace::ELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const ace::DetectionPostProcessParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const ace::OneHotParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const ace::PadParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const ace::WhileParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const ace::IfParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const ace::RandomUniform *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const ace::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const ace::TensorArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const ace::LSTMBlockCell *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const ace::GridSample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const ace::LoopParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const ace::ImageProcessParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const ace::CumSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParameter(
        verifier,  values->Get(i), types->GetEnum<OpParameter>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpParameterUnion::UnPack(const void *obj, OpParameter type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const ace::QuantizedAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const ace::ArgMax *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const ace::AsString *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const ace::Axis *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const ace::BatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const ace::BinaryOp *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const ace::Blob *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const ace::CastParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const ace::Convolution2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const ace::Crop *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const ace::CropAndResize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const ace::Dequantize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const ace::DetectionOutput *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const ace::Eltwise *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const ace::ExpandDims *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const ace::Fill *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const ace::Flatten *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const ace::Gather *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const ace::GatherV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const ace::InnerProduct *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const ace::Input *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const ace::Interp *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const ace::LRN *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const ace::LSTM *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const ace::MatMul *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const ace::NonMaxSuppressionV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const ace::Normalize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const ace::PackParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const ace::Permute *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const ace::Plugin *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const ace::Pool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const ace::PRelu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const ace::PriorBox *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const ace::Proposal *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const ace::QuantizedAvgPool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const ace::QuantizedBiasAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const ace::QuantizedConcat *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const ace::QuantizedLogistic *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const ace::QuantizedMatMul *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const ace::QuantizedMaxPool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const ace::QuantizedRelu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const ace::QuantizedRelu6 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const ace::QuantizedReshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const ace::QuantizedSoftmax *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const ace::QuantizeMaxMin *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const ace::QuantizeV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const ace::Range *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const ace::Rank *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const ace::ReduceJoin *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const ace::ReductionParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const ace::Relu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const ace::Relu6 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const ace::RequantizationRange *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const ace::Requantize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const ace::Reshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const ace::Resize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const ace::RoiParameters *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const ace::Scale *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const ace::Selu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const ace::Size *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const ace::Slice *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const ace::SliceTf *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const ace::SpaceBatch *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const ace::SqueezeParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const ace::StridedSliceParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const ace::TensorConvertInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const ace::TfQuantizedConv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const ace::TopKV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const ace::Transpose *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const ace::UnaryOp *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const ace::MomentsParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const ace::RNNParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const ace::BatchMatMulParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const ace::QuantizedFloatParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const ace::DepthSpaceParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const ace::EltwiseInt8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const ace::ReverseSequenceParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const ace::Extra *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const ace::Pool3D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const ace::Convolution3D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const ace::ELU *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const ace::DetectionPostProcessParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const ace::OneHotParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const ace::PadParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const ace::WhileParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const ace::IfParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const ace::RandomUniform *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const ace::LayerNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const ace::TensorArray *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const ace::LSTMBlockCell *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const ace::GridSample *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const ace::LoopParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const ace::ImageProcessParam *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const ace::CumSum *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OpParameterUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const ace::QuantizedAddT *>(value);
      return CreateQuantizedAdd(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const ace::ArgMaxT *>(value);
      return CreateArgMax(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const ace::AsStringT *>(value);
      return CreateAsString(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const ace::AxisT *>(value);
      return CreateAxis(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const ace::BatchNormT *>(value);
      return CreateBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const ace::BinaryOpT *>(value);
      return CreateBinaryOp(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const ace::BlobT *>(value);
      return CreateBlob(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const ace::CastParamT *>(value);
      return CreateCastParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const ace::Convolution2DT *>(value);
      return CreateConvolution2D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const ace::CropT *>(value);
      return CreateCrop(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const ace::CropAndResizeT *>(value);
      return CreateCropAndResize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const ace::DequantizeT *>(value);
      return CreateDequantize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const ace::DetectionOutputT *>(value);
      return CreateDetectionOutput(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const ace::EltwiseT *>(value);
      return CreateEltwise(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const ace::ExpandDimsT *>(value);
      return CreateExpandDims(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const ace::FillT *>(value);
      return CreateFill(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const ace::FlattenT *>(value);
      return CreateFlatten(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const ace::GatherT *>(value);
      return CreateGather(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const ace::GatherV2T *>(value);
      return CreateGatherV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const ace::InnerProductT *>(value);
      return CreateInnerProduct(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const ace::InputT *>(value);
      return CreateInput(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const ace::InterpT *>(value);
      return CreateInterp(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const ace::LRNT *>(value);
      return CreateLRN(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const ace::LSTMT *>(value);
      return CreateLSTM(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const ace::MatMulT *>(value);
      return CreateMatMul(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const ace::NonMaxSuppressionV2T *>(value);
      return CreateNonMaxSuppressionV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const ace::NormalizeT *>(value);
      return CreateNormalize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const ace::PackParamT *>(value);
      return CreatePackParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const ace::PermuteT *>(value);
      return CreatePermute(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const ace::PluginT *>(value);
      return CreatePlugin(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const ace::PoolT *>(value);
      return CreatePool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const ace::PReluT *>(value);
      return CreatePRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const ace::PriorBoxT *>(value);
      return CreatePriorBox(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const ace::ProposalT *>(value);
      return CreateProposal(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const ace::QuantizedAvgPoolT *>(value);
      return CreateQuantizedAvgPool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const ace::QuantizedBiasAddT *>(value);
      return CreateQuantizedBiasAdd(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const ace::QuantizedConcatT *>(value);
      return CreateQuantizedConcat(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const ace::QuantizedLogisticT *>(value);
      return CreateQuantizedLogistic(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const ace::QuantizedMatMulT *>(value);
      return CreateQuantizedMatMul(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const ace::QuantizedMaxPoolT *>(value);
      return CreateQuantizedMaxPool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const ace::QuantizedReluT *>(value);
      return CreateQuantizedRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const ace::QuantizedRelu6T *>(value);
      return CreateQuantizedRelu6(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const ace::QuantizedReshapeT *>(value);
      return CreateQuantizedReshape(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const ace::QuantizedSoftmaxT *>(value);
      return CreateQuantizedSoftmax(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const ace::QuantizeMaxMinT *>(value);
      return CreateQuantizeMaxMin(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const ace::QuantizeV2T *>(value);
      return CreateQuantizeV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const ace::RangeT *>(value);
      return CreateRange(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const ace::RankT *>(value);
      return CreateRank(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const ace::ReduceJoinT *>(value);
      return CreateReduceJoin(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const ace::ReductionParamT *>(value);
      return CreateReductionParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const ace::ReluT *>(value);
      return CreateRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const ace::Relu6T *>(value);
      return CreateRelu6(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const ace::RequantizationRangeT *>(value);
      return CreateRequantizationRange(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const ace::RequantizeT *>(value);
      return CreateRequantize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const ace::ReshapeT *>(value);
      return CreateReshape(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const ace::ResizeT *>(value);
      return CreateResize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const ace::RoiParametersT *>(value);
      return CreateRoiParameters(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const ace::ScaleT *>(value);
      return CreateScale(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const ace::SeluT *>(value);
      return CreateSelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const ace::SizeT *>(value);
      return CreateSize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const ace::SliceT *>(value);
      return CreateSlice(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const ace::SliceTfT *>(value);
      return CreateSliceTf(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const ace::SpaceBatchT *>(value);
      return CreateSpaceBatch(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const ace::SqueezeParamT *>(value);
      return CreateSqueezeParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const ace::StridedSliceParamT *>(value);
      return CreateStridedSliceParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const ace::TensorConvertInfoT *>(value);
      return CreateTensorConvertInfo(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const ace::TfQuantizedConv2DT *>(value);
      return CreateTfQuantizedConv2D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const ace::TopKV2T *>(value);
      return CreateTopKV2(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const ace::TransposeT *>(value);
      return CreateTranspose(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const ace::UnaryOpT *>(value);
      return CreateUnaryOp(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const ace::MomentsParamT *>(value);
      return CreateMomentsParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const ace::RNNParamT *>(value);
      return CreateRNNParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const ace::BatchMatMulParamT *>(value);
      return CreateBatchMatMulParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const ace::QuantizedFloatParamT *>(value);
      return CreateQuantizedFloatParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const ace::DepthSpaceParamT *>(value);
      return CreateDepthSpaceParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const ace::EltwiseInt8T *>(value);
      return CreateEltwiseInt8(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const ace::ReverseSequenceParamT *>(value);
      return CreateReverseSequenceParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const ace::ExtraT *>(value);
      return CreateExtra(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const ace::Pool3DT *>(value);
      return CreatePool3D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const ace::Convolution3DT *>(value);
      return CreateConvolution3D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const ace::ELUT *>(value);
      return CreateELU(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const ace::DetectionPostProcessParamT *>(value);
      return CreateDetectionPostProcessParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const ace::OneHotParamT *>(value);
      return CreateOneHotParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const ace::PadParamT *>(value);
      return CreatePadParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const ace::WhileParamT *>(value);
      return CreateWhileParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const ace::IfParamT *>(value);
      return CreateIfParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const ace::RandomUniformT *>(value);
      return CreateRandomUniform(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const ace::LayerNormT *>(value);
      return CreateLayerNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const ace::TensorArrayT *>(value);
      return CreateTensorArray(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const ace::LSTMBlockCellT *>(value);
      return CreateLSTMBlockCell(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const ace::GridSampleT *>(value);
      return CreateGridSample(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const ace::LoopParamT *>(value);
      return CreateLoopParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const ace::ImageProcessParamT *>(value);
      return CreateImageProcessParam(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const ace::CumSumT *>(value);
      return CreateCumSum(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpParameterUnion::OpParameterUnion(const OpParameterUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpParameter_QuantizedAdd: {
      value = new ace::QuantizedAddT(*reinterpret_cast<ace::QuantizedAddT *>(u.value));
      break;
    }
    case OpParameter_ArgMax: {
      value = new ace::ArgMaxT(*reinterpret_cast<ace::ArgMaxT *>(u.value));
      break;
    }
    case OpParameter_AsString: {
      value = new ace::AsStringT(*reinterpret_cast<ace::AsStringT *>(u.value));
      break;
    }
    case OpParameter_Axis: {
      value = new ace::AxisT(*reinterpret_cast<ace::AxisT *>(u.value));
      break;
    }
    case OpParameter_BatchNorm: {
      value = new ace::BatchNormT(*reinterpret_cast<ace::BatchNormT *>(u.value));
      break;
    }
    case OpParameter_BinaryOp: {
      value = new ace::BinaryOpT(*reinterpret_cast<ace::BinaryOpT *>(u.value));
      break;
    }
    case OpParameter_Blob: {
      value = new ace::BlobT(*reinterpret_cast<ace::BlobT *>(u.value));
      break;
    }
    case OpParameter_CastParam: {
      value = new ace::CastParamT(*reinterpret_cast<ace::CastParamT *>(u.value));
      break;
    }
    case OpParameter_Convolution2D: {
      value = new ace::Convolution2DT(*reinterpret_cast<ace::Convolution2DT *>(u.value));
      break;
    }
    case OpParameter_Crop: {
      value = new ace::CropT(*reinterpret_cast<ace::CropT *>(u.value));
      break;
    }
    case OpParameter_CropAndResize: {
      value = new ace::CropAndResizeT(*reinterpret_cast<ace::CropAndResizeT *>(u.value));
      break;
    }
    case OpParameter_Dequantize: {
      value = new ace::DequantizeT(*reinterpret_cast<ace::DequantizeT *>(u.value));
      break;
    }
    case OpParameter_DetectionOutput: {
      value = new ace::DetectionOutputT(*reinterpret_cast<ace::DetectionOutputT *>(u.value));
      break;
    }
    case OpParameter_Eltwise: {
      value = new ace::EltwiseT(*reinterpret_cast<ace::EltwiseT *>(u.value));
      break;
    }
    case OpParameter_ExpandDims: {
      value = new ace::ExpandDimsT(*reinterpret_cast<ace::ExpandDimsT *>(u.value));
      break;
    }
    case OpParameter_Fill: {
      value = new ace::FillT(*reinterpret_cast<ace::FillT *>(u.value));
      break;
    }
    case OpParameter_Flatten: {
      value = new ace::FlattenT(*reinterpret_cast<ace::FlattenT *>(u.value));
      break;
    }
    case OpParameter_Gather: {
      value = new ace::GatherT(*reinterpret_cast<ace::GatherT *>(u.value));
      break;
    }
    case OpParameter_GatherV2: {
      value = new ace::GatherV2T(*reinterpret_cast<ace::GatherV2T *>(u.value));
      break;
    }
    case OpParameter_InnerProduct: {
      value = new ace::InnerProductT(*reinterpret_cast<ace::InnerProductT *>(u.value));
      break;
    }
    case OpParameter_Input: {
      value = new ace::InputT(*reinterpret_cast<ace::InputT *>(u.value));
      break;
    }
    case OpParameter_Interp: {
      value = new ace::InterpT(*reinterpret_cast<ace::InterpT *>(u.value));
      break;
    }
    case OpParameter_LRN: {
      value = new ace::LRNT(*reinterpret_cast<ace::LRNT *>(u.value));
      break;
    }
    case OpParameter_LSTM: {
      value = new ace::LSTMT(*reinterpret_cast<ace::LSTMT *>(u.value));
      break;
    }
    case OpParameter_MatMul: {
      value = new ace::MatMulT(*reinterpret_cast<ace::MatMulT *>(u.value));
      break;
    }
    case OpParameter_NonMaxSuppressionV2: {
      value = new ace::NonMaxSuppressionV2T(*reinterpret_cast<ace::NonMaxSuppressionV2T *>(u.value));
      break;
    }
    case OpParameter_Normalize: {
      value = new ace::NormalizeT(*reinterpret_cast<ace::NormalizeT *>(u.value));
      break;
    }
    case OpParameter_PackParam: {
      value = new ace::PackParamT(*reinterpret_cast<ace::PackParamT *>(u.value));
      break;
    }
    case OpParameter_Permute: {
      value = new ace::PermuteT(*reinterpret_cast<ace::PermuteT *>(u.value));
      break;
    }
    case OpParameter_Plugin: {
      value = new ace::PluginT(*reinterpret_cast<ace::PluginT *>(u.value));
      break;
    }
    case OpParameter_Pool: {
      value = new ace::PoolT(*reinterpret_cast<ace::PoolT *>(u.value));
      break;
    }
    case OpParameter_PRelu: {
      value = new ace::PReluT(*reinterpret_cast<ace::PReluT *>(u.value));
      break;
    }
    case OpParameter_PriorBox: {
      value = new ace::PriorBoxT(*reinterpret_cast<ace::PriorBoxT *>(u.value));
      break;
    }
    case OpParameter_Proposal: {
      value = new ace::ProposalT(*reinterpret_cast<ace::ProposalT *>(u.value));
      break;
    }
    case OpParameter_QuantizedAvgPool: {
      value = new ace::QuantizedAvgPoolT(*reinterpret_cast<ace::QuantizedAvgPoolT *>(u.value));
      break;
    }
    case OpParameter_QuantizedBiasAdd: {
      value = new ace::QuantizedBiasAddT(*reinterpret_cast<ace::QuantizedBiasAddT *>(u.value));
      break;
    }
    case OpParameter_QuantizedConcat: {
      value = new ace::QuantizedConcatT(*reinterpret_cast<ace::QuantizedConcatT *>(u.value));
      break;
    }
    case OpParameter_QuantizedLogistic: {
      value = new ace::QuantizedLogisticT(*reinterpret_cast<ace::QuantizedLogisticT *>(u.value));
      break;
    }
    case OpParameter_QuantizedMatMul: {
      value = new ace::QuantizedMatMulT(*reinterpret_cast<ace::QuantizedMatMulT *>(u.value));
      break;
    }
    case OpParameter_QuantizedMaxPool: {
      value = new ace::QuantizedMaxPoolT(*reinterpret_cast<ace::QuantizedMaxPoolT *>(u.value));
      break;
    }
    case OpParameter_QuantizedRelu: {
      value = new ace::QuantizedReluT(*reinterpret_cast<ace::QuantizedReluT *>(u.value));
      break;
    }
    case OpParameter_QuantizedRelu6: {
      value = new ace::QuantizedRelu6T(*reinterpret_cast<ace::QuantizedRelu6T *>(u.value));
      break;
    }
    case OpParameter_QuantizedReshape: {
      value = new ace::QuantizedReshapeT(*reinterpret_cast<ace::QuantizedReshapeT *>(u.value));
      break;
    }
    case OpParameter_QuantizedSoftmax: {
      value = new ace::QuantizedSoftmaxT(*reinterpret_cast<ace::QuantizedSoftmaxT *>(u.value));
      break;
    }
    case OpParameter_QuantizeMaxMin: {
      value = new ace::QuantizeMaxMinT(*reinterpret_cast<ace::QuantizeMaxMinT *>(u.value));
      break;
    }
    case OpParameter_QuantizeV2: {
      value = new ace::QuantizeV2T(*reinterpret_cast<ace::QuantizeV2T *>(u.value));
      break;
    }
    case OpParameter_Range: {
      value = new ace::RangeT(*reinterpret_cast<ace::RangeT *>(u.value));
      break;
    }
    case OpParameter_Rank: {
      value = new ace::RankT(*reinterpret_cast<ace::RankT *>(u.value));
      break;
    }
    case OpParameter_ReduceJoin: {
      value = new ace::ReduceJoinT(*reinterpret_cast<ace::ReduceJoinT *>(u.value));
      break;
    }
    case OpParameter_ReductionParam: {
      value = new ace::ReductionParamT(*reinterpret_cast<ace::ReductionParamT *>(u.value));
      break;
    }
    case OpParameter_Relu: {
      value = new ace::ReluT(*reinterpret_cast<ace::ReluT *>(u.value));
      break;
    }
    case OpParameter_Relu6: {
      value = new ace::Relu6T(*reinterpret_cast<ace::Relu6T *>(u.value));
      break;
    }
    case OpParameter_RequantizationRange: {
      value = new ace::RequantizationRangeT(*reinterpret_cast<ace::RequantizationRangeT *>(u.value));
      break;
    }
    case OpParameter_Requantize: {
      value = new ace::RequantizeT(*reinterpret_cast<ace::RequantizeT *>(u.value));
      break;
    }
    case OpParameter_Reshape: {
      value = new ace::ReshapeT(*reinterpret_cast<ace::ReshapeT *>(u.value));
      break;
    }
    case OpParameter_Resize: {
      value = new ace::ResizeT(*reinterpret_cast<ace::ResizeT *>(u.value));
      break;
    }
    case OpParameter_RoiParameters: {
      value = new ace::RoiParametersT(*reinterpret_cast<ace::RoiParametersT *>(u.value));
      break;
    }
    case OpParameter_Scale: {
      value = new ace::ScaleT(*reinterpret_cast<ace::ScaleT *>(u.value));
      break;
    }
    case OpParameter_Selu: {
      value = new ace::SeluT(*reinterpret_cast<ace::SeluT *>(u.value));
      break;
    }
    case OpParameter_Size: {
      value = new ace::SizeT(*reinterpret_cast<ace::SizeT *>(u.value));
      break;
    }
    case OpParameter_Slice: {
      value = new ace::SliceT(*reinterpret_cast<ace::SliceT *>(u.value));
      break;
    }
    case OpParameter_SliceTf: {
      value = new ace::SliceTfT(*reinterpret_cast<ace::SliceTfT *>(u.value));
      break;
    }
    case OpParameter_SpaceBatch: {
      value = new ace::SpaceBatchT(*reinterpret_cast<ace::SpaceBatchT *>(u.value));
      break;
    }
    case OpParameter_SqueezeParam: {
      value = new ace::SqueezeParamT(*reinterpret_cast<ace::SqueezeParamT *>(u.value));
      break;
    }
    case OpParameter_StridedSliceParam: {
      value = new ace::StridedSliceParamT(*reinterpret_cast<ace::StridedSliceParamT *>(u.value));
      break;
    }
    case OpParameter_TensorConvertInfo: {
      value = new ace::TensorConvertInfoT(*reinterpret_cast<ace::TensorConvertInfoT *>(u.value));
      break;
    }
    case OpParameter_TfQuantizedConv2D: {
      value = new ace::TfQuantizedConv2DT(*reinterpret_cast<ace::TfQuantizedConv2DT *>(u.value));
      break;
    }
    case OpParameter_TopKV2: {
      value = new ace::TopKV2T(*reinterpret_cast<ace::TopKV2T *>(u.value));
      break;
    }
    case OpParameter_Transpose: {
      value = new ace::TransposeT(*reinterpret_cast<ace::TransposeT *>(u.value));
      break;
    }
    case OpParameter_UnaryOp: {
      value = new ace::UnaryOpT(*reinterpret_cast<ace::UnaryOpT *>(u.value));
      break;
    }
    case OpParameter_MomentsParam: {
      value = new ace::MomentsParamT(*reinterpret_cast<ace::MomentsParamT *>(u.value));
      break;
    }
    case OpParameter_RNNParam: {
      value = new ace::RNNParamT(*reinterpret_cast<ace::RNNParamT *>(u.value));
      break;
    }
    case OpParameter_BatchMatMulParam: {
      value = new ace::BatchMatMulParamT(*reinterpret_cast<ace::BatchMatMulParamT *>(u.value));
      break;
    }
    case OpParameter_QuantizedFloatParam: {
      value = new ace::QuantizedFloatParamT(*reinterpret_cast<ace::QuantizedFloatParamT *>(u.value));
      break;
    }
    case OpParameter_DepthSpaceParam: {
      value = new ace::DepthSpaceParamT(*reinterpret_cast<ace::DepthSpaceParamT *>(u.value));
      break;
    }
    case OpParameter_EltwiseInt8: {
      value = new ace::EltwiseInt8T(*reinterpret_cast<ace::EltwiseInt8T *>(u.value));
      break;
    }
    case OpParameter_ReverseSequenceParam: {
      value = new ace::ReverseSequenceParamT(*reinterpret_cast<ace::ReverseSequenceParamT *>(u.value));
      break;
    }
    case OpParameter_Extra: {
      value = new ace::ExtraT(*reinterpret_cast<ace::ExtraT *>(u.value));
      break;
    }
    case OpParameter_Pool3D: {
      value = new ace::Pool3DT(*reinterpret_cast<ace::Pool3DT *>(u.value));
      break;
    }
    case OpParameter_Convolution3D: {
      value = new ace::Convolution3DT(*reinterpret_cast<ace::Convolution3DT *>(u.value));
      break;
    }
    case OpParameter_ELU: {
      value = new ace::ELUT(*reinterpret_cast<ace::ELUT *>(u.value));
      break;
    }
    case OpParameter_DetectionPostProcessParam: {
      value = new ace::DetectionPostProcessParamT(*reinterpret_cast<ace::DetectionPostProcessParamT *>(u.value));
      break;
    }
    case OpParameter_OneHotParam: {
      value = new ace::OneHotParamT(*reinterpret_cast<ace::OneHotParamT *>(u.value));
      break;
    }
    case OpParameter_PadParam: {
      value = new ace::PadParamT(*reinterpret_cast<ace::PadParamT *>(u.value));
      break;
    }
    case OpParameter_WhileParam: {
      value = new ace::WhileParamT(*reinterpret_cast<ace::WhileParamT *>(u.value));
      break;
    }
    case OpParameter_IfParam: {
      value = new ace::IfParamT(*reinterpret_cast<ace::IfParamT *>(u.value));
      break;
    }
    case OpParameter_RandomUniform: {
      value = new ace::RandomUniformT(*reinterpret_cast<ace::RandomUniformT *>(u.value));
      break;
    }
    case OpParameter_LayerNorm: {
      value = new ace::LayerNormT(*reinterpret_cast<ace::LayerNormT *>(u.value));
      break;
    }
    case OpParameter_TensorArray: {
      value = new ace::TensorArrayT(*reinterpret_cast<ace::TensorArrayT *>(u.value));
      break;
    }
    case OpParameter_LSTMBlockCell: {
      value = new ace::LSTMBlockCellT(*reinterpret_cast<ace::LSTMBlockCellT *>(u.value));
      break;
    }
    case OpParameter_GridSample: {
      value = new ace::GridSampleT(*reinterpret_cast<ace::GridSampleT *>(u.value));
      break;
    }
    case OpParameter_LoopParam: {
      value = new ace::LoopParamT(*reinterpret_cast<ace::LoopParamT *>(u.value));
      break;
    }
    case OpParameter_ImageProcessParam: {
      value = new ace::ImageProcessParamT(*reinterpret_cast<ace::ImageProcessParamT *>(u.value));
      break;
    }
    case OpParameter_CumSum: {
      value = new ace::CumSumT(*reinterpret_cast<ace::CumSumT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpParameterUnion::Reset() {
  switch (type) {
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<ace::QuantizedAddT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<ace::ArgMaxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<ace::AsStringT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<ace::AxisT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<ace::BatchNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<ace::BinaryOpT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<ace::BlobT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<ace::CastParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<ace::Convolution2DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<ace::CropT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<ace::CropAndResizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<ace::DequantizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<ace::DetectionOutputT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<ace::EltwiseT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<ace::ExpandDimsT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<ace::FillT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<ace::FlattenT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<ace::GatherT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<ace::GatherV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<ace::InnerProductT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<ace::InputT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<ace::InterpT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<ace::LRNT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<ace::LSTMT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<ace::MatMulT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<ace::NonMaxSuppressionV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<ace::NormalizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<ace::PackParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<ace::PermuteT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<ace::PluginT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<ace::PoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<ace::PReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<ace::PriorBoxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<ace::ProposalT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<ace::QuantizedAvgPoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<ace::QuantizedBiasAddT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<ace::QuantizedConcatT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<ace::QuantizedLogisticT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<ace::QuantizedMatMulT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<ace::QuantizedMaxPoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<ace::QuantizedReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<ace::QuantizedRelu6T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<ace::QuantizedReshapeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<ace::QuantizedSoftmaxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<ace::QuantizeMaxMinT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<ace::QuantizeV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<ace::RangeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<ace::RankT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<ace::ReduceJoinT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<ace::ReductionParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<ace::ReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<ace::Relu6T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<ace::RequantizationRangeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<ace::RequantizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<ace::ReshapeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<ace::ResizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<ace::RoiParametersT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<ace::ScaleT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<ace::SeluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<ace::SizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<ace::SliceT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<ace::SliceTfT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<ace::SpaceBatchT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<ace::SqueezeParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<ace::StridedSliceParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<ace::TensorConvertInfoT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<ace::TfQuantizedConv2DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<ace::TopKV2T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<ace::TransposeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<ace::UnaryOpT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<ace::MomentsParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<ace::RNNParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<ace::BatchMatMulParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<ace::QuantizedFloatParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<ace::DepthSpaceParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<ace::EltwiseInt8T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<ace::ReverseSequenceParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<ace::ExtraT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<ace::Pool3DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<ace::Convolution3DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<ace::ELUT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<ace::DetectionPostProcessParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<ace::OneHotParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<ace::PadParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<ace::WhileParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<ace::IfParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<ace::RandomUniformT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<ace::LayerNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<ace::TensorArrayT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<ace::LSTMBlockCellT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<ace::GridSampleT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<ace::LoopParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<ace::ImageProcessParamT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<ace::CumSumT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpParameter_NONE;
}

inline const flatbuffers::TypeTable *OpTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::OpTypeTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 512, 513, 514, 515, 516, 517, 518, 600, 601, 603, 604 };
  static const char * const names[] = {
    "AbsVal",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "InstanceNorm",
    "BatchToSpaceND",
    "Copy",
    "BinaryOp",
    "Bnll",
    "Cast",
    "Concat",
    "Const",
    "Convolution",
    "ConvolutionDepthwise",
    "Crop",
    "CropAndResize",
    "ImageProcess",
    "Deconvolution",
    "DeconvolutionDepthwise",
    "Dequantize",
    "DetectionOutput",
    "Dropout",
    "Eltwise",
    "ELU",
    "Unique",
    "Exp",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Im2Col",
    "Gather",
    "GatherV2",
    "Im2Seq",
    "InnerProduct",
    "Input",
    "Interp",
    "Log",
    "LRN",
    "LSTM",
    "MatMul",
    "MVN",
    "NonMaxSuppression",
    "NonMaxSuppressionV2",
    "Normalize",
    "Pack",
    "Padding",
    "Permute",
    "Pooling",
    "Power",
    "PReLU",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedDepthwiseConv2D",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "Reduction",
    "ReLU",
    "ReLU6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RNN",
    "ROIPooling",
    "Scale",
    "Selu",
    "Seq2Out",
    "Shape",
    "Sigmoid",
    "Size",
    "Slice",
    "SliceTf",
    "Softmax",
    "SpaceToBatchND",
    "SpatialProduct",
    "Col2Im",
    "Segment",
    "Squeeze",
    "StridedSlice",
    "StringJoin",
    "StringSplit",
    "StringToNumber",
    "TanH",
    "TfQuantizedConv2D",
    "Threshold",
    "Tile",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "Unpack",
    "Where",
    "Moments",
    "RNNSequenceGRU",
    "BatchMatMul",
    "Unsqueeze",
    "CosineSimilarity",
    "DepthToSpace",
    "SpaceToDepth",
    "ReverseSequence",
    "Pooling3D",
    "Convolution3D",
    "MatrixBandPart",
    "GatherND",
    "DetectionPostProcess",
    "UnravelIndex",
    "ScatterNd",
    "OneHot",
    "BroadcastTo",
    "Dilation2D",
    "Interp3D",
    "Raster",
    "ConvertTensor",
    "ArgMin",
    "LinSpace",
    "RandomUniform",
    "TensorArray",
    "TensorArraySize",
    "TensorArrayRead",
    "TensorArrayWrite",
    "TensorArrayGather",
    "TensorArrayScatter",
    "TensorArraySplit",
    "TensorArrayConcat",
    "LSTMBlockCell",
    "Reverse",
    "ROIAlign",
    "RandomNormal",
    "TensorArrayInsert",
    "TensorArrayErase",
    "EyeLike",
    "CumSum",
    "Det",
    "CumProd",
    "ScatterElements",
    "GatherElements",
    "Svd",
    "Histogram",
    "Plugin",
    "Select",
    "ZerosLike",
    "Broastcast",
    "SetDiff1D",
    "ReluGrad",
    "Identity",
    "PoolGrad",
    "SoftmaxGrad",
    "Conv2DBackPropFilter",
    "TrainableParam",
    "BatchNorm",
    "ConvTranspose3D",
    "ZeroGrad",
    "Extra",
    "ConvInt8",
    "Int8ToFloat",
    "DepthwiseConvInt8",
    "PoolInt8",
    "FloatToInt8",
    "EltwiseInt8",
    "While",
    "If",
    "LayerNorm",
    "GridSample"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 175, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpParameterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 },
    { flatbuffers::ET_SEQUENCE, 0, 67 },
    { flatbuffers::ET_SEQUENCE, 0, 68 },
    { flatbuffers::ET_SEQUENCE, 0, 69 },
    { flatbuffers::ET_SEQUENCE, 0, 70 },
    { flatbuffers::ET_SEQUENCE, 0, 71 },
    { flatbuffers::ET_SEQUENCE, 0, 72 },
    { flatbuffers::ET_SEQUENCE, 0, 73 },
    { flatbuffers::ET_SEQUENCE, 0, 74 },
    { flatbuffers::ET_SEQUENCE, 0, 75 },
    { flatbuffers::ET_SEQUENCE, 0, 76 },
    { flatbuffers::ET_SEQUENCE, 0, 77 },
    { flatbuffers::ET_SEQUENCE, 0, 78 },
    { flatbuffers::ET_SEQUENCE, 0, 79 },
    { flatbuffers::ET_SEQUENCE, 0, 80 },
    { flatbuffers::ET_SEQUENCE, 0, 81 },
    { flatbuffers::ET_SEQUENCE, 0, 82 },
    { flatbuffers::ET_SEQUENCE, 0, 83 },
    { flatbuffers::ET_SEQUENCE, 0, 84 },
    { flatbuffers::ET_SEQUENCE, 0, 85 },
    { flatbuffers::ET_SEQUENCE, 0, 86 },
    { flatbuffers::ET_SEQUENCE, 0, 87 },
    { flatbuffers::ET_SEQUENCE, 0, 88 },
    { flatbuffers::ET_SEQUENCE, 0, 89 },
    { flatbuffers::ET_SEQUENCE, 0, 90 },
    { flatbuffers::ET_SEQUENCE, 0, 91 },
    { flatbuffers::ET_SEQUENCE, 0, 92 },
    { flatbuffers::ET_SEQUENCE, 0, 93 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::QuantizedAddTypeTable,
    ace::ArgMaxTypeTable,
    ace::AsStringTypeTable,
    ace::AxisTypeTable,
    ace::BatchNormTypeTable,
    ace::BinaryOpTypeTable,
    ace::BlobTypeTable,
    ace::CastParamTypeTable,
    ace::Convolution2DTypeTable,
    ace::CropTypeTable,
    ace::CropAndResizeTypeTable,
    ace::DequantizeTypeTable,
    ace::DetectionOutputTypeTable,
    ace::EltwiseTypeTable,
    ace::ExpandDimsTypeTable,
    ace::FillTypeTable,
    ace::FlattenTypeTable,
    ace::GatherTypeTable,
    ace::GatherV2TypeTable,
    ace::InnerProductTypeTable,
    ace::InputTypeTable,
    ace::InterpTypeTable,
    ace::LRNTypeTable,
    ace::LSTMTypeTable,
    ace::MatMulTypeTable,
    ace::NonMaxSuppressionV2TypeTable,
    ace::NormalizeTypeTable,
    ace::PackParamTypeTable,
    ace::PermuteTypeTable,
    ace::PluginTypeTable,
    ace::PoolTypeTable,
    ace::PReluTypeTable,
    ace::PriorBoxTypeTable,
    ace::ProposalTypeTable,
    ace::QuantizedAvgPoolTypeTable,
    ace::QuantizedBiasAddTypeTable,
    ace::QuantizedConcatTypeTable,
    ace::QuantizedLogisticTypeTable,
    ace::QuantizedMatMulTypeTable,
    ace::QuantizedMaxPoolTypeTable,
    ace::QuantizedReluTypeTable,
    ace::QuantizedRelu6TypeTable,
    ace::QuantizedReshapeTypeTable,
    ace::QuantizedSoftmaxTypeTable,
    ace::QuantizeMaxMinTypeTable,
    ace::QuantizeV2TypeTable,
    ace::RangeTypeTable,
    ace::RankTypeTable,
    ace::ReduceJoinTypeTable,
    ace::ReductionParamTypeTable,
    ace::ReluTypeTable,
    ace::Relu6TypeTable,
    ace::RequantizationRangeTypeTable,
    ace::RequantizeTypeTable,
    ace::ReshapeTypeTable,
    ace::ResizeTypeTable,
    ace::RoiParametersTypeTable,
    ace::ScaleTypeTable,
    ace::SeluTypeTable,
    ace::SizeTypeTable,
    ace::SliceTypeTable,
    ace::SliceTfTypeTable,
    ace::SpaceBatchTypeTable,
    ace::SqueezeParamTypeTable,
    ace::StridedSliceParamTypeTable,
    ace::TensorConvertInfoTypeTable,
    ace::TfQuantizedConv2DTypeTable,
    ace::TopKV2TypeTable,
    ace::TransposeTypeTable,
    ace::UnaryOpTypeTable,
    ace::MomentsParamTypeTable,
    ace::RNNParamTypeTable,
    ace::BatchMatMulParamTypeTable,
    ace::QuantizedFloatParamTypeTable,
    ace::DepthSpaceParamTypeTable,
    ace::EltwiseInt8TypeTable,
    ace::ReverseSequenceParamTypeTable,
    ace::ExtraTypeTable,
    ace::Pool3DTypeTable,
    ace::Convolution3DTypeTable,
    ace::ELUTypeTable,
    ace::DetectionPostProcessParamTypeTable,
    ace::OneHotParamTypeTable,
    ace::PadParamTypeTable,
    ace::WhileParamTypeTable,
    ace::IfParamTypeTable,
    ace::RandomUniformTypeTable,
    ace::LayerNormTypeTable,
    ace::TensorArrayTypeTable,
    ace::LSTMBlockCellTypeTable,
    ace::GridSampleTypeTable,
    ace::LoopParamTypeTable,
    ace::ImageProcessParamTypeTable,
    ace::CumSumTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "Axis",
    "BatchNorm",
    "BinaryOp",
    "Blob",
    "CastParam",
    "Convolution2D",
    "Crop",
    "CropAndResize",
    "Dequantize",
    "DetectionOutput",
    "Eltwise",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Gather",
    "GatherV2",
    "InnerProduct",
    "Input",
    "Interp",
    "LRN",
    "LSTM",
    "MatMul",
    "NonMaxSuppressionV2",
    "Normalize",
    "PackParam",
    "Permute",
    "Plugin",
    "Pool",
    "PRelu",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "ReductionParam",
    "Relu",
    "Relu6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RoiParameters",
    "Scale",
    "Selu",
    "Size",
    "Slice",
    "SliceTf",
    "SpaceBatch",
    "SqueezeParam",
    "StridedSliceParam",
    "TensorConvertInfo",
    "TfQuantizedConv2D",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "MomentsParam",
    "RNNParam",
    "BatchMatMulParam",
    "QuantizedFloatParam",
    "DepthSpaceParam",
    "EltwiseInt8",
    "ReverseSequenceParam",
    "Extra",
    "Pool3D",
    "Convolution3D",
    "ELU",
    "DetectionPostProcessParam",
    "OneHotParam",
    "PadParam",
    "WhileParam",
    "IfParam",
    "RandomUniform",
    "LayerNorm",
    "TensorArray",
    "LSTMBlockCell",
    "GridSample",
    "LoopParam",
    "ImageProcessParam",
    "CumSum"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 95, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ForwardTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::ForwardTypeTypeTable
  };
  static const char * const names[] = {
    "CPU",
    "CUDA",
    "METAL",
    "OPENCL",
    "OPENGLES",
    "VULKAN"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UsageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::UsageTypeTable
  };
  static const char * const names[] = {
    "INFERENCE",
    "TRAIN",
    "INFERENCE_STATIC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PluginTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "attr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExtraTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "engine",
    "info",
    "attr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StringVecTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhileParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::StringVecTypeTable
  };
  static const char * const names[] = {
    "cond_graph",
    "body_graph",
    "aliases_inputs",
    "aliases_outputs",
    "aliases_updates"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IfParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::StringVecTypeTable
  };
  static const char * const names[] = {
    "then_graph",
    "else_graph",
    "aliases_inputs",
    "aliases_outputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RegionCommandTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::OpTypeTable,
    ace::ViewTypeTable
  };
  static const char * const names[] = {
    "op",
    "steps",
    "size",
    "indexes",
    "view",
    "fuse",
    "iterIndexes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LoopParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::TensorDescribeTypeTable,
    ace::RegionCommandTypeTable
  };
  static const char * const names[] = {
    "tensorNumber",
    "outputIndexes",
    "inputIndexes",
    "extraTensorInfos",
    "parallel",
    "loopNumber",
    "commands",
    "initCommand"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::OpParameterTypeTable,
    ace::OpTypeTypeTable,
    ace::DataFormatTypeTable
  };
  static const char * const names[] = {
    "inputIndexes",
    "main_type",
    "main",
    "name",
    "outputIndexes",
    "type",
    "defaultDimentionFormat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ViewTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "offset",
    "stride"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RegionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::ViewTypeTable
  };
  static const char * const names[] = {
    "src",
    "dst",
    "size",
    "origin"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorDescribeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::BlobTypeTable,
    ace::RegionTypeTable,
    ace::TensorQuantInfoTypeTable
  };
  static const char * const names[] = {
    "blob",
    "index",
    "name",
    "regions",
    "quantInfo"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGraphProtoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::OpTypeTable,
    ace::TensorDescribeTypeTable
  };
  static const char * const names[] = {
    "name",
    "inputs",
    "outputs",
    "tensors",
    "nodes",
    "extraTensorDescribe"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorQuantInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DataTypeTypeTable
  };
  static const char * const names[] = {
    "scale",
    "zero",
    "min",
    "max",
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NetTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 3 },
    { flatbuffers::ET_CHAR, 0, 4 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::TensorDescribeTypeTable,
    ace::ExtraInfoTypeTable,
    ace::OpTypeTable,
    ace::ForwardTypeTypeTable,
    ace::NetSourceTypeTable,
    ace::UsageTypeTable,
    ace::SubGraphProtoTypeTable
  };
  static const char * const names[] = {
    "bizCode",
    "extraTensorDescribe",
    "extraInfo",
    "oplists",
    "outputName",
    "preferForwardType",
    "sourceType",
    "tensorName",
    "tensorNumber",
    "usage",
    "subgraphs",
    "uuid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ace::Net *GetNet(const void *buf) {
  return flatbuffers::GetRoot<ace::Net>(buf);
}

inline const ace::Net *GetSizePrefixedNet(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ace::Net>(buf);
}

inline bool VerifyNetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ace::Net>(nullptr);
}

inline bool VerifySizePrefixedNetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ace::Net>(nullptr);
}

inline void FinishNetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ace::Net> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ace::Net> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ace::NetT> UnPackNet(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ace::NetT>(GetNet(buf)->UnPack(res));
}

inline std::unique_ptr<ace::NetT> UnPackSizePrefixedNet(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ace::NetT>(GetSizePrefixedNet(buf)->UnPack(res));
}

}  // namespace ace

#endif  // FLATBUFFERS_GENERATED_ACE_ACE_H_
