// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAFFEOP_ACE_H_
#define FLATBUFFERS_GENERATED_CAFFEOP_ACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "tensor_generated.h"

namespace ace {

struct Convolution2DCommon;
struct Convolution2DCommonBuilder;
struct Convolution2DCommonT;

struct Convolution3DCommon;
struct Convolution3DCommonBuilder;
struct Convolution3DCommonT;

struct SparseCommon;
struct SparseCommonBuilder;
struct SparseCommonT;

struct IDSTQuan;
struct IDSTQuanBuilder;
struct IDSTQuanT;

struct QuantizedFloatParam;
struct QuantizedFloatParamBuilder;
struct QuantizedFloatParamT;

struct Convolution2D;
struct Convolution2DBuilder;
struct Convolution2DT;

struct Convolution3D;
struct Convolution3DBuilder;
struct Convolution3DT;

struct InnerProduct;
struct InnerProductBuilder;
struct InnerProductT;

struct Pool;
struct PoolBuilder;
struct PoolT;

struct Pool3D;
struct Pool3DBuilder;
struct Pool3DT;

struct Relu;
struct ReluBuilder;
struct ReluT;

struct Relu6;
struct Relu6Builder;
struct Relu6T;

struct PRelu;
struct PReluBuilder;
struct PReluT;

struct ELU;
struct ELUBuilder;
struct ELUT;

struct LRN;
struct LRNBuilder;
struct LRNT;

struct ArgMax;
struct ArgMaxBuilder;
struct ArgMaxT;

struct Axis;
struct AxisBuilder;
struct AxisT;

struct Input;
struct InputBuilder;
struct InputT;

struct LSTM;
struct LSTMBuilder;
struct LSTMT;

struct Slice;
struct SliceBuilder;
struct SliceT;

struct BatchNorm;
struct BatchNormBuilder;
struct BatchNormT;

struct Scale;
struct ScaleBuilder;
struct ScaleT;

struct Eltwise;
struct EltwiseBuilder;
struct EltwiseT;

struct Flatten;
struct FlattenBuilder;
struct FlattenT;

struct Permute;
struct PermuteBuilder;
struct PermuteT;

struct Reshape;
struct ReshapeBuilder;
struct ReshapeT;

struct DetectionOutput;
struct DetectionOutputBuilder;
struct DetectionOutputT;

struct RoiParameters;
struct RoiParametersBuilder;
struct RoiParametersT;

struct Proposal;
struct ProposalBuilder;
struct ProposalT;

struct Interp;
struct InterpBuilder;
struct InterpT;

struct Resize;
struct ResizeBuilder;
struct ResizeT;

struct PriorBox;
struct PriorBoxBuilder;
struct PriorBoxT;

struct Normalize;
struct NormalizeBuilder;
struct NormalizeT;

struct EltwiseInt8;
struct EltwiseInt8Builder;
struct EltwiseInt8T;

struct CumSum;
struct CumSumBuilder;
struct CumSumT;

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable();

inline const flatbuffers::TypeTable *Convolution3DCommonTypeTable();

inline const flatbuffers::TypeTable *SparseCommonTypeTable();

inline const flatbuffers::TypeTable *IDSTQuanTypeTable();

inline const flatbuffers::TypeTable *QuantizedFloatParamTypeTable();

inline const flatbuffers::TypeTable *Convolution2DTypeTable();

inline const flatbuffers::TypeTable *Convolution3DTypeTable();

inline const flatbuffers::TypeTable *InnerProductTypeTable();

inline const flatbuffers::TypeTable *PoolTypeTable();

inline const flatbuffers::TypeTable *Pool3DTypeTable();

inline const flatbuffers::TypeTable *ReluTypeTable();

inline const flatbuffers::TypeTable *Relu6TypeTable();

inline const flatbuffers::TypeTable *PReluTypeTable();

inline const flatbuffers::TypeTable *ELUTypeTable();

inline const flatbuffers::TypeTable *LRNTypeTable();

inline const flatbuffers::TypeTable *ArgMaxTypeTable();

inline const flatbuffers::TypeTable *AxisTypeTable();

inline const flatbuffers::TypeTable *InputTypeTable();

inline const flatbuffers::TypeTable *LSTMTypeTable();

inline const flatbuffers::TypeTable *SliceTypeTable();

inline const flatbuffers::TypeTable *BatchNormTypeTable();

inline const flatbuffers::TypeTable *ScaleTypeTable();

inline const flatbuffers::TypeTable *EltwiseTypeTable();

inline const flatbuffers::TypeTable *FlattenTypeTable();

inline const flatbuffers::TypeTable *PermuteTypeTable();

inline const flatbuffers::TypeTable *ReshapeTypeTable();

inline const flatbuffers::TypeTable *DetectionOutputTypeTable();

inline const flatbuffers::TypeTable *RoiParametersTypeTable();

inline const flatbuffers::TypeTable *ProposalTypeTable();

inline const flatbuffers::TypeTable *InterpTypeTable();

inline const flatbuffers::TypeTable *ResizeTypeTable();

inline const flatbuffers::TypeTable *PriorBoxTypeTable();

inline const flatbuffers::TypeTable *NormalizeTypeTable();

inline const flatbuffers::TypeTable *EltwiseInt8TypeTable();

inline const flatbuffers::TypeTable *CumSumTypeTable();

enum PadMode : int8_t {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_CAFFE, PadMode_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum SparseAlgo : int8_t {
  SparseAlgo_RANDOM = 0,
  SparseAlgo_SIMD_OC = 1,
  SparseAlgo_MIN = SparseAlgo_RANDOM,
  SparseAlgo_MAX = SparseAlgo_SIMD_OC
};

inline const SparseAlgo (&EnumValuesSparseAlgo())[2] {
  static const SparseAlgo values[] = {
    SparseAlgo_RANDOM,
    SparseAlgo_SIMD_OC
  };
  return values;
}

inline const char * const *EnumNamesSparseAlgo() {
  static const char * const names[3] = {
    "RANDOM",
    "SIMD_OC",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseAlgo(SparseAlgo e) {
  if (flatbuffers::IsOutRange(e, SparseAlgo_RANDOM, SparseAlgo_SIMD_OC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseAlgo()[index];
}

enum QuantizeAlgo : int8_t {
  QuantizeAlgo_DEFAULT = 0,
  QuantizeAlgo_OVERFLOW_AWARE = 1,
  QuantizeAlgo_WINOGRAD_AWARE = 2,
  QuantizeAlgo_MIN = QuantizeAlgo_DEFAULT,
  QuantizeAlgo_MAX = QuantizeAlgo_WINOGRAD_AWARE
};

inline const QuantizeAlgo (&EnumValuesQuantizeAlgo())[3] {
  static const QuantizeAlgo values[] = {
    QuantizeAlgo_DEFAULT,
    QuantizeAlgo_OVERFLOW_AWARE,
    QuantizeAlgo_WINOGRAD_AWARE
  };
  return values;
}

inline const char * const *EnumNamesQuantizeAlgo() {
  static const char * const names[4] = {
    "DEFAULT",
    "OVERFLOW_AWARE",
    "WINOGRAD_AWARE",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizeAlgo(QuantizeAlgo e) {
  if (flatbuffers::IsOutRange(e, QuantizeAlgo_DEFAULT, QuantizeAlgo_WINOGRAD_AWARE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizeAlgo()[index];
}

enum PoolType : int8_t {
  PoolType_MAXPOOL = 0,
  PoolType_AVEPOOL = 1,
  PoolType_MIN = PoolType_MAXPOOL,
  PoolType_MAX = PoolType_AVEPOOL
};

inline const PoolType (&EnumValuesPoolType())[2] {
  static const PoolType values[] = {
    PoolType_MAXPOOL,
    PoolType_AVEPOOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[3] = {
    "MAXPOOL",
    "AVEPOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (flatbuffers::IsOutRange(e, PoolType_MAXPOOL, PoolType_AVEPOOL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolType()[index];
}

enum PoolPadType : int8_t {
  PoolPadType_CAFFE = 0,
  PoolPadType_VALID = 1,
  PoolPadType_SAME = 2,
  PoolPadType_MIN = PoolPadType_CAFFE,
  PoolPadType_MAX = PoolPadType_SAME
};

inline const PoolPadType (&EnumValuesPoolPadType())[3] {
  static const PoolPadType values[] = {
    PoolPadType_CAFFE,
    PoolPadType_VALID,
    PoolPadType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPoolPadType() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolPadType(PoolPadType e) {
  if (flatbuffers::IsOutRange(e, PoolPadType_CAFFE, PoolPadType_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolPadType()[index];
}

enum AvgPoolCountType : int8_t {
  AvgPoolCountType_DEFAULT = 0,
  AvgPoolCountType_INCLUDE_PADDING = 1,
  AvgPoolCountType_EXCLUDE_PADDING = 2,
  AvgPoolCountType_MIN = AvgPoolCountType_DEFAULT,
  AvgPoolCountType_MAX = AvgPoolCountType_EXCLUDE_PADDING
};

inline const AvgPoolCountType (&EnumValuesAvgPoolCountType())[3] {
  static const AvgPoolCountType values[] = {
    AvgPoolCountType_DEFAULT,
    AvgPoolCountType_INCLUDE_PADDING,
    AvgPoolCountType_EXCLUDE_PADDING
  };
  return values;
}

inline const char * const *EnumNamesAvgPoolCountType() {
  static const char * const names[4] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameAvgPoolCountType(AvgPoolCountType e) {
  if (flatbuffers::IsOutRange(e, AvgPoolCountType_DEFAULT, AvgPoolCountType_EXCLUDE_PADDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAvgPoolCountType()[index];
}

enum EltwiseType : int8_t {
  EltwiseType_PROD = 0,
  EltwiseType_SUM = 1,
  EltwiseType_MAXIMUM = 2,
  EltwiseType_SUB = 3,
  EltwiseType_MIN = EltwiseType_PROD,
  EltwiseType_MAX = EltwiseType_SUB
};

inline const EltwiseType (&EnumValuesEltwiseType())[4] {
  static const EltwiseType values[] = {
    EltwiseType_PROD,
    EltwiseType_SUM,
    EltwiseType_MAXIMUM,
    EltwiseType_SUB
  };
  return values;
}

inline const char * const *EnumNamesEltwiseType() {
  static const char * const names[5] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseType(EltwiseType e) {
  if (flatbuffers::IsOutRange(e, EltwiseType_PROD, EltwiseType_SUB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseType()[index];
}

enum CoordinateTransformationMode : int8_t {
  CoordinateTransformationMode_NotSet = 0,
  CoordinateTransformationMode_AlignCorners = 1,
  CoordinateTransformationMode_HalfPixels = 2,
  CoordinateTransformationMode_PytorchHalfPixels = 3,
  CoordinateTransformationMode_Asymmetric = 4,
  CoordinateTransformationMode_TensorflowHalfPixels = 5,
  CoordinateTransformationMode_TensorflowCropAndResize = 6,
  CoordinateTransformationMode_MIN = CoordinateTransformationMode_NotSet,
  CoordinateTransformationMode_MAX = CoordinateTransformationMode_TensorflowCropAndResize
};

inline const CoordinateTransformationMode (&EnumValuesCoordinateTransformationMode())[7] {
  static const CoordinateTransformationMode values[] = {
    CoordinateTransformationMode_NotSet,
    CoordinateTransformationMode_AlignCorners,
    CoordinateTransformationMode_HalfPixels,
    CoordinateTransformationMode_PytorchHalfPixels,
    CoordinateTransformationMode_Asymmetric,
    CoordinateTransformationMode_TensorflowHalfPixels,
    CoordinateTransformationMode_TensorflowCropAndResize
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformationMode() {
  static const char * const names[8] = {
    "NotSet",
    "AlignCorners",
    "HalfPixels",
    "PytorchHalfPixels",
    "Asymmetric",
    "TensorflowHalfPixels",
    "TensorflowCropAndResize",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformationMode(CoordinateTransformationMode e) {
  if (flatbuffers::IsOutRange(e, CoordinateTransformationMode_NotSet, CoordinateTransformationMode_TensorflowCropAndResize)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateTransformationMode()[index];
}

struct Convolution2DCommonT : public flatbuffers::NativeTable {
  typedef Convolution2DCommon TableType;
  int32_t padX = 0;
  int32_t padY = 0;
  int32_t kernelX = 1;
  int32_t kernelY = 1;
  int32_t strideX = 1;
  int32_t strideY = 1;
  int32_t dilateX = 1;
  int32_t dilateY = 1;
  ace::PadMode padMode = ace::PadMode_CAFFE;
  int32_t group = 1;
  int32_t outputCount = 0;
  int32_t inputCount = 0;
  bool relu = false;
  bool relu6 = false;
  std::vector<int32_t> pads{};
  std::vector<int32_t> outPads{};
  bool hasOutputShape = false;
};

struct Convolution2DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DCommonT NativeTableType;
  typedef Convolution2DCommonBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_KERNELX = 8,
    VT_KERNELY = 10,
    VT_STRIDEX = 12,
    VT_STRIDEY = 14,
    VT_DILATEX = 16,
    VT_DILATEY = 18,
    VT_PADMODE = 20,
    VT_GROUP = 22,
    VT_OUTPUTCOUNT = 24,
    VT_INPUTCOUNT = 26,
    VT_RELU = 28,
    VT_RELU6 = 30,
    VT_PADS = 32,
    VT_OUTPADS = 34,
    VT_HASOUTPUTSHAPE = 36
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(VT_DILATEX, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(VT_DILATEY, 1);
  }
  ace::PadMode padMode() const {
    return static_cast<ace::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPADS);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(VT_HASOUTPUTSHAPE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX, 4) &&
           VerifyField<int32_t>(verifier, VT_PADY, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELX, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELY, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATEX, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATEY, 4) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_OUTPADS) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, VT_HASOUTPUTSHAPE, 1) &&
           verifier.EndTable();
  }
  Convolution2DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DCommonBuilder {
  typedef Convolution2DCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADY, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELX, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELY, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEX, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEY, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEX, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEY, dilateY, 1);
  }
  void add_padMode(ace::PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution2DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_GROUP, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Convolution2DCommon::VT_PADS, pads);
  }
  void add_outPads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(Convolution2DCommon::VT_OUTPADS, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_HASOUTPUTSHAPE, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Convolution2DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Convolution2DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Convolution2DCommonBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_pads(pads);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *outPads = nullptr,
    bool hasOutputShape = false) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto outPads__ = outPads ? _fbb.CreateVector<int32_t>(*outPads) : 0;
  return ace::CreateConvolution2DCommon(
      _fbb,
      padX,
      padY,
      kernelX,
      kernelY,
      strideX,
      strideY,
      dilateX,
      dilateY,
      padMode,
      group,
      outputCount,
      inputCount,
      relu,
      relu6,
      pads__,
      outPads__,
      hasOutputShape);
}

flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution3DCommonT : public flatbuffers::NativeTable {
  typedef Convolution3DCommon TableType;
  std::vector<int32_t> dilates{};
  std::vector<int32_t> strides{};
  std::vector<int32_t> kernels{};
  std::vector<int32_t> pads{};
  ace::PadMode padMode = ace::PadMode_CAFFE;
  int32_t inputCount = 0;
  int32_t outputCount = 0;
  bool relu = false;
  bool relu6 = false;
  int32_t group = 1;
  std::vector<int32_t> outPads{};
  bool hasOutputShape = false;
};

struct Convolution3DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution3DCommonT NativeTableType;
  typedef Convolution3DCommonBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution3DCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DILATES = 4,
    VT_STRIDES = 6,
    VT_KERNELS = 8,
    VT_PADS = 10,
    VT_PADMODE = 12,
    VT_INPUTCOUNT = 14,
    VT_OUTPUTCOUNT = 16,
    VT_RELU = 18,
    VT_RELU6 = 20,
    VT_GROUP = 22,
    VT_OUTPADS = 24,
    VT_HASOUTPUTSHAPE = 26
  };
  const flatbuffers::Vector<int32_t> *dilates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATES);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  ace::PadMode padMode() const {
    return static_cast<ace::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  const flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPADS);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(VT_HASOUTPUTSHAPE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DILATES) &&
           verifier.VerifyVector(dilates()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyOffset(verifier, VT_OUTPADS) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, VT_HASOUTPUTSHAPE, 1) &&
           verifier.EndTable();
  }
  Convolution3DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution3DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution3DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution3DCommonBuilder {
  typedef Convolution3DCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dilates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates) {
    fbb_.AddOffset(Convolution3DCommon::VT_DILATES, dilates);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Convolution3DCommon::VT_STRIDES, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Convolution3DCommon::VT_KERNELS, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Convolution3DCommon::VT_PADS, pads);
  }
  void add_padMode(ace::PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution3DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_GROUP, group, 1);
  }
  void add_outPads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(Convolution3DCommon::VT_OUTPADS, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_HASOUTPUTSHAPE, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Convolution3DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Convolution3DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution3DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false,
    int32_t group = 1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Convolution3DCommonBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_group(group);
  builder_.add_outputCount(outputCount);
  builder_.add_inputCount(inputCount);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_dilates(dilates);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dilates = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false,
    int32_t group = 1,
    const std::vector<int32_t> *outPads = nullptr,
    bool hasOutputShape = false) {
  auto dilates__ = dilates ? _fbb.CreateVector<int32_t>(*dilates) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto outPads__ = outPads ? _fbb.CreateVector<int32_t>(*outPads) : 0;
  return ace::CreateConvolution3DCommon(
      _fbb,
      dilates__,
      strides__,
      kernels__,
      pads__,
      padMode,
      inputCount,
      outputCount,
      relu,
      relu6,
      group,
      outPads__,
      hasOutputShape);
}

flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseCommonT : public flatbuffers::NativeTable {
  typedef SparseCommon TableType;
  ace::SparseAlgo method = ace::SparseAlgo_RANDOM;
  std::vector<std::unique_ptr<ace::AttributeT>> args{};
  SparseCommonT() = default;
  SparseCommonT(const SparseCommonT &o);
  SparseCommonT(SparseCommonT&&) FLATBUFFERS_NOEXCEPT = default;
  SparseCommonT &operator=(SparseCommonT o) FLATBUFFERS_NOEXCEPT;
};

struct SparseCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseCommonT NativeTableType;
  typedef SparseCommonBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_ARGS = 6
  };
  ace::SparseAlgo method() const {
    return static_cast<ace::SparseAlgo>(GetField<int8_t>(VT_METHOD, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_METHOD, 1) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
  SparseCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseCommonBuilder {
  typedef SparseCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(ace::SparseAlgo method) {
    fbb_.AddElement<int8_t>(SparseCommon::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> args) {
    fbb_.AddOffset(SparseCommon::VT_ARGS, args);
  }
  explicit SparseCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseCommon> CreateSparseCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::SparseAlgo method = ace::SparseAlgo_RANDOM,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> args = 0) {
  SparseCommonBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_method(method);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparseCommon> CreateSparseCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::SparseAlgo method = ace::SparseAlgo_RANDOM,
    std::vector<flatbuffers::Offset<ace::Attribute>> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVectorOfSortedTables<ace::Attribute>(args) : 0;
  return ace::CreateSparseCommon(
      _fbb,
      method,
      args__);
}

flatbuffers::Offset<SparseCommon> CreateSparseCommon(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IDSTQuanT : public flatbuffers::NativeTable {
  typedef IDSTQuan TableType;
  std::vector<int8_t> buffer{};
  std::vector<float> alpha{};
  int32_t type = 0;
  bool useInt32 = false;
  float quantScale = 0.0f;
  float scaleIn = 0.0f;
  float scaleOut = 0.0f;
  int32_t aMax = 0;
  int32_t aMin = 0;
  int32_t readType = 0;
  bool has_scaleInt = false;
};

struct IDSTQuan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IDSTQuanT NativeTableType;
  typedef IDSTQuanBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IDSTQuanTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_ALPHA = 6,
    VT_TYPE = 8,
    VT_USEINT32 = 10,
    VT_QUANTSCALE = 12,
    VT_SCALEIN = 14,
    VT_SCALEOUT = 16,
    VT_AMAX = 18,
    VT_AMIN = 20,
    VT_READTYPE = 22,
    VT_HAS_SCALEINT = 24
  };
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  const flatbuffers::Vector<float> *alpha() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ALPHA);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool useInt32() const {
    return GetField<uint8_t>(VT_USEINT32, 0) != 0;
  }
  float quantScale() const {
    return GetField<float>(VT_QUANTSCALE, 0.0f);
  }
  float scaleIn() const {
    return GetField<float>(VT_SCALEIN, 0.0f);
  }
  float scaleOut() const {
    return GetField<float>(VT_SCALEOUT, 0.0f);
  }
  int32_t aMax() const {
    return GetField<int32_t>(VT_AMAX, 0);
  }
  int32_t aMin() const {
    return GetField<int32_t>(VT_AMIN, 0);
  }
  int32_t readType() const {
    return GetField<int32_t>(VT_READTYPE, 0);
  }
  bool has_scaleInt() const {
    return GetField<uint8_t>(VT_HAS_SCALEINT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyVector(alpha()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_USEINT32, 1) &&
           VerifyField<float>(verifier, VT_QUANTSCALE, 4) &&
           VerifyField<float>(verifier, VT_SCALEIN, 4) &&
           VerifyField<float>(verifier, VT_SCALEOUT, 4) &&
           VerifyField<int32_t>(verifier, VT_AMAX, 4) &&
           VerifyField<int32_t>(verifier, VT_AMIN, 4) &&
           VerifyField<int32_t>(verifier, VT_READTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SCALEINT, 1) &&
           verifier.EndTable();
  }
  IDSTQuanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IDSTQuanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IDSTQuan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IDSTQuanBuilder {
  typedef IDSTQuan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(IDSTQuan::VT_BUFFER, buffer);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::Vector<float>> alpha) {
    fbb_.AddOffset(IDSTQuan::VT_ALPHA, alpha);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_TYPE, type, 0);
  }
  void add_useInt32(bool useInt32) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_USEINT32, static_cast<uint8_t>(useInt32), 0);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(IDSTQuan::VT_QUANTSCALE, quantScale, 0.0f);
  }
  void add_scaleIn(float scaleIn) {
    fbb_.AddElement<float>(IDSTQuan::VT_SCALEIN, scaleIn, 0.0f);
  }
  void add_scaleOut(float scaleOut) {
    fbb_.AddElement<float>(IDSTQuan::VT_SCALEOUT, scaleOut, 0.0f);
  }
  void add_aMax(int32_t aMax) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_AMAX, aMax, 0);
  }
  void add_aMin(int32_t aMin) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_AMIN, aMin, 0);
  }
  void add_readType(int32_t readType) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_READTYPE, readType, 0);
  }
  void add_has_scaleInt(bool has_scaleInt) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_HAS_SCALEINT, static_cast<uint8_t>(has_scaleInt), 0);
  }
  explicit IDSTQuanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IDSTQuan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IDSTQuan>(end);
    return o;
  }
};

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> alpha = 0,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false) {
  IDSTQuanBuilder builder_(_fbb);
  builder_.add_readType(readType);
  builder_.add_aMin(aMin);
  builder_.add_aMax(aMax);
  builder_.add_scaleOut(scaleOut);
  builder_.add_scaleIn(scaleIn);
  builder_.add_quantScale(quantScale);
  builder_.add_type(type);
  builder_.add_alpha(alpha);
  builder_.add_buffer(buffer);
  builder_.add_has_scaleInt(has_scaleInt);
  builder_.add_useInt32(useInt32);
  return builder_.Finish();
}

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr,
    const std::vector<float> *alpha = nullptr,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  auto alpha__ = alpha ? _fbb.CreateVector<float>(*alpha) : 0;
  return ace::CreateIDSTQuan(
      _fbb,
      buffer__,
      alpha__,
      type,
      useInt32,
      quantScale,
      scaleIn,
      scaleOut,
      aMax,
      aMin,
      readType,
      has_scaleInt);
}

flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizedFloatParamT : public flatbuffers::NativeTable {
  typedef QuantizedFloatParam TableType;
  std::vector<int8_t> weight{};
  std::vector<int32_t> bias{};
  std::vector<float> scale{};
  std::vector<float> tensorScale{};
  ace::QuantizeAlgo method = ace::QuantizeAlgo_DEFAULT;
  int32_t nbits = 8;
  int8_t zeroPoint = 0;
  int8_t outputZeroPoint = 0;
  int8_t clampMin = -128;
  int8_t clampMax = 127;
  std::vector<int32_t> winogradAttr{};
};

struct QuantizedFloatParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizedFloatParamT NativeTableType;
  typedef QuantizedFloatParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizedFloatParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHT = 4,
    VT_BIAS = 6,
    VT_SCALE = 8,
    VT_TENSORSCALE = 10,
    VT_METHOD = 12,
    VT_NBITS = 14,
    VT_ZEROPOINT = 16,
    VT_OUTPUTZEROPOINT = 18,
    VT_CLAMPMIN = 20,
    VT_CLAMPMAX = 22,
    VT_WINOGRADATTR = 24
  };
  const flatbuffers::Vector<int8_t> *weight() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<int32_t> *bias() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BIAS);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<float> *tensorScale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TENSORSCALE);
  }
  ace::QuantizeAlgo method() const {
    return static_cast<ace::QuantizeAlgo>(GetField<int8_t>(VT_METHOD, 0));
  }
  int32_t nbits() const {
    return GetField<int32_t>(VT_NBITS, 8);
  }
  int8_t zeroPoint() const {
    return GetField<int8_t>(VT_ZEROPOINT, 0);
  }
  int8_t outputZeroPoint() const {
    return GetField<int8_t>(VT_OUTPUTZEROPOINT, 0);
  }
  int8_t clampMin() const {
    return GetField<int8_t>(VT_CLAMPMIN, -128);
  }
  int8_t clampMax() const {
    return GetField<int8_t>(VT_CLAMPMAX, 127);
  }
  const flatbuffers::Vector<int32_t> *winogradAttr() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_WINOGRADATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_TENSORSCALE) &&
           verifier.VerifyVector(tensorScale()) &&
           VerifyField<int8_t>(verifier, VT_METHOD, 1) &&
           VerifyField<int32_t>(verifier, VT_NBITS, 4) &&
           VerifyField<int8_t>(verifier, VT_ZEROPOINT, 1) &&
           VerifyField<int8_t>(verifier, VT_OUTPUTZEROPOINT, 1) &&
           VerifyField<int8_t>(verifier, VT_CLAMPMIN, 1) &&
           VerifyField<int8_t>(verifier, VT_CLAMPMAX, 1) &&
           VerifyOffset(verifier, VT_WINOGRADATTR) &&
           verifier.VerifyVector(winogradAttr()) &&
           verifier.EndTable();
  }
  QuantizedFloatParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizedFloatParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizedFloatParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizedFloatParamBuilder {
  typedef QuantizedFloatParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<int8_t>> weight) {
    fbb_.AddOffset(QuantizedFloatParam::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<int32_t>> bias) {
    fbb_.AddOffset(QuantizedFloatParam::VT_BIAS, bias);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizedFloatParam::VT_SCALE, scale);
  }
  void add_tensorScale(flatbuffers::Offset<flatbuffers::Vector<float>> tensorScale) {
    fbb_.AddOffset(QuantizedFloatParam::VT_TENSORSCALE, tensorScale);
  }
  void add_method(ace::QuantizeAlgo method) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_nbits(int32_t nbits) {
    fbb_.AddElement<int32_t>(QuantizedFloatParam::VT_NBITS, nbits, 8);
  }
  void add_zeroPoint(int8_t zeroPoint) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_ZEROPOINT, zeroPoint, 0);
  }
  void add_outputZeroPoint(int8_t outputZeroPoint) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_OUTPUTZEROPOINT, outputZeroPoint, 0);
  }
  void add_clampMin(int8_t clampMin) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_CLAMPMIN, clampMin, -128);
  }
  void add_clampMax(int8_t clampMax) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_CLAMPMAX, clampMax, 127);
  }
  void add_winogradAttr(flatbuffers::Offset<flatbuffers::Vector<int32_t>> winogradAttr) {
    fbb_.AddOffset(QuantizedFloatParam::VT_WINOGRADATTR, winogradAttr);
  }
  explicit QuantizedFloatParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantizedFloatParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizedFloatParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> tensorScale = 0,
    ace::QuantizeAlgo method = ace::QuantizeAlgo_DEFAULT,
    int32_t nbits = 8,
    int8_t zeroPoint = 0,
    int8_t outputZeroPoint = 0,
    int8_t clampMin = -128,
    int8_t clampMax = 127,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> winogradAttr = 0) {
  QuantizedFloatParamBuilder builder_(_fbb);
  builder_.add_winogradAttr(winogradAttr);
  builder_.add_nbits(nbits);
  builder_.add_tensorScale(tensorScale);
  builder_.add_scale(scale);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_clampMax(clampMax);
  builder_.add_clampMin(clampMin);
  builder_.add_outputZeroPoint(outputZeroPoint);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_method(method);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *weight = nullptr,
    const std::vector<int32_t> *bias = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<float> *tensorScale = nullptr,
    ace::QuantizeAlgo method = ace::QuantizeAlgo_DEFAULT,
    int32_t nbits = 8,
    int8_t zeroPoint = 0,
    int8_t outputZeroPoint = 0,
    int8_t clampMin = -128,
    int8_t clampMax = 127,
    const std::vector<int32_t> *winogradAttr = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<int8_t>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<int32_t>(*bias) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto tensorScale__ = tensorScale ? _fbb.CreateVector<float>(*tensorScale) : 0;
  auto winogradAttr__ = winogradAttr ? _fbb.CreateVector<int32_t>(*winogradAttr) : 0;
  return ace::CreateQuantizedFloatParam(
      _fbb,
      weight__,
      bias__,
      scale__,
      tensorScale__,
      method,
      nbits,
      zeroPoint,
      outputZeroPoint,
      clampMin,
      clampMax,
      winogradAttr__);
}

flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution2DT : public flatbuffers::NativeTable {
  typedef Convolution2D TableType;
  std::unique_ptr<ace::Convolution2DCommonT> common{};
  std::vector<float> weight{};
  std::vector<float> bias{};
  std::unique_ptr<ace::IDSTQuanT> quanParameter{};
  std::unique_ptr<ace::QuantizedFloatParamT> symmetricQuan{};
  std::unique_ptr<ace::SparseCommonT> sparseParameter{};
  std::vector<int64_t> external{};
  Convolution2DT() = default;
  Convolution2DT(const Convolution2DT &o);
  Convolution2DT(Convolution2DT&&) FLATBUFFERS_NOEXCEPT = default;
  Convolution2DT &operator=(Convolution2DT o) FLATBUFFERS_NOEXCEPT;
};

struct Convolution2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DT NativeTableType;
  typedef Convolution2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_QUANPARAMETER = 10,
    VT_SYMMETRICQUAN = 12,
    VT_SPARSEPARAMETER = 14,
    VT_EXTERNAL = 16
  };
  const ace::Convolution2DCommon *common() const {
    return GetPointer<const ace::Convolution2DCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const ace::IDSTQuan *quanParameter() const {
    return GetPointer<const ace::IDSTQuan *>(VT_QUANPARAMETER);
  }
  const ace::QuantizedFloatParam *symmetricQuan() const {
    return GetPointer<const ace::QuantizedFloatParam *>(VT_SYMMETRICQUAN);
  }
  const ace::SparseCommon *sparseParameter() const {
    return GetPointer<const ace::SparseCommon *>(VT_SPARSEPARAMETER);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_QUANPARAMETER) &&
           verifier.VerifyTable(quanParameter()) &&
           VerifyOffset(verifier, VT_SYMMETRICQUAN) &&
           verifier.VerifyTable(symmetricQuan()) &&
           VerifyOffset(verifier, VT_SPARSEPARAMETER) &&
           verifier.VerifyTable(sparseParameter()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  Convolution2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DBuilder {
  typedef Convolution2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<ace::Convolution2DCommon> common) {
    fbb_.AddOffset(Convolution2D::VT_COMMON, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution2D::VT_BIAS, bias);
  }
  void add_quanParameter(flatbuffers::Offset<ace::IDSTQuan> quanParameter) {
    fbb_.AddOffset(Convolution2D::VT_QUANPARAMETER, quanParameter);
  }
  void add_symmetricQuan(flatbuffers::Offset<ace::QuantizedFloatParam> symmetricQuan) {
    fbb_.AddOffset(Convolution2D::VT_SYMMETRICQUAN, symmetricQuan);
  }
  void add_sparseParameter(flatbuffers::Offset<ace::SparseCommon> sparseParameter) {
    fbb_.AddOffset(Convolution2D::VT_SPARSEPARAMETER, sparseParameter);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Convolution2D::VT_EXTERNAL, external);
  }
  explicit Convolution2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Convolution2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Convolution2DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<ace::IDSTQuan> quanParameter = 0,
    flatbuffers::Offset<ace::QuantizedFloatParam> symmetricQuan = 0,
    flatbuffers::Offset<ace::SparseCommon> sparseParameter = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  Convolution2DBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_sparseParameter(sparseParameter);
  builder_.add_symmetricQuan(symmetricQuan);
  builder_.add_quanParameter(quanParameter);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Convolution2DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    flatbuffers::Offset<ace::IDSTQuan> quanParameter = 0,
    flatbuffers::Offset<ace::QuantizedFloatParam> symmetricQuan = 0,
    flatbuffers::Offset<ace::SparseCommon> sparseParameter = 0,
    const std::vector<int64_t> *external = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return ace::CreateConvolution2D(
      _fbb,
      common,
      weight__,
      bias__,
      quanParameter,
      symmetricQuan,
      sparseParameter,
      external__);
}

flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution3DT : public flatbuffers::NativeTable {
  typedef Convolution3D TableType;
  std::unique_ptr<ace::Convolution3DCommonT> common{};
  std::vector<float> weight{};
  std::vector<float> bias{};
  std::vector<int64_t> external{};
  Convolution3DT() = default;
  Convolution3DT(const Convolution3DT &o);
  Convolution3DT(Convolution3DT&&) FLATBUFFERS_NOEXCEPT = default;
  Convolution3DT &operator=(Convolution3DT o) FLATBUFFERS_NOEXCEPT;
};

struct Convolution3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution3DT NativeTableType;
  typedef Convolution3DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution3DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_EXTERNAL = 10
  };
  const ace::Convolution3DCommon *common() const {
    return GetPointer<const ace::Convolution3DCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  Convolution3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution3DBuilder {
  typedef Convolution3D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<ace::Convolution3DCommon> common) {
    fbb_.AddOffset(Convolution3D::VT_COMMON, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution3D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution3D::VT_BIAS, bias);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Convolution3D::VT_EXTERNAL, external);
  }
  explicit Convolution3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Convolution3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution3D> CreateConvolution3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Convolution3DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  Convolution3DBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution3D> CreateConvolution3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::Convolution3DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    const std::vector<int64_t> *external = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return ace::CreateConvolution3D(
      _fbb,
      common,
      weight__,
      bias__,
      external__);
}

flatbuffers::Offset<Convolution3D> CreateConvolution3D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InnerProductT : public flatbuffers::NativeTable {
  typedef InnerProduct TableType;
  int32_t outputCount = 0;
  int32_t biasTerm = 0;
  int32_t weightSize = 0;
  std::vector<float> weight{};
  std::vector<float> bias{};
  int32_t axis = 0;
  bool transpose = false;
  std::unique_ptr<ace::IDSTQuanT> quanParameter{};
  InnerProductT() = default;
  InnerProductT(const InnerProductT &o);
  InnerProductT(InnerProductT&&) FLATBUFFERS_NOEXCEPT = default;
  InnerProductT &operator=(InnerProductT o) FLATBUFFERS_NOEXCEPT;
};

struct InnerProduct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InnerProductT NativeTableType;
  typedef InnerProductBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InnerProductTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_BIASTERM = 6,
    VT_WEIGHTSIZE = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12,
    VT_AXIS = 14,
    VT_TRANSPOSE = 16,
    VT_QUANPARAMETER = 18
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(VT_BIASTERM, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(VT_TRANSPOSE, 0) != 0;
  }
  const ace::IDSTQuan *quanParameter() const {
    return GetPointer<const ace::IDSTQuan *>(VT_QUANPARAMETER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_BIASTERM, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE, 4) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE, 1) &&
           VerifyOffset(verifier, VT_QUANPARAMETER) &&
           verifier.VerifyTable(quanParameter()) &&
           verifier.EndTable();
  }
  InnerProductT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InnerProduct> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InnerProductBuilder {
  typedef InnerProduct Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_BIASTERM, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(InnerProduct::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(InnerProduct::VT_BIAS, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_AXIS, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(InnerProduct::VT_TRANSPOSE, static_cast<uint8_t>(transpose), 0);
  }
  void add_quanParameter(flatbuffers::Offset<ace::IDSTQuan> quanParameter) {
    fbb_.AddOffset(InnerProduct::VT_QUANPARAMETER, quanParameter);
  }
  explicit InnerProductBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InnerProduct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InnerProduct>(end);
    return o;
  }
};

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false,
    flatbuffers::Offset<ace::IDSTQuan> quanParameter = 0) {
  InnerProductBuilder builder_(_fbb);
  builder_.add_quanParameter(quanParameter);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProductDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    int32_t axis = 0,
    bool transpose = false,
    flatbuffers::Offset<ace::IDSTQuan> quanParameter = 0) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return ace::CreateInnerProduct(
      _fbb,
      outputCount,
      biasTerm,
      weightSize,
      weight__,
      bias__,
      axis,
      transpose,
      quanParameter);
}

flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolT : public flatbuffers::NativeTable {
  typedef Pool TableType;
  int32_t padX = 0;
  int32_t padY = 0;
  bool isGlobal = false;
  int32_t kernelX = 0;
  int32_t kernelY = 0;
  int32_t strideX = 0;
  int32_t strideY = 0;
  ace::PoolType type = ace::PoolType_MAXPOOL;
  ace::PoolPadType padType = ace::PoolPadType_CAFFE;
  ace::DataType dataType = ace::DataType_DT_FLOAT;
  bool ceilModel = true;
  std::vector<int32_t> pads{};
  ace::AvgPoolCountType countType = ace::AvgPoolCountType_DEFAULT;
};

struct Pool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolT NativeTableType;
  typedef PoolBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_ISGLOBAL = 8,
    VT_KERNELX = 10,
    VT_KERNELY = 12,
    VT_STRIDEX = 14,
    VT_STRIDEY = 16,
    VT_TYPE = 18,
    VT_PADTYPE = 20,
    VT_DATATYPE = 22,
    VT_CEILMODEL = 24,
    VT_PADS = 26,
    VT_COUNTTYPE = 28
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  bool isGlobal() const {
    return GetField<uint8_t>(VT_ISGLOBAL, 0) != 0;
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 0);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 0);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 0);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 0);
  }
  ace::PoolType type() const {
    return static_cast<ace::PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  ace::PoolPadType padType() const {
    return static_cast<ace::PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  ace::DataType dataType() const {
    return static_cast<ace::DataType>(GetField<int32_t>(VT_DATATYPE, 1));
  }
  bool ceilModel() const {
    return GetField<uint8_t>(VT_CEILMODEL, 1) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  ace::AvgPoolCountType countType() const {
    return static_cast<ace::AvgPoolCountType>(GetField<int8_t>(VT_COUNTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX, 4) &&
           VerifyField<int32_t>(verifier, VT_PADY, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISGLOBAL, 1) &&
           VerifyField<int32_t>(verifier, VT_KERNELX, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELY, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CEILMODEL, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_COUNTTYPE, 1) &&
           verifier.EndTable();
  }
  PoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolBuilder {
  typedef Pool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Pool::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Pool::VT_PADY, padY, 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(Pool::VT_ISGLOBAL, static_cast<uint8_t>(isGlobal), 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNELX, kernelX, 0);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNELY, kernelY, 0);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDEY, strideY, 0);
  }
  void add_type(ace::PoolType type) {
    fbb_.AddElement<int8_t>(Pool::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(ace::PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pool::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  void add_dataType(ace::DataType dataType) {
    fbb_.AddElement<int32_t>(Pool::VT_DATATYPE, static_cast<int32_t>(dataType), 1);
  }
  void add_ceilModel(bool ceilModel) {
    fbb_.AddElement<uint8_t>(Pool::VT_CEILMODEL, static_cast<uint8_t>(ceilModel), 1);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pool::VT_PADS, pads);
  }
  void add_countType(ace::AvgPoolCountType countType) {
    fbb_.AddElement<int8_t>(Pool::VT_COUNTTYPE, static_cast<int8_t>(countType), 0);
  }
  explicit PoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool> CreatePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    ace::PoolType type = ace::PoolType_MAXPOOL,
    ace::PoolPadType padType = ace::PoolPadType_CAFFE,
    ace::DataType dataType = ace::DataType_DT_FLOAT,
    bool ceilModel = true,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    ace::AvgPoolCountType countType = ace::AvgPoolCountType_DEFAULT) {
  PoolBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_dataType(dataType);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_countType(countType);
  builder_.add_ceilModel(ceilModel);
  builder_.add_padType(padType);
  builder_.add_type(type);
  builder_.add_isGlobal(isGlobal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pool> CreatePoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    ace::PoolType type = ace::PoolType_MAXPOOL,
    ace::PoolPadType padType = ace::PoolPadType_CAFFE,
    ace::DataType dataType = ace::DataType_DT_FLOAT,
    bool ceilModel = true,
    const std::vector<int32_t> *pads = nullptr,
    ace::AvgPoolCountType countType = ace::AvgPoolCountType_DEFAULT) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return ace::CreatePool(
      _fbb,
      padX,
      padY,
      isGlobal,
      kernelX,
      kernelY,
      strideX,
      strideY,
      type,
      padType,
      dataType,
      ceilModel,
      pads__,
      countType);
}

flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool3DT : public flatbuffers::NativeTable {
  typedef Pool3D TableType;
  std::vector<int32_t> strides{};
  std::vector<int32_t> kernels{};
  std::vector<int32_t> pads{};
  ace::PoolType type = ace::PoolType_MAXPOOL;
  ace::PoolPadType padType = ace::PoolPadType_CAFFE;
  bool isGlobal = false;
};

struct Pool3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool3DT NativeTableType;
  typedef Pool3DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool3DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDES = 4,
    VT_KERNELS = 6,
    VT_PADS = 8,
    VT_TYPE = 10,
    VT_PADTYPE = 12,
    VT_ISGLOBAL = 14
  };
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  ace::PoolType type() const {
    return static_cast<ace::PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  ace::PoolPadType padType() const {
    return static_cast<ace::PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  bool isGlobal() const {
    return GetField<uint8_t>(VT_ISGLOBAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISGLOBAL, 1) &&
           verifier.EndTable();
  }
  Pool3DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool3DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool3D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool3DBuilder {
  typedef Pool3D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Pool3D::VT_STRIDES, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Pool3D::VT_KERNELS, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pool3D::VT_PADS, pads);
  }
  void add_type(ace::PoolType type) {
    fbb_.AddElement<int8_t>(Pool3D::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(ace::PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pool3D::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(Pool3D::VT_ISGLOBAL, static_cast<uint8_t>(isGlobal), 0);
  }
  explicit Pool3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pool3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool3D> CreatePool3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    ace::PoolType type = ace::PoolType_MAXPOOL,
    ace::PoolPadType padType = ace::PoolPadType_CAFFE,
    bool isGlobal = false) {
  Pool3DBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_isGlobal(isGlobal);
  builder_.add_padType(padType);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pool3D> CreatePool3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    ace::PoolType type = ace::PoolType_MAXPOOL,
    ace::PoolPadType padType = ace::PoolPadType_CAFFE,
    bool isGlobal = false) {
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return ace::CreatePool3D(
      _fbb,
      strides__,
      kernels__,
      pads__,
      type,
      padType,
      isGlobal);
}

flatbuffers::Offset<Pool3D> CreatePool3D(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReluT : public flatbuffers::NativeTable {
  typedef Relu TableType;
  float slope = 0.0f;
};

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReluT NativeTableType;
  typedef ReluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE, 4) &&
           verifier.EndTable();
  }
  ReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReluBuilder {
  typedef Relu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(Relu::VT_SLOPE, slope, 0.0f);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Relu6T : public flatbuffers::NativeTable {
  typedef Relu6 TableType;
  float minValue = 0.0f;
  float maxValue = 6.0f;
};

struct Relu6 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Relu6T NativeTableType;
  typedef Relu6Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Relu6TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINVALUE = 4,
    VT_MAXVALUE = 6
  };
  float minValue() const {
    return GetField<float>(VT_MINVALUE, 0.0f);
  }
  float maxValue() const {
    return GetField<float>(VT_MAXVALUE, 6.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MINVALUE, 4) &&
           VerifyField<float>(verifier, VT_MAXVALUE, 4) &&
           verifier.EndTable();
  }
  Relu6T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu6> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Relu6Builder {
  typedef Relu6 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minValue(float minValue) {
    fbb_.AddElement<float>(Relu6::VT_MINVALUE, minValue, 0.0f);
  }
  void add_maxValue(float maxValue) {
    fbb_.AddElement<float>(Relu6::VT_MAXVALUE, maxValue, 6.0f);
  }
  explicit Relu6Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Relu6> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu6>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu6> CreateRelu6(
    flatbuffers::FlatBufferBuilder &_fbb,
    float minValue = 0.0f,
    float maxValue = 6.0f) {
  Relu6Builder builder_(_fbb);
  builder_.add_maxValue(maxValue);
  builder_.add_minValue(minValue);
  return builder_.Finish();
}

flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReluT : public flatbuffers::NativeTable {
  typedef PRelu TableType;
  int32_t slopeCount = 0;
  std::vector<float> slope{};
};

struct PRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReluT NativeTableType;
  typedef PReluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPECOUNT = 4,
    VT_SLOPE = 6
  };
  int32_t slopeCount() const {
    return GetField<int32_t>(VT_SLOPECOUNT, 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOPECOUNT, 4) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PRelu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReluBuilder {
  typedef PRelu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slopeCount(int32_t slopeCount) {
    fbb_.AddElement<int32_t>(PRelu::VT_SLOPECOUNT, slopeCount, 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PRelu::VT_SLOPE, slope);
  }
  explicit PReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<PRelu> CreatePRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slopeCount(slopeCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<PRelu> CreatePReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return ace::CreatePRelu(
      _fbb,
      slopeCount,
      slope__);
}

flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ELUT : public flatbuffers::NativeTable {
  typedef ELU TableType;
  float alpha = 0.0f;
};

struct ELU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ELUT NativeTableType;
  typedef ELUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ELUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
  ELUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ELU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ELUBuilder {
  typedef ELU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ELU::VT_ALPHA, alpha, 0.0f);
  }
  explicit ELUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ELU>(end);
    return o;
  }
};

inline flatbuffers::Offset<ELU> CreateELU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  ELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNT : public flatbuffers::NativeTable {
  typedef LRN TableType;
  int32_t regionType = 0;
  int32_t localSize = 0;
  float alpha = 0.0f;
  float beta = 0.0f;
  float bias = 1.0f;
};

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNT NativeTableType;
  typedef LRNBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGIONTYPE = 4,
    VT_LOCALSIZE = 6,
    VT_ALPHA = 8,
    VT_BETA = 10,
    VT_BIAS = 12
  };
  int32_t regionType() const {
    return GetField<int32_t>(VT_REGIONTYPE, 0);
  }
  int32_t localSize() const {
    return GetField<int32_t>(VT_LOCALSIZE, 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REGIONTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_LOCALSIZE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           verifier.EndTable();
  }
  LRNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNBuilder {
  typedef LRN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regionType(int32_t regionType) {
    fbb_.AddElement<int32_t>(LRN::VT_REGIONTYPE, regionType, 0);
  }
  void add_localSize(int32_t localSize) {
    fbb_.AddElement<int32_t>(LRN::VT_LOCALSIZE, localSize, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 1.0f);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t regionType = 0,
    int32_t localSize = 0,
    float alpha = 0.0f,
    float beta = 0.0f,
    float bias = 1.0f) {
  LRNBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_localSize(localSize);
  builder_.add_regionType(regionType);
  return builder_.Finish();
}

flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxT : public flatbuffers::NativeTable {
  typedef ArgMax TableType;
  int32_t outMaxVal = 0;
  int32_t topK = 0;
  int32_t axis = 0;
  int32_t softmaxThreshold = 0;
};

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxT NativeTableType;
  typedef ArgMaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTMAXVAL = 4,
    VT_TOPK = 6,
    VT_AXIS = 8,
    VT_SOFTMAXTHRESHOLD = 10
  };
  int32_t outMaxVal() const {
    return GetField<int32_t>(VT_OUTMAXVAL, 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t softmaxThreshold() const {
    return GetField<int32_t>(VT_SOFTMAXTHRESHOLD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTMAXVAL, 4) &&
           VerifyField<int32_t>(verifier, VT_TOPK, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_SOFTMAXTHRESHOLD, 4) &&
           verifier.EndTable();
  }
  ArgMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxBuilder {
  typedef ArgMax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outMaxVal(int32_t outMaxVal) {
    fbb_.AddElement<int32_t>(ArgMax::VT_OUTMAXVAL, outMaxVal, 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOPK, topK, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_softmaxThreshold(int32_t softmaxThreshold) {
    fbb_.AddElement<int32_t>(ArgMax::VT_SOFTMAXTHRESHOLD, softmaxThreshold, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outMaxVal = 0,
    int32_t topK = 0,
    int32_t axis = 0,
    int32_t softmaxThreshold = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_softmaxThreshold(softmaxThreshold);
  builder_.add_axis(axis);
  builder_.add_topK(topK);
  builder_.add_outMaxVal(outMaxVal);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AxisT : public flatbuffers::NativeTable {
  typedef Axis TableType;
  int32_t axis = 0;
};

struct Axis FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AxisT NativeTableType;
  typedef AxisBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AxisTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  AxisT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AxisT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Axis> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AxisBuilder {
  typedef Axis Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Axis::VT_AXIS, axis, 0);
  }
  explicit AxisBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Axis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Axis>(end);
    return o;
  }
};

inline flatbuffers::Offset<Axis> CreateAxis(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  AxisBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Axis> CreateAxis(flatbuffers::FlatBufferBuilder &_fbb, const AxisT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputT : public flatbuffers::NativeTable {
  typedef Input TableType;
  std::vector<int32_t> dims{};
  ace::DataType dtype = ace::DataType_DT_FLOAT;
  ace::DataFormat dformat = ace::DataFormat_NC4HW4;
};

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputT NativeTableType;
  typedef InputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  ace::DataType dtype() const {
    return static_cast<ace::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  ace::DataFormat dformat() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_DFORMAT, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           VerifyField<int8_t>(verifier, VT_DFORMAT, 1) &&
           verifier.EndTable();
  }
  InputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Input> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputBuilder {
  typedef Input Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Input::VT_DIMS, dims);
  }
  void add_dtype(ace::DataType dtype) {
    fbb_.AddElement<int32_t>(Input::VT_DTYPE, static_cast<int32_t>(dtype), 1);
  }
  void add_dformat(ace::DataFormat dformat) {
    fbb_.AddElement<int8_t>(Input::VT_DFORMAT, static_cast<int8_t>(dformat), 2);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    ace::DataType dtype = ace::DataType_DT_FLOAT,
    ace::DataFormat dformat = ace::DataFormat_NC4HW4) {
  InputBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    ace::DataType dtype = ace::DataType_DT_FLOAT,
    ace::DataFormat dformat = ace::DataFormat_NC4HW4) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return ace::CreateInput(
      _fbb,
      dims__,
      dtype,
      dformat);
}

flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMT : public flatbuffers::NativeTable {
  typedef LSTM TableType;
  int32_t outputCount = 0;
  int32_t weightSize = 0;
  float clippingThreshold = 0.0f;
  std::unique_ptr<ace::BlobT> weightI{};
  std::unique_ptr<ace::BlobT> weightH{};
  std::unique_ptr<ace::BlobT> bias{};
  std::unique_ptr<ace::BlobT> weightIQ{};
  std::unique_ptr<ace::BlobT> weightIA{};
  float quantScale = 0.0f;
  LSTMT() = default;
  LSTMT(const LSTMT &o);
  LSTMT(LSTMT&&) FLATBUFFERS_NOEXCEPT = default;
  LSTMT &operator=(LSTMT o) FLATBUFFERS_NOEXCEPT;
};

struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMT NativeTableType;
  typedef LSTMBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_WEIGHTSIZE = 6,
    VT_CLIPPINGTHRESHOLD = 8,
    VT_WEIGHTI = 10,
    VT_WEIGHTH = 12,
    VT_BIAS = 14,
    VT_WEIGHTIQ = 16,
    VT_WEIGHTIA = 18,
    VT_QUANTSCALE = 20
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  float clippingThreshold() const {
    return GetField<float>(VT_CLIPPINGTHRESHOLD, 0.0f);
  }
  const ace::Blob *weightI() const {
    return GetPointer<const ace::Blob *>(VT_WEIGHTI);
  }
  const ace::Blob *weightH() const {
    return GetPointer<const ace::Blob *>(VT_WEIGHTH);
  }
  const ace::Blob *bias() const {
    return GetPointer<const ace::Blob *>(VT_BIAS);
  }
  const ace::Blob *weightIQ() const {
    return GetPointer<const ace::Blob *>(VT_WEIGHTIQ);
  }
  const ace::Blob *weightIA() const {
    return GetPointer<const ace::Blob *>(VT_WEIGHTIA);
  }
  float quantScale() const {
    return GetField<float>(VT_QUANTSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE, 4) &&
           VerifyField<float>(verifier, VT_CLIPPINGTHRESHOLD, 4) &&
           VerifyOffset(verifier, VT_WEIGHTI) &&
           verifier.VerifyTable(weightI()) &&
           VerifyOffset(verifier, VT_WEIGHTH) &&
           verifier.VerifyTable(weightH()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           VerifyOffset(verifier, VT_WEIGHTIQ) &&
           verifier.VerifyTable(weightIQ()) &&
           VerifyOffset(verifier, VT_WEIGHTIA) &&
           verifier.VerifyTable(weightIA()) &&
           VerifyField<float>(verifier, VT_QUANTSCALE, 4) &&
           verifier.EndTable();
  }
  LSTMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMBuilder {
  typedef LSTM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(LSTM::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(LSTM::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_clippingThreshold(float clippingThreshold) {
    fbb_.AddElement<float>(LSTM::VT_CLIPPINGTHRESHOLD, clippingThreshold, 0.0f);
  }
  void add_weightI(flatbuffers::Offset<ace::Blob> weightI) {
    fbb_.AddOffset(LSTM::VT_WEIGHTI, weightI);
  }
  void add_weightH(flatbuffers::Offset<ace::Blob> weightH) {
    fbb_.AddOffset(LSTM::VT_WEIGHTH, weightH);
  }
  void add_bias(flatbuffers::Offset<ace::Blob> bias) {
    fbb_.AddOffset(LSTM::VT_BIAS, bias);
  }
  void add_weightIQ(flatbuffers::Offset<ace::Blob> weightIQ) {
    fbb_.AddOffset(LSTM::VT_WEIGHTIQ, weightIQ);
  }
  void add_weightIA(flatbuffers::Offset<ace::Blob> weightIA) {
    fbb_.AddOffset(LSTM::VT_WEIGHTIA, weightIA);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(LSTM::VT_QUANTSCALE, quantScale, 0.0f);
  }
  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTM> CreateLSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t weightSize = 0,
    float clippingThreshold = 0.0f,
    flatbuffers::Offset<ace::Blob> weightI = 0,
    flatbuffers::Offset<ace::Blob> weightH = 0,
    flatbuffers::Offset<ace::Blob> bias = 0,
    flatbuffers::Offset<ace::Blob> weightIQ = 0,
    flatbuffers::Offset<ace::Blob> weightIA = 0,
    float quantScale = 0.0f) {
  LSTMBuilder builder_(_fbb);
  builder_.add_quantScale(quantScale);
  builder_.add_weightIA(weightIA);
  builder_.add_weightIQ(weightIQ);
  builder_.add_bias(bias);
  builder_.add_weightH(weightH);
  builder_.add_weightI(weightI);
  builder_.add_clippingThreshold(clippingThreshold);
  builder_.add_weightSize(weightSize);
  builder_.add_outputCount(outputCount);
  return builder_.Finish();
}

flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceT : public flatbuffers::NativeTable {
  typedef Slice TableType;
  int32_t axis = 0;
  std::vector<int32_t> slicePoints{};
  ace::NetSource sourceType = ace::NetSource_CAFFE;
};

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceT NativeTableType;
  typedef SliceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SLICEPOINTS = 6,
    VT_SOURCETYPE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *slicePoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLICEPOINTS);
  }
  ace::NetSource sourceType() const {
    return static_cast<ace::NetSource>(GetField<int8_t>(VT_SOURCETYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyOffset(verifier, VT_SLICEPOINTS) &&
           verifier.VerifyVector(slicePoints()) &&
           VerifyField<int8_t>(verifier, VT_SOURCETYPE, 1) &&
           verifier.EndTable();
  }
  SliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Slice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceBuilder {
  typedef Slice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Slice::VT_AXIS, axis, 0);
  }
  void add_slicePoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints) {
    fbb_.AddOffset(Slice::VT_SLICEPOINTS, slicePoints);
  }
  void add_sourceType(ace::NetSource sourceType) {
    fbb_.AddElement<int8_t>(Slice::VT_SOURCETYPE, static_cast<int8_t>(sourceType), 0);
  }
  explicit SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints = 0,
    ace::NetSource sourceType = ace::NetSource_CAFFE) {
  SliceBuilder builder_(_fbb);
  builder_.add_slicePoints(slicePoints);
  builder_.add_axis(axis);
  builder_.add_sourceType(sourceType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *slicePoints = nullptr,
    ace::NetSource sourceType = ace::NetSource_CAFFE) {
  auto slicePoints__ = slicePoints ? _fbb.CreateVector<int32_t>(*slicePoints) : 0;
  return ace::CreateSlice(
      _fbb,
      axis,
      slicePoints__,
      sourceType);
}

flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormT : public flatbuffers::NativeTable {
  typedef BatchNorm TableType;
  int32_t channels = 0;
  std::vector<float> slopeData{};
  std::vector<float> meanData{};
  std::vector<float> varData{};
  std::vector<float> biasData{};
  std::vector<float> Adata{};
  std::vector<float> Bdata{};
  float epsilon = 0.001f;
};

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormT NativeTableType;
  typedef BatchNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SLOPEDATA = 6,
    VT_MEANDATA = 8,
    VT_VARDATA = 10,
    VT_BIASDATA = 12,
    VT_ADATA = 14,
    VT_BDATA = 16,
    VT_EPSILON = 18
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *slopeData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPEDATA);
  }
  const flatbuffers::Vector<float> *meanData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MEANDATA);
  }
  const flatbuffers::Vector<float> *varData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARDATA);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  const flatbuffers::Vector<float> *Adata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ADATA);
  }
  const flatbuffers::Vector<float> *Bdata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BDATA);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SLOPEDATA) &&
           verifier.VerifyVector(slopeData()) &&
           VerifyOffset(verifier, VT_MEANDATA) &&
           verifier.VerifyVector(meanData()) &&
           VerifyOffset(verifier, VT_VARDATA) &&
           verifier.VerifyVector(varData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, VT_ADATA) &&
           verifier.VerifyVector(Adata()) &&
           VerifyOffset(verifier, VT_BDATA) &&
           verifier.VerifyVector(Bdata()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           verifier.EndTable();
  }
  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormBuilder {
  typedef BatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(BatchNorm::VT_CHANNELS, channels, 0);
  }
  void add_slopeData(flatbuffers::Offset<flatbuffers::Vector<float>> slopeData) {
    fbb_.AddOffset(BatchNorm::VT_SLOPEDATA, slopeData);
  }
  void add_meanData(flatbuffers::Offset<flatbuffers::Vector<float>> meanData) {
    fbb_.AddOffset(BatchNorm::VT_MEANDATA, meanData);
  }
  void add_varData(flatbuffers::Offset<flatbuffers::Vector<float>> varData) {
    fbb_.AddOffset(BatchNorm::VT_VARDATA, varData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(BatchNorm::VT_BIASDATA, biasData);
  }
  void add_Adata(flatbuffers::Offset<flatbuffers::Vector<float>> Adata) {
    fbb_.AddOffset(BatchNorm::VT_ADATA, Adata);
  }
  void add_Bdata(flatbuffers::Offset<flatbuffers::Vector<float>> Bdata) {
    fbb_.AddOffset(BatchNorm::VT_BDATA, Bdata);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.001f);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slopeData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> meanData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> varData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Adata = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Bdata = 0,
    float epsilon = 0.001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_Bdata(Bdata);
  builder_.add_Adata(Adata);
  builder_.add_biasData(biasData);
  builder_.add_varData(varData);
  builder_.add_meanData(meanData);
  builder_.add_slopeData(slopeData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *slopeData = nullptr,
    const std::vector<float> *meanData = nullptr,
    const std::vector<float> *varData = nullptr,
    const std::vector<float> *biasData = nullptr,
    const std::vector<float> *Adata = nullptr,
    const std::vector<float> *Bdata = nullptr,
    float epsilon = 0.001f) {
  auto slopeData__ = slopeData ? _fbb.CreateVector<float>(*slopeData) : 0;
  auto meanData__ = meanData ? _fbb.CreateVector<float>(*meanData) : 0;
  auto varData__ = varData ? _fbb.CreateVector<float>(*varData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  auto Adata__ = Adata ? _fbb.CreateVector<float>(*Adata) : 0;
  auto Bdata__ = Bdata ? _fbb.CreateVector<float>(*Bdata) : 0;
  return ace::CreateBatchNorm(
      _fbb,
      channels,
      slopeData__,
      meanData__,
      varData__,
      biasData__,
      Adata__,
      Bdata__,
      epsilon);
}

flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleT : public flatbuffers::NativeTable {
  typedef Scale TableType;
  int32_t channels = 0;
  std::vector<float> scaleData{};
  std::vector<float> biasData{};
  std::vector<int64_t> external{};
};

struct Scale FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleT NativeTableType;
  typedef ScaleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SCALEDATA = 6,
    VT_BIASDATA = 8,
    VT_EXTERNAL = 10
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *scaleData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALEDATA);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  const flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SCALEDATA) &&
           verifier.VerifyVector(scaleData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
  ScaleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Scale> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleBuilder {
  typedef Scale Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(Scale::VT_CHANNELS, channels, 0);
  }
  void add_scaleData(flatbuffers::Offset<flatbuffers::Vector<float>> scaleData) {
    fbb_.AddOffset(Scale::VT_SCALEDATA, scaleData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(Scale::VT_BIASDATA, biasData);
  }
  void add_external(flatbuffers::Offset<flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Scale::VT_EXTERNAL, external);
  }
  explicit ScaleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scale> CreateScale(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scaleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> external = 0) {
  ScaleBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_biasData(biasData);
  builder_.add_scaleData(scaleData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scale> CreateScaleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *scaleData = nullptr,
    const std::vector<float> *biasData = nullptr,
    const std::vector<int64_t> *external = nullptr) {
  auto scaleData__ = scaleData ? _fbb.CreateVector<float>(*scaleData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return ace::CreateScale(
      _fbb,
      channels,
      scaleData__,
      biasData__,
      external__);
}

flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseT : public flatbuffers::NativeTable {
  typedef Eltwise TableType;
  ace::EltwiseType type = ace::EltwiseType_PROD;
  std::vector<float> coeff{};
};

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseT NativeTableType;
  typedef EltwiseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COEFF = 6
  };
  ace::EltwiseType type() const {
    return static_cast<ace::EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseBuilder {
  typedef Eltwise Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ace::EltwiseType type) {
    fbb_.AddElement<int8_t>(Eltwise::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(Eltwise::VT_COEFF, coeff);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::EltwiseType type = ace::EltwiseType_PROD,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Eltwise> CreateEltwiseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::EltwiseType type = ace::EltwiseType_PROD,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return ace::CreateEltwise(
      _fbb,
      type,
      coeff__);
}

flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenT : public flatbuffers::NativeTable {
  typedef Flatten TableType;
  int32_t axis = 0;
  int32_t endAxis = 0;
};

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenT NativeTableType;
  typedef FlattenBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ENDAXIS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t endAxis() const {
    return GetField<int32_t>(VT_ENDAXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDAXIS, 4) &&
           verifier.EndTable();
  }
  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenBuilder {
  typedef Flatten Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Flatten::VT_AXIS, axis, 0);
  }
  void add_endAxis(int32_t endAxis) {
    fbb_.AddElement<int32_t>(Flatten::VT_ENDAXIS, endAxis, 0);
  }
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t endAxis = 0) {
  FlattenBuilder builder_(_fbb);
  builder_.add_endAxis(endAxis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteT : public flatbuffers::NativeTable {
  typedef Permute TableType;
  std::vector<int32_t> dims{};
};

struct Permute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteT NativeTableType;
  typedef PermuteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PermuteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  PermuteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Permute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteBuilder {
  typedef Permute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Permute::VT_DIMS, dims);
  }
  explicit PermuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Permute> CreatePermute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Permute> CreatePermuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return ace::CreatePermute(
      _fbb,
      dims__);
}

flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeT : public flatbuffers::NativeTable {
  typedef Reshape TableType;
  std::vector<int32_t> dims{};
  ace::DataFormat dimType = ace::DataFormat_NCHW;
};

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeT NativeTableType;
  typedef ReshapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DIMTYPE = 6
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  ace::DataFormat dimType() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_DIMTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, VT_DIMTYPE, 1) &&
           verifier.EndTable();
  }
  ReshapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reshape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeBuilder {
  typedef Reshape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Reshape::VT_DIMS, dims);
  }
  void add_dimType(ace::DataFormat dimType) {
    fbb_.AddElement<int8_t>(Reshape::VT_DIMTYPE, static_cast<int8_t>(dimType), 0);
  }
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    ace::DataFormat dimType = ace::DataFormat_NCHW) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimType(dimType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reshape> CreateReshapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    ace::DataFormat dimType = ace::DataFormat_NCHW) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return ace::CreateReshape(
      _fbb,
      dims__,
      dimType);
}

flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionOutputT : public flatbuffers::NativeTable {
  typedef DetectionOutput TableType;
  int32_t classCount = 0;
  float nmsThresholdold = 0.0f;
  int32_t nmsTopK = 0;
  int32_t keepTopK = 0;
  float confidenceThreshold = 0.0f;
  int32_t shareLocation = 0;
  int32_t backgroundLable = 0;
  int32_t varianceEncodedTarget = 0;
  int32_t codeType = 0;
  float objectnessScore = 0.01f;
};

struct DetectionOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionOutputT NativeTableType;
  typedef DetectionOutputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionOutputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSCOUNT = 4,
    VT_NMSTHRESHOLDOLD = 6,
    VT_NMSTOPK = 8,
    VT_KEEPTOPK = 10,
    VT_CONFIDENCETHRESHOLD = 12,
    VT_SHARELOCATION = 14,
    VT_BACKGROUNDLABLE = 16,
    VT_VARIANCEENCODEDTARGET = 18,
    VT_CODETYPE = 20,
    VT_OBJECTNESSSCORE = 22
  };
  int32_t classCount() const {
    return GetField<int32_t>(VT_CLASSCOUNT, 0);
  }
  float nmsThresholdold() const {
    return GetField<float>(VT_NMSTHRESHOLDOLD, 0.0f);
  }
  int32_t nmsTopK() const {
    return GetField<int32_t>(VT_NMSTOPK, 0);
  }
  int32_t keepTopK() const {
    return GetField<int32_t>(VT_KEEPTOPK, 0);
  }
  float confidenceThreshold() const {
    return GetField<float>(VT_CONFIDENCETHRESHOLD, 0.0f);
  }
  int32_t shareLocation() const {
    return GetField<int32_t>(VT_SHARELOCATION, 0);
  }
  int32_t backgroundLable() const {
    return GetField<int32_t>(VT_BACKGROUNDLABLE, 0);
  }
  int32_t varianceEncodedTarget() const {
    return GetField<int32_t>(VT_VARIANCEENCODEDTARGET, 0);
  }
  int32_t codeType() const {
    return GetField<int32_t>(VT_CODETYPE, 0);
  }
  float objectnessScore() const {
    return GetField<float>(VT_OBJECTNESSSCORE, 0.01f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASSCOUNT, 4) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLDOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_NMSTOPK, 4) &&
           VerifyField<int32_t>(verifier, VT_KEEPTOPK, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCETHRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_SHARELOCATION, 4) &&
           VerifyField<int32_t>(verifier, VT_BACKGROUNDLABLE, 4) &&
           VerifyField<int32_t>(verifier, VT_VARIANCEENCODEDTARGET, 4) &&
           VerifyField<int32_t>(verifier, VT_CODETYPE, 4) &&
           VerifyField<float>(verifier, VT_OBJECTNESSSCORE, 4) &&
           verifier.EndTable();
  }
  DetectionOutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionOutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionOutput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionOutputBuilder {
  typedef DetectionOutput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_classCount(int32_t classCount) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_CLASSCOUNT, classCount, 0);
  }
  void add_nmsThresholdold(float nmsThresholdold) {
    fbb_.AddElement<float>(DetectionOutput::VT_NMSTHRESHOLDOLD, nmsThresholdold, 0.0f);
  }
  void add_nmsTopK(int32_t nmsTopK) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_NMSTOPK, nmsTopK, 0);
  }
  void add_keepTopK(int32_t keepTopK) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_KEEPTOPK, keepTopK, 0);
  }
  void add_confidenceThreshold(float confidenceThreshold) {
    fbb_.AddElement<float>(DetectionOutput::VT_CONFIDENCETHRESHOLD, confidenceThreshold, 0.0f);
  }
  void add_shareLocation(int32_t shareLocation) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_SHARELOCATION, shareLocation, 0);
  }
  void add_backgroundLable(int32_t backgroundLable) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_BACKGROUNDLABLE, backgroundLable, 0);
  }
  void add_varianceEncodedTarget(int32_t varianceEncodedTarget) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_VARIANCEENCODEDTARGET, varianceEncodedTarget, 0);
  }
  void add_codeType(int32_t codeType) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_CODETYPE, codeType, 0);
  }
  void add_objectnessScore(float objectnessScore) {
    fbb_.AddElement<float>(DetectionOutput::VT_OBJECTNESSSCORE, objectnessScore, 0.01f);
  }
  explicit DetectionOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectionOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classCount = 0,
    float nmsThresholdold = 0.0f,
    int32_t nmsTopK = 0,
    int32_t keepTopK = 0,
    float confidenceThreshold = 0.0f,
    int32_t shareLocation = 0,
    int32_t backgroundLable = 0,
    int32_t varianceEncodedTarget = 0,
    int32_t codeType = 0,
    float objectnessScore = 0.01f) {
  DetectionOutputBuilder builder_(_fbb);
  builder_.add_objectnessScore(objectnessScore);
  builder_.add_codeType(codeType);
  builder_.add_varianceEncodedTarget(varianceEncodedTarget);
  builder_.add_backgroundLable(backgroundLable);
  builder_.add_shareLocation(shareLocation);
  builder_.add_confidenceThreshold(confidenceThreshold);
  builder_.add_keepTopK(keepTopK);
  builder_.add_nmsTopK(nmsTopK);
  builder_.add_nmsThresholdold(nmsThresholdold);
  builder_.add_classCount(classCount);
  return builder_.Finish();
}

flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoiParametersT : public flatbuffers::NativeTable {
  typedef RoiParameters TableType;
  int32_t pooledWidth = 0;
  int32_t pooledHeight = 0;
  float spatialScale = 0.0f;
  int32_t samplingRatio = -1;
  bool aligned = false;
  ace::PoolType poolType = ace::PoolType_AVEPOOL;
};

struct RoiParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoiParametersT NativeTableType;
  typedef RoiParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoiParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLEDWIDTH = 4,
    VT_POOLEDHEIGHT = 6,
    VT_SPATIALSCALE = 8,
    VT_SAMPLINGRATIO = 10,
    VT_ALIGNED = 12,
    VT_POOLTYPE = 14
  };
  int32_t pooledWidth() const {
    return GetField<int32_t>(VT_POOLEDWIDTH, 0);
  }
  int32_t pooledHeight() const {
    return GetField<int32_t>(VT_POOLEDHEIGHT, 0);
  }
  float spatialScale() const {
    return GetField<float>(VT_SPATIALSCALE, 0.0f);
  }
  int32_t samplingRatio() const {
    return GetField<int32_t>(VT_SAMPLINGRATIO, -1);
  }
  bool aligned() const {
    return GetField<uint8_t>(VT_ALIGNED, 0) != 0;
  }
  ace::PoolType poolType() const {
    return static_cast<ace::PoolType>(GetField<int8_t>(VT_POOLTYPE, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POOLEDWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_POOLEDHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_SPATIALSCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_SAMPLINGRATIO, 4) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNED, 1) &&
           VerifyField<int8_t>(verifier, VT_POOLTYPE, 1) &&
           verifier.EndTable();
  }
  RoiParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoiParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoiParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoiParametersBuilder {
  typedef RoiParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledWidth(int32_t pooledWidth) {
    fbb_.AddElement<int32_t>(RoiParameters::VT_POOLEDWIDTH, pooledWidth, 0);
  }
  void add_pooledHeight(int32_t pooledHeight) {
    fbb_.AddElement<int32_t>(RoiParameters::VT_POOLEDHEIGHT, pooledHeight, 0);
  }
  void add_spatialScale(float spatialScale) {
    fbb_.AddElement<float>(RoiParameters::VT_SPATIALSCALE, spatialScale, 0.0f);
  }
  void add_samplingRatio(int32_t samplingRatio) {
    fbb_.AddElement<int32_t>(RoiParameters::VT_SAMPLINGRATIO, samplingRatio, -1);
  }
  void add_aligned(bool aligned) {
    fbb_.AddElement<uint8_t>(RoiParameters::VT_ALIGNED, static_cast<uint8_t>(aligned), 0);
  }
  void add_poolType(ace::PoolType poolType) {
    fbb_.AddElement<int8_t>(RoiParameters::VT_POOLTYPE, static_cast<int8_t>(poolType), 1);
  }
  explicit RoiParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoiParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoiParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoiParameters> CreateRoiParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledWidth = 0,
    int32_t pooledHeight = 0,
    float spatialScale = 0.0f,
    int32_t samplingRatio = -1,
    bool aligned = false,
    ace::PoolType poolType = ace::PoolType_AVEPOOL) {
  RoiParametersBuilder builder_(_fbb);
  builder_.add_samplingRatio(samplingRatio);
  builder_.add_spatialScale(spatialScale);
  builder_.add_pooledHeight(pooledHeight);
  builder_.add_pooledWidth(pooledWidth);
  builder_.add_poolType(poolType);
  builder_.add_aligned(aligned);
  return builder_.Finish();
}

flatbuffers::Offset<RoiParameters> CreateRoiParameters(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalT : public flatbuffers::NativeTable {
  typedef Proposal TableType;
  int32_t featStride = 0;
  int32_t baseSize = 0;
  int32_t preNmsTopN = 0;
  int32_t afterNmsTopN = 0;
  float nmsThreshold = 0.0f;
  int32_t minSize = 0;
  std::unique_ptr<ace::BlobT> ratios{};
  std::unique_ptr<ace::BlobT> scales{};
  std::unique_ptr<ace::BlobT> anchors{};
  ProposalT() = default;
  ProposalT(const ProposalT &o);
  ProposalT(ProposalT&&) FLATBUFFERS_NOEXCEPT = default;
  ProposalT &operator=(ProposalT o) FLATBUFFERS_NOEXCEPT;
};

struct Proposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalT NativeTableType;
  typedef ProposalBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProposalTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATSTRIDE = 4,
    VT_BASESIZE = 6,
    VT_PRENMSTOPN = 8,
    VT_AFTERNMSTOPN = 10,
    VT_NMSTHRESHOLD = 12,
    VT_MINSIZE = 14,
    VT_RATIOS = 16,
    VT_SCALES = 18,
    VT_ANCHORS = 20
  };
  int32_t featStride() const {
    return GetField<int32_t>(VT_FEATSTRIDE, 0);
  }
  int32_t baseSize() const {
    return GetField<int32_t>(VT_BASESIZE, 0);
  }
  int32_t preNmsTopN() const {
    return GetField<int32_t>(VT_PRENMSTOPN, 0);
  }
  int32_t afterNmsTopN() const {
    return GetField<int32_t>(VT_AFTERNMSTOPN, 0);
  }
  float nmsThreshold() const {
    return GetField<float>(VT_NMSTHRESHOLD, 0.0f);
  }
  int32_t minSize() const {
    return GetField<int32_t>(VT_MINSIZE, 0);
  }
  const ace::Blob *ratios() const {
    return GetPointer<const ace::Blob *>(VT_RATIOS);
  }
  const ace::Blob *scales() const {
    return GetPointer<const ace::Blob *>(VT_SCALES);
  }
  const ace::Blob *anchors() const {
    return GetPointer<const ace::Blob *>(VT_ANCHORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FEATSTRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_BASESIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_PRENMSTOPN, 4) &&
           VerifyField<int32_t>(verifier, VT_AFTERNMSTOPN, 4) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_MINSIZE, 4) &&
           VerifyOffset(verifier, VT_RATIOS) &&
           verifier.VerifyTable(ratios()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, VT_ANCHORS) &&
           verifier.VerifyTable(anchors()) &&
           verifier.EndTable();
  }
  ProposalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Proposal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalBuilder {
  typedef Proposal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_featStride(int32_t featStride) {
    fbb_.AddElement<int32_t>(Proposal::VT_FEATSTRIDE, featStride, 0);
  }
  void add_baseSize(int32_t baseSize) {
    fbb_.AddElement<int32_t>(Proposal::VT_BASESIZE, baseSize, 0);
  }
  void add_preNmsTopN(int32_t preNmsTopN) {
    fbb_.AddElement<int32_t>(Proposal::VT_PRENMSTOPN, preNmsTopN, 0);
  }
  void add_afterNmsTopN(int32_t afterNmsTopN) {
    fbb_.AddElement<int32_t>(Proposal::VT_AFTERNMSTOPN, afterNmsTopN, 0);
  }
  void add_nmsThreshold(float nmsThreshold) {
    fbb_.AddElement<float>(Proposal::VT_NMSTHRESHOLD, nmsThreshold, 0.0f);
  }
  void add_minSize(int32_t minSize) {
    fbb_.AddElement<int32_t>(Proposal::VT_MINSIZE, minSize, 0);
  }
  void add_ratios(flatbuffers::Offset<ace::Blob> ratios) {
    fbb_.AddOffset(Proposal::VT_RATIOS, ratios);
  }
  void add_scales(flatbuffers::Offset<ace::Blob> scales) {
    fbb_.AddOffset(Proposal::VT_SCALES, scales);
  }
  void add_anchors(flatbuffers::Offset<ace::Blob> anchors) {
    fbb_.AddOffset(Proposal::VT_ANCHORS, anchors);
  }
  explicit ProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal> CreateProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featStride = 0,
    int32_t baseSize = 0,
    int32_t preNmsTopN = 0,
    int32_t afterNmsTopN = 0,
    float nmsThreshold = 0.0f,
    int32_t minSize = 0,
    flatbuffers::Offset<ace::Blob> ratios = 0,
    flatbuffers::Offset<ace::Blob> scales = 0,
    flatbuffers::Offset<ace::Blob> anchors = 0) {
  ProposalBuilder builder_(_fbb);
  builder_.add_anchors(anchors);
  builder_.add_scales(scales);
  builder_.add_ratios(ratios);
  builder_.add_minSize(minSize);
  builder_.add_nmsThreshold(nmsThreshold);
  builder_.add_afterNmsTopN(afterNmsTopN);
  builder_.add_preNmsTopN(preNmsTopN);
  builder_.add_baseSize(baseSize);
  builder_.add_featStride(featStride);
  return builder_.Finish();
}

flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InterpT : public flatbuffers::NativeTable {
  typedef Interp TableType;
  float widthScale = 0.0f;
  float heightScale = 0.0f;
  int32_t outputWidth = 0;
  int32_t outputHeight = 0;
  int32_t resizeType = 0;
  bool alignCorners = false;
  bool halfPixelCenters = false;
  float widthOffset = 0.0f;
  float heightOffset = 0.0f;
  float cubicCoeffA = -0.75f;
  ace::CoordinateTransformationMode ctm = ace::CoordinateTransformationMode_NotSet;
  float depthScale = 0.0f;
  int32_t outputDepth = 0;
  float depthOffset = 0.0f;
};

struct Interp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterpT NativeTableType;
  typedef InterpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InterpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTHSCALE = 4,
    VT_HEIGHTSCALE = 6,
    VT_OUTPUTWIDTH = 8,
    VT_OUTPUTHEIGHT = 10,
    VT_RESIZETYPE = 12,
    VT_ALIGNCORNERS = 14,
    VT_HALFPIXELCENTERS = 16,
    VT_WIDTHOFFSET = 18,
    VT_HEIGHTOFFSET = 20,
    VT_CUBICCOEFFA = 22,
    VT_CTM = 24,
    VT_DEPTHSCALE = 26,
    VT_OUTPUTDEPTH = 28,
    VT_DEPTHOFFSET = 30
  };
  float widthScale() const {
    return GetField<float>(VT_WIDTHSCALE, 0.0f);
  }
  float heightScale() const {
    return GetField<float>(VT_HEIGHTSCALE, 0.0f);
  }
  int32_t outputWidth() const {
    return GetField<int32_t>(VT_OUTPUTWIDTH, 0);
  }
  int32_t outputHeight() const {
    return GetField<int32_t>(VT_OUTPUTHEIGHT, 0);
  }
  int32_t resizeType() const {
    return GetField<int32_t>(VT_RESIZETYPE, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool halfPixelCenters() const {
    return GetField<uint8_t>(VT_HALFPIXELCENTERS, 0) != 0;
  }
  float widthOffset() const {
    return GetField<float>(VT_WIDTHOFFSET, 0.0f);
  }
  float heightOffset() const {
    return GetField<float>(VT_HEIGHTOFFSET, 0.0f);
  }
  float cubicCoeffA() const {
    return GetField<float>(VT_CUBICCOEFFA, -0.75f);
  }
  ace::CoordinateTransformationMode ctm() const {
    return static_cast<ace::CoordinateTransformationMode>(GetField<int8_t>(VT_CTM, 0));
  }
  float depthScale() const {
    return GetField<float>(VT_DEPTHSCALE, 0.0f);
  }
  int32_t outputDepth() const {
    return GetField<int32_t>(VT_OUTPUTDEPTH, 0);
  }
  float depthOffset() const {
    return GetField<float>(VT_DEPTHOFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTHSCALE, 4) &&
           VerifyField<float>(verifier, VT_HEIGHTSCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_RESIZETYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HALFPIXELCENTERS, 1) &&
           VerifyField<float>(verifier, VT_WIDTHOFFSET, 4) &&
           VerifyField<float>(verifier, VT_HEIGHTOFFSET, 4) &&
           VerifyField<float>(verifier, VT_CUBICCOEFFA, 4) &&
           VerifyField<int8_t>(verifier, VT_CTM, 1) &&
           VerifyField<float>(verifier, VT_DEPTHSCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTDEPTH, 4) &&
           VerifyField<float>(verifier, VT_DEPTHOFFSET, 4) &&
           verifier.EndTable();
  }
  InterpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InterpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Interp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InterpBuilder {
  typedef Interp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_widthScale(float widthScale) {
    fbb_.AddElement<float>(Interp::VT_WIDTHSCALE, widthScale, 0.0f);
  }
  void add_heightScale(float heightScale) {
    fbb_.AddElement<float>(Interp::VT_HEIGHTSCALE, heightScale, 0.0f);
  }
  void add_outputWidth(int32_t outputWidth) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTWIDTH, outputWidth, 0);
  }
  void add_outputHeight(int32_t outputHeight) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTHEIGHT, outputHeight, 0);
  }
  void add_resizeType(int32_t resizeType) {
    fbb_.AddElement<int32_t>(Interp::VT_RESIZETYPE, resizeType, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(Interp::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_halfPixelCenters(bool halfPixelCenters) {
    fbb_.AddElement<uint8_t>(Interp::VT_HALFPIXELCENTERS, static_cast<uint8_t>(halfPixelCenters), 0);
  }
  void add_widthOffset(float widthOffset) {
    fbb_.AddElement<float>(Interp::VT_WIDTHOFFSET, widthOffset, 0.0f);
  }
  void add_heightOffset(float heightOffset) {
    fbb_.AddElement<float>(Interp::VT_HEIGHTOFFSET, heightOffset, 0.0f);
  }
  void add_cubicCoeffA(float cubicCoeffA) {
    fbb_.AddElement<float>(Interp::VT_CUBICCOEFFA, cubicCoeffA, -0.75f);
  }
  void add_ctm(ace::CoordinateTransformationMode ctm) {
    fbb_.AddElement<int8_t>(Interp::VT_CTM, static_cast<int8_t>(ctm), 0);
  }
  void add_depthScale(float depthScale) {
    fbb_.AddElement<float>(Interp::VT_DEPTHSCALE, depthScale, 0.0f);
  }
  void add_outputDepth(int32_t outputDepth) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTDEPTH, outputDepth, 0);
  }
  void add_depthOffset(float depthOffset) {
    fbb_.AddElement<float>(Interp::VT_DEPTHOFFSET, depthOffset, 0.0f);
  }
  explicit InterpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Interp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Interp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Interp> CreateInterp(
    flatbuffers::FlatBufferBuilder &_fbb,
    float widthScale = 0.0f,
    float heightScale = 0.0f,
    int32_t outputWidth = 0,
    int32_t outputHeight = 0,
    int32_t resizeType = 0,
    bool alignCorners = false,
    bool halfPixelCenters = false,
    float widthOffset = 0.0f,
    float heightOffset = 0.0f,
    float cubicCoeffA = -0.75f,
    ace::CoordinateTransformationMode ctm = ace::CoordinateTransformationMode_NotSet,
    float depthScale = 0.0f,
    int32_t outputDepth = 0,
    float depthOffset = 0.0f) {
  InterpBuilder builder_(_fbb);
  builder_.add_depthOffset(depthOffset);
  builder_.add_outputDepth(outputDepth);
  builder_.add_depthScale(depthScale);
  builder_.add_cubicCoeffA(cubicCoeffA);
  builder_.add_heightOffset(heightOffset);
  builder_.add_widthOffset(widthOffset);
  builder_.add_resizeType(resizeType);
  builder_.add_outputHeight(outputHeight);
  builder_.add_outputWidth(outputWidth);
  builder_.add_heightScale(heightScale);
  builder_.add_widthScale(widthScale);
  builder_.add_ctm(ctm);
  builder_.add_halfPixelCenters(halfPixelCenters);
  builder_.add_alignCorners(alignCorners);
  return builder_.Finish();
}

flatbuffers::Offset<Interp> CreateInterp(flatbuffers::FlatBufferBuilder &_fbb, const InterpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeT : public flatbuffers::NativeTable {
  typedef Resize TableType;
  float xScale = 0.0f;
  float yScale = 0.0f;
};

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeT NativeTableType;
  typedef ResizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XSCALE = 4,
    VT_YSCALE = 6
  };
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_XSCALE, 4) &&
           VerifyField<float>(verifier, VT_YSCALE, 4) &&
           verifier.EndTable();
  }
  ResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBuilder {
  typedef Resize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(Resize::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(Resize::VT_YSCALE, yScale, 0.0f);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float xScale = 0.0f,
    float yScale = 0.0f) {
  ResizeBuilder builder_(_fbb);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  return builder_.Finish();
}

flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxT : public flatbuffers::NativeTable {
  typedef PriorBox TableType;
  std::vector<float> minSizes{};
  std::vector<float> maxSizes{};
  std::vector<float> aspectRatios{};
  std::vector<float> variances{};
  bool flip = false;
  bool clip = false;
  int32_t imageWidth = 0;
  int32_t imageHeight = 0;
  int32_t stepWidth = 0;
  int32_t stepHeight = 0;
  float offset = 0.0f;
};

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxT NativeTableType;
  typedef PriorBoxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINSIZES = 4,
    VT_MAXSIZES = 6,
    VT_ASPECTRATIOS = 8,
    VT_VARIANCES = 10,
    VT_FLIP = 12,
    VT_CLIP = 14,
    VT_IMAGEWIDTH = 16,
    VT_IMAGEHEIGHT = 18,
    VT_STEPWIDTH = 20,
    VT_STEPHEIGHT = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<float> *minSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MINSIZES);
  }
  const flatbuffers::Vector<float> *maxSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAXSIZES);
  }
  const flatbuffers::Vector<float> *aspectRatios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECTRATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  int32_t imageWidth() const {
    return GetField<int32_t>(VT_IMAGEWIDTH, 0);
  }
  int32_t imageHeight() const {
    return GetField<int32_t>(VT_IMAGEHEIGHT, 0);
  }
  int32_t stepWidth() const {
    return GetField<int32_t>(VT_STEPWIDTH, 0);
  }
  int32_t stepHeight() const {
    return GetField<int32_t>(VT_STEPHEIGHT, 0);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINSIZES) &&
           verifier.VerifyVector(minSizes()) &&
           VerifyOffset(verifier, VT_MAXSIZES) &&
           verifier.VerifyVector(maxSizes()) &&
           VerifyOffset(verifier, VT_ASPECTRATIOS) &&
           verifier.VerifyVector(aspectRatios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint8_t>(verifier, VT_FLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLIP, 1) &&
           VerifyField<int32_t>(verifier, VT_IMAGEWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_IMAGEHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_OFFSET, 4) &&
           verifier.EndTable();
  }
  PriorBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxBuilder {
  typedef PriorBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minSizes(flatbuffers::Offset<flatbuffers::Vector<float>> minSizes) {
    fbb_.AddOffset(PriorBox::VT_MINSIZES, minSizes);
  }
  void add_maxSizes(flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes) {
    fbb_.AddOffset(PriorBox::VT_MAXSIZES, maxSizes);
  }
  void add_aspectRatios(flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios) {
    fbb_.AddOffset(PriorBox::VT_ASPECTRATIOS, aspectRatios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_imageWidth(int32_t imageWidth) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGEWIDTH, imageWidth, 0);
  }
  void add_imageHeight(int32_t imageHeight) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGEHEIGHT, imageHeight, 0);
  }
  void add_stepWidth(int32_t stepWidth) {
    fbb_.AddElement<int32_t>(PriorBox::VT_STEPWIDTH, stepWidth, 0);
  }
  void add_stepHeight(int32_t stepHeight) {
    fbb_.AddElement<int32_t>(PriorBox::VT_STEPHEIGHT, stepHeight, 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> minSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_stepHeight(stepHeight);
  builder_.add_stepWidth(stepWidth);
  builder_.add_imageHeight(imageHeight);
  builder_.add_imageWidth(imageWidth);
  builder_.add_variances(variances);
  builder_.add_aspectRatios(aspectRatios);
  builder_.add_maxSizes(maxSizes);
  builder_.add_minSizes(minSizes);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *minSizes = nullptr,
    const std::vector<float> *maxSizes = nullptr,
    const std::vector<float> *aspectRatios = nullptr,
    const std::vector<float> *variances = nullptr,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  auto minSizes__ = minSizes ? _fbb.CreateVector<float>(*minSizes) : 0;
  auto maxSizes__ = maxSizes ? _fbb.CreateVector<float>(*maxSizes) : 0;
  auto aspectRatios__ = aspectRatios ? _fbb.CreateVector<float>(*aspectRatios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return ace::CreatePriorBox(
      _fbb,
      minSizes__,
      maxSizes__,
      aspectRatios__,
      variances__,
      flip,
      clip,
      imageWidth,
      imageHeight,
      stepWidth,
      stepHeight,
      offset);
}

flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizeT : public flatbuffers::NativeTable {
  typedef Normalize TableType;
  int32_t acrossSpatial = 0;
  int32_t channelShared = 0;
  float eps = 0.0f;
  std::vector<float> scale{};
};

struct Normalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizeT NativeTableType;
  typedef NormalizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NormalizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACROSSSPATIAL = 4,
    VT_CHANNELSHARED = 6,
    VT_EPS = 8,
    VT_SCALE = 10
  };
  int32_t acrossSpatial() const {
    return GetField<int32_t>(VT_ACROSSSPATIAL, 0);
  }
  int32_t channelShared() const {
    return GetField<int32_t>(VT_CHANNELSHARED, 0);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACROSSSPATIAL, 4) &&
           VerifyField<int32_t>(verifier, VT_CHANNELSHARED, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
  NormalizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Normalize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizeBuilder {
  typedef Normalize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acrossSpatial(int32_t acrossSpatial) {
    fbb_.AddElement<int32_t>(Normalize::VT_ACROSSSPATIAL, acrossSpatial, 0);
  }
  void add_channelShared(int32_t channelShared) {
    fbb_.AddElement<int32_t>(Normalize::VT_CHANNELSHARED, channelShared, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(Normalize::VT_EPS, eps, 0.0f);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(Normalize::VT_SCALE, scale);
  }
  explicit NormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Normalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Normalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normalize> CreateNormalize(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  NormalizeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_eps(eps);
  builder_.add_channelShared(channelShared);
  builder_.add_acrossSpatial(acrossSpatial);
  return builder_.Finish();
}

inline flatbuffers::Offset<Normalize> CreateNormalizeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    const std::vector<float> *scale = nullptr) {
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return ace::CreateNormalize(
      _fbb,
      acrossSpatial,
      channelShared,
      eps,
      scale__);
}

flatbuffers::Offset<Normalize> CreateNormalize(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseInt8T : public flatbuffers::NativeTable {
  typedef EltwiseInt8 TableType;
  ace::EltwiseType type = ace::EltwiseType_PROD;
  std::unique_ptr<ace::QuantizedFloatParamT> inputQuan0{};
  std::unique_ptr<ace::QuantizedFloatParamT> inputQuan1{};
  std::unique_ptr<ace::QuantizedFloatParamT> outputQuan{};
  EltwiseInt8T() = default;
  EltwiseInt8T(const EltwiseInt8T &o);
  EltwiseInt8T(EltwiseInt8T&&) FLATBUFFERS_NOEXCEPT = default;
  EltwiseInt8T &operator=(EltwiseInt8T o) FLATBUFFERS_NOEXCEPT;
};

struct EltwiseInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseInt8T NativeTableType;
  typedef EltwiseInt8Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseInt8TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTQUAN0 = 6,
    VT_INPUTQUAN1 = 8,
    VT_OUTPUTQUAN = 10
  };
  ace::EltwiseType type() const {
    return static_cast<ace::EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ace::QuantizedFloatParam *inputQuan0() const {
    return GetPointer<const ace::QuantizedFloatParam *>(VT_INPUTQUAN0);
  }
  const ace::QuantizedFloatParam *inputQuan1() const {
    return GetPointer<const ace::QuantizedFloatParam *>(VT_INPUTQUAN1);
  }
  const ace::QuantizedFloatParam *outputQuan() const {
    return GetPointer<const ace::QuantizedFloatParam *>(VT_OUTPUTQUAN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_INPUTQUAN0) &&
           verifier.VerifyTable(inputQuan0()) &&
           VerifyOffset(verifier, VT_INPUTQUAN1) &&
           verifier.VerifyTable(inputQuan1()) &&
           VerifyOffset(verifier, VT_OUTPUTQUAN) &&
           verifier.VerifyTable(outputQuan()) &&
           verifier.EndTable();
  }
  EltwiseInt8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseInt8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EltwiseInt8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseInt8Builder {
  typedef EltwiseInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ace::EltwiseType type) {
    fbb_.AddElement<int8_t>(EltwiseInt8::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_inputQuan0(flatbuffers::Offset<ace::QuantizedFloatParam> inputQuan0) {
    fbb_.AddOffset(EltwiseInt8::VT_INPUTQUAN0, inputQuan0);
  }
  void add_inputQuan1(flatbuffers::Offset<ace::QuantizedFloatParam> inputQuan1) {
    fbb_.AddOffset(EltwiseInt8::VT_INPUTQUAN1, inputQuan1);
  }
  void add_outputQuan(flatbuffers::Offset<ace::QuantizedFloatParam> outputQuan) {
    fbb_.AddOffset(EltwiseInt8::VT_OUTPUTQUAN, outputQuan);
  }
  explicit EltwiseInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EltwiseInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EltwiseInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::EltwiseType type = ace::EltwiseType_PROD,
    flatbuffers::Offset<ace::QuantizedFloatParam> inputQuan0 = 0,
    flatbuffers::Offset<ace::QuantizedFloatParam> inputQuan1 = 0,
    flatbuffers::Offset<ace::QuantizedFloatParam> outputQuan = 0) {
  EltwiseInt8Builder builder_(_fbb);
  builder_.add_outputQuan(outputQuan);
  builder_.add_inputQuan1(inputQuan1);
  builder_.add_inputQuan0(inputQuan0);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumSumT : public flatbuffers::NativeTable {
  typedef CumSum TableType;
  bool exclusive = false;
  bool reverse = false;
};

struct CumSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CumSumT NativeTableType;
  typedef CumSumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CumSumTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE, 1) &&
           verifier.EndTable();
  }
  CumSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CumSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumSumBuilder {
  typedef CumSum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumSum::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumSum::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CumSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumSum> CreateCumSum(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumSumBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Convolution2DCommonT *Convolution2DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Convolution2DCommonT>(new Convolution2DCommonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Convolution2DCommon::UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; }
  { auto _e = padY(); _o->padY = _e; }
  { auto _e = kernelX(); _o->kernelX = _e; }
  { auto _e = kernelY(); _o->kernelY = _e; }
  { auto _e = strideX(); _o->strideX = _e; }
  { auto _e = strideY(); _o->strideY = _e; }
  { auto _e = dilateX(); _o->dilateX = _e; }
  { auto _e = dilateY(); _o->dilateY = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = inputCount(); _o->inputCount = _e; }
  { auto _e = relu(); _o->relu = _e; }
  { auto _e = relu6(); _o->relu6 = _e; }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = outPads(); if (_e) { _o->outPads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outPads[_i] = _e->Get(_i); } } }
  { auto _e = hasOutputShape(); _o->hasOutputShape = _e; }
}

inline flatbuffers::Offset<Convolution2DCommon> Convolution2DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _dilateX = _o->dilateX;
  auto _dilateY = _o->dilateY;
  auto _padMode = _o->padMode;
  auto _group = _o->group;
  auto _outputCount = _o->outputCount;
  auto _inputCount = _o->inputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _outPads = _o->outPads.size() ? _fbb.CreateVector(_o->outPads) : 0;
  auto _hasOutputShape = _o->hasOutputShape;
  return ace::CreateConvolution2DCommon(
      _fbb,
      _padX,
      _padY,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _dilateX,
      _dilateY,
      _padMode,
      _group,
      _outputCount,
      _inputCount,
      _relu,
      _relu6,
      _pads,
      _outPads,
      _hasOutputShape);
}

inline Convolution3DCommonT *Convolution3DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Convolution3DCommonT>(new Convolution3DCommonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Convolution3DCommon::UnPackTo(Convolution3DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dilates(); if (_e) { _o->dilates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilates[_i] = _e->Get(_i); } } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = inputCount(); _o->inputCount = _e; }
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = relu(); _o->relu = _e; }
  { auto _e = relu6(); _o->relu6 = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = outPads(); if (_e) { _o->outPads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outPads[_i] = _e->Get(_i); } } }
  { auto _e = hasOutputShape(); _o->hasOutputShape = _e; }
}

inline flatbuffers::Offset<Convolution3DCommon> Convolution3DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution3DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution3DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dilates = _o->dilates.size() ? _fbb.CreateVector(_o->dilates) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _padMode = _o->padMode;
  auto _inputCount = _o->inputCount;
  auto _outputCount = _o->outputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _group = _o->group;
  auto _outPads = _o->outPads.size() ? _fbb.CreateVector(_o->outPads) : 0;
  auto _hasOutputShape = _o->hasOutputShape;
  return ace::CreateConvolution3DCommon(
      _fbb,
      _dilates,
      _strides,
      _kernels,
      _pads,
      _padMode,
      _inputCount,
      _outputCount,
      _relu,
      _relu6,
      _group,
      _outPads,
      _hasOutputShape);
}

inline SparseCommonT::SparseCommonT(const SparseCommonT &o)
      : method(o.method) {
  args.reserve(o.args.size());
  for (const auto &args_ : o.args) { args.emplace_back((args_) ? new ace::AttributeT(*args_) : nullptr); }
}

inline SparseCommonT &SparseCommonT::operator=(SparseCommonT o) FLATBUFFERS_NOEXCEPT {
  std::swap(method, o.method);
  std::swap(args, o.args);
  return *this;
}

inline SparseCommonT *SparseCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparseCommonT>(new SparseCommonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseCommon::UnPackTo(SparseCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); _o->method = _e; }
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args[_i] = std::unique_ptr<ace::AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<SparseCommon> SparseCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseCommon> CreateSparseCommon(flatbuffers::FlatBufferBuilder &_fbb, const SparseCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method;
  auto _args = _o->args.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Attribute>> (_o->args.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->args[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateSparseCommon(
      _fbb,
      _method,
      _args);
}

inline IDSTQuanT *IDSTQuan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IDSTQuanT>(new IDSTQuanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IDSTQuan::UnPackTo(IDSTQuanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->buffer.begin()); } }
  { auto _e = alpha(); if (_e) { _o->alpha.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->alpha[_i] = _e->Get(_i); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = useInt32(); _o->useInt32 = _e; }
  { auto _e = quantScale(); _o->quantScale = _e; }
  { auto _e = scaleIn(); _o->scaleIn = _e; }
  { auto _e = scaleOut(); _o->scaleOut = _e; }
  { auto _e = aMax(); _o->aMax = _e; }
  { auto _e = aMin(); _o->aMin = _e; }
  { auto _e = readType(); _o->readType = _e; }
  { auto _e = has_scaleInt(); _o->has_scaleInt = _e; }
}

inline flatbuffers::Offset<IDSTQuan> IDSTQuan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIDSTQuan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(flatbuffers::FlatBufferBuilder &_fbb, const IDSTQuanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IDSTQuanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  auto _alpha = _o->alpha.size() ? _fbb.CreateVector(_o->alpha) : 0;
  auto _type = _o->type;
  auto _useInt32 = _o->useInt32;
  auto _quantScale = _o->quantScale;
  auto _scaleIn = _o->scaleIn;
  auto _scaleOut = _o->scaleOut;
  auto _aMax = _o->aMax;
  auto _aMin = _o->aMin;
  auto _readType = _o->readType;
  auto _has_scaleInt = _o->has_scaleInt;
  return ace::CreateIDSTQuan(
      _fbb,
      _buffer,
      _alpha,
      _type,
      _useInt32,
      _quantScale,
      _scaleIn,
      _scaleOut,
      _aMax,
      _aMin,
      _readType,
      _has_scaleInt);
}

inline QuantizedFloatParamT *QuantizedFloatParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantizedFloatParamT>(new QuantizedFloatParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantizedFloatParam::UnPackTo(QuantizedFloatParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->weight.begin()); } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
  { auto _e = tensorScale(); if (_e) { _o->tensorScale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorScale[_i] = _e->Get(_i); } } }
  { auto _e = method(); _o->method = _e; }
  { auto _e = nbits(); _o->nbits = _e; }
  { auto _e = zeroPoint(); _o->zeroPoint = _e; }
  { auto _e = outputZeroPoint(); _o->outputZeroPoint = _e; }
  { auto _e = clampMin(); _o->clampMin = _e; }
  { auto _e = clampMax(); _o->clampMax = _e; }
  { auto _e = winogradAttr(); if (_e) { _o->winogradAttr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->winogradAttr[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<QuantizedFloatParam> QuantizedFloatParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizedFloatParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantizedFloatParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizedFloatParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _tensorScale = _o->tensorScale.size() ? _fbb.CreateVector(_o->tensorScale) : 0;
  auto _method = _o->method;
  auto _nbits = _o->nbits;
  auto _zeroPoint = _o->zeroPoint;
  auto _outputZeroPoint = _o->outputZeroPoint;
  auto _clampMin = _o->clampMin;
  auto _clampMax = _o->clampMax;
  auto _winogradAttr = _o->winogradAttr.size() ? _fbb.CreateVector(_o->winogradAttr) : 0;
  return ace::CreateQuantizedFloatParam(
      _fbb,
      _weight,
      _bias,
      _scale,
      _tensorScale,
      _method,
      _nbits,
      _zeroPoint,
      _outputZeroPoint,
      _clampMin,
      _clampMax,
      _winogradAttr);
}

inline Convolution2DT::Convolution2DT(const Convolution2DT &o)
      : common((o.common) ? new ace::Convolution2DCommonT(*o.common) : nullptr),
        weight(o.weight),
        bias(o.bias),
        quanParameter((o.quanParameter) ? new ace::IDSTQuanT(*o.quanParameter) : nullptr),
        symmetricQuan((o.symmetricQuan) ? new ace::QuantizedFloatParamT(*o.symmetricQuan) : nullptr),
        sparseParameter((o.sparseParameter) ? new ace::SparseCommonT(*o.sparseParameter) : nullptr),
        external(o.external) {
}

inline Convolution2DT &Convolution2DT::operator=(Convolution2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(common, o.common);
  std::swap(weight, o.weight);
  std::swap(bias, o.bias);
  std::swap(quanParameter, o.quanParameter);
  std::swap(symmetricQuan, o.symmetricQuan);
  std::swap(sparseParameter, o.sparseParameter);
  std::swap(external, o.external);
  return *this;
}

inline Convolution2DT *Convolution2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Convolution2DT>(new Convolution2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Convolution2D::UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<ace::Convolution2DCommonT>(_e->UnPack(_resolver)); }
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = quanParameter(); if (_e) _o->quanParameter = std::unique_ptr<ace::IDSTQuanT>(_e->UnPack(_resolver)); }
  { auto _e = symmetricQuan(); if (_e) _o->symmetricQuan = std::unique_ptr<ace::QuantizedFloatParamT>(_e->UnPack(_resolver)); }
  { auto _e = sparseParameter(); if (_e) _o->sparseParameter = std::unique_ptr<ace::SparseCommonT>(_e->UnPack(_resolver)); }
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Convolution2D> Convolution2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution2DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _quanParameter = _o->quanParameter ? CreateIDSTQuan(_fbb, _o->quanParameter.get(), _rehasher) : 0;
  auto _symmetricQuan = _o->symmetricQuan ? CreateQuantizedFloatParam(_fbb, _o->symmetricQuan.get(), _rehasher) : 0;
  auto _sparseParameter = _o->sparseParameter ? CreateSparseCommon(_fbb, _o->sparseParameter.get(), _rehasher) : 0;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return ace::CreateConvolution2D(
      _fbb,
      _common,
      _weight,
      _bias,
      _quanParameter,
      _symmetricQuan,
      _sparseParameter,
      _external);
}

inline Convolution3DT::Convolution3DT(const Convolution3DT &o)
      : common((o.common) ? new ace::Convolution3DCommonT(*o.common) : nullptr),
        weight(o.weight),
        bias(o.bias),
        external(o.external) {
}

inline Convolution3DT &Convolution3DT::operator=(Convolution3DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(common, o.common);
  std::swap(weight, o.weight);
  std::swap(bias, o.bias);
  std::swap(external, o.external);
  return *this;
}

inline Convolution3DT *Convolution3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Convolution3DT>(new Convolution3DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Convolution3D::UnPackTo(Convolution3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<ace::Convolution3DCommonT>(_e->UnPack(_resolver)); }
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Convolution3D> Convolution3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution3D> CreateConvolution3D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution3DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return ace::CreateConvolution3D(
      _fbb,
      _common,
      _weight,
      _bias,
      _external);
}

inline InnerProductT::InnerProductT(const InnerProductT &o)
      : outputCount(o.outputCount),
        biasTerm(o.biasTerm),
        weightSize(o.weightSize),
        weight(o.weight),
        bias(o.bias),
        axis(o.axis),
        transpose(o.transpose),
        quanParameter((o.quanParameter) ? new ace::IDSTQuanT(*o.quanParameter) : nullptr) {
}

inline InnerProductT &InnerProductT::operator=(InnerProductT o) FLATBUFFERS_NOEXCEPT {
  std::swap(outputCount, o.outputCount);
  std::swap(biasTerm, o.biasTerm);
  std::swap(weightSize, o.weightSize);
  std::swap(weight, o.weight);
  std::swap(bias, o.bias);
  std::swap(axis, o.axis);
  std::swap(transpose, o.transpose);
  std::swap(quanParameter, o.quanParameter);
  return *this;
}

inline InnerProductT *InnerProduct::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InnerProductT>(new InnerProductT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InnerProduct::UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = biasTerm(); _o->biasTerm = _e; }
  { auto _e = weightSize(); _o->weightSize = _e; }
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = transpose(); _o->transpose = _e; }
  { auto _e = quanParameter(); if (_e) _o->quanParameter = std::unique_ptr<ace::IDSTQuanT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<InnerProduct> InnerProduct::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInnerProduct(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InnerProductT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _biasTerm = _o->biasTerm;
  auto _weightSize = _o->weightSize;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  auto _transpose = _o->transpose;
  auto _quanParameter = _o->quanParameter ? CreateIDSTQuan(_fbb, _o->quanParameter.get(), _rehasher) : 0;
  return ace::CreateInnerProduct(
      _fbb,
      _outputCount,
      _biasTerm,
      _weightSize,
      _weight,
      _bias,
      _axis,
      _transpose,
      _quanParameter);
}

inline PoolT *Pool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoolT>(new PoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool::UnPackTo(PoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; }
  { auto _e = padY(); _o->padY = _e; }
  { auto _e = isGlobal(); _o->isGlobal = _e; }
  { auto _e = kernelX(); _o->kernelX = _e; }
  { auto _e = kernelY(); _o->kernelY = _e; }
  { auto _e = strideX(); _o->strideX = _e; }
  { auto _e = strideY(); _o->strideY = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = padType(); _o->padType = _e; }
  { auto _e = dataType(); _o->dataType = _e; }
  { auto _e = ceilModel(); _o->ceilModel = _e; }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = countType(); _o->countType = _e; }
}

inline flatbuffers::Offset<Pool> Pool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool> CreatePool(flatbuffers::FlatBufferBuilder &_fbb, const PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _isGlobal = _o->isGlobal;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _type = _o->type;
  auto _padType = _o->padType;
  auto _dataType = _o->dataType;
  auto _ceilModel = _o->ceilModel;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _countType = _o->countType;
  return ace::CreatePool(
      _fbb,
      _padX,
      _padY,
      _isGlobal,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _type,
      _padType,
      _dataType,
      _ceilModel,
      _pads,
      _countType);
}

inline Pool3DT *Pool3D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pool3DT>(new Pool3DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool3D::UnPackTo(Pool3DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = padType(); _o->padType = _e; }
  { auto _e = isGlobal(); _o->isGlobal = _e; }
}

inline flatbuffers::Offset<Pool3D> Pool3D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool3D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool3D> CreatePool3D(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool3DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _type = _o->type;
  auto _padType = _o->padType;
  auto _isGlobal = _o->isGlobal;
  return ace::CreatePool3D(
      _fbb,
      _strides,
      _kernels,
      _pads,
      _type,
      _padType,
      _isGlobal);
}

inline ReluT *Relu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReluT>(new ReluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Relu::UnPackTo(ReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; }
}

inline flatbuffers::Offset<Relu> Relu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu> CreateRelu(flatbuffers::FlatBufferBuilder &_fbb, const ReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return ace::CreateRelu(
      _fbb,
      _slope);
}

inline Relu6T *Relu6::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Relu6T>(new Relu6T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Relu6::UnPackTo(Relu6T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minValue(); _o->minValue = _e; }
  { auto _e = maxValue(); _o->maxValue = _e; }
}

inline flatbuffers::Offset<Relu6> Relu6::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu6(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu6> CreateRelu6(flatbuffers::FlatBufferBuilder &_fbb, const Relu6T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Relu6T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minValue = _o->minValue;
  auto _maxValue = _o->maxValue;
  return ace::CreateRelu6(
      _fbb,
      _minValue,
      _maxValue);
}

inline PReluT *PRelu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PReluT>(new PReluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PRelu::UnPackTo(PReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slopeCount(); _o->slopeCount = _e; }
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PRelu> PRelu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PRelu> CreatePRelu(flatbuffers::FlatBufferBuilder &_fbb, const PReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slopeCount = _o->slopeCount;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return ace::CreatePRelu(
      _fbb,
      _slopeCount,
      _slope);
}

inline ELUT *ELU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ELUT>(new ELUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ELU::UnPackTo(ELUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<ELU> ELU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ELUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateELU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ELU> CreateELU(flatbuffers::FlatBufferBuilder &_fbb, const ELUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ELUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return ace::CreateELU(
      _fbb,
      _alpha);
}

inline LRNT *LRN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LRNT>(new LRNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LRN::UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regionType(); _o->regionType = _e; }
  { auto _e = localSize(); _o->localSize = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
  { auto _e = bias(); _o->bias = _e; }
}

inline flatbuffers::Offset<LRN> LRN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regionType = _o->regionType;
  auto _localSize = _o->localSize;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  auto _bias = _o->bias;
  return ace::CreateLRN(
      _fbb,
      _regionType,
      _localSize,
      _alpha,
      _beta,
      _bias);
}

inline ArgMaxT *ArgMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMaxT>(new ArgMaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMax::UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outMaxVal(); _o->outMaxVal = _e; }
  { auto _e = topK(); _o->topK = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = softmaxThreshold(); _o->softmaxThreshold = _e; }
}

inline flatbuffers::Offset<ArgMax> ArgMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outMaxVal = _o->outMaxVal;
  auto _topK = _o->topK;
  auto _axis = _o->axis;
  auto _softmaxThreshold = _o->softmaxThreshold;
  return ace::CreateArgMax(
      _fbb,
      _outMaxVal,
      _topK,
      _axis,
      _softmaxThreshold);
}

inline AxisT *Axis::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AxisT>(new AxisT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Axis::UnPackTo(AxisT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Axis> Axis::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAxis(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Axis> CreateAxis(flatbuffers::FlatBufferBuilder &_fbb, const AxisT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AxisT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return ace::CreateAxis(
      _fbb,
      _axis);
}

inline InputT *Input::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputT>(new InputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Input::UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
  { auto _e = dtype(); _o->dtype = _e; }
  { auto _e = dformat(); _o->dformat = _e; }
}

inline flatbuffers::Offset<Input> Input::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dtype = _o->dtype;
  auto _dformat = _o->dformat;
  return ace::CreateInput(
      _fbb,
      _dims,
      _dtype,
      _dformat);
}

inline LSTMT::LSTMT(const LSTMT &o)
      : outputCount(o.outputCount),
        weightSize(o.weightSize),
        clippingThreshold(o.clippingThreshold),
        weightI((o.weightI) ? new ace::BlobT(*o.weightI) : nullptr),
        weightH((o.weightH) ? new ace::BlobT(*o.weightH) : nullptr),
        bias((o.bias) ? new ace::BlobT(*o.bias) : nullptr),
        weightIQ((o.weightIQ) ? new ace::BlobT(*o.weightIQ) : nullptr),
        weightIA((o.weightIA) ? new ace::BlobT(*o.weightIA) : nullptr),
        quantScale(o.quantScale) {
}

inline LSTMT &LSTMT::operator=(LSTMT o) FLATBUFFERS_NOEXCEPT {
  std::swap(outputCount, o.outputCount);
  std::swap(weightSize, o.weightSize);
  std::swap(clippingThreshold, o.clippingThreshold);
  std::swap(weightI, o.weightI);
  std::swap(weightH, o.weightH);
  std::swap(bias, o.bias);
  std::swap(weightIQ, o.weightIQ);
  std::swap(weightIA, o.weightIA);
  std::swap(quantScale, o.quantScale);
  return *this;
}

inline LSTMT *LSTM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LSTMT>(new LSTMT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSTM::UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = weightSize(); _o->weightSize = _e; }
  { auto _e = clippingThreshold(); _o->clippingThreshold = _e; }
  { auto _e = weightI(); if (_e) _o->weightI = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = weightH(); if (_e) _o->weightH = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = weightIQ(); if (_e) _o->weightIQ = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = weightIA(); if (_e) _o->weightIA = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = quantScale(); _o->quantScale = _e; }
}

inline flatbuffers::Offset<LSTM> LSTM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _weightSize = _o->weightSize;
  auto _clippingThreshold = _o->clippingThreshold;
  auto _weightI = _o->weightI ? CreateBlob(_fbb, _o->weightI.get(), _rehasher) : 0;
  auto _weightH = _o->weightH ? CreateBlob(_fbb, _o->weightH.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateBlob(_fbb, _o->bias.get(), _rehasher) : 0;
  auto _weightIQ = _o->weightIQ ? CreateBlob(_fbb, _o->weightIQ.get(), _rehasher) : 0;
  auto _weightIA = _o->weightIA ? CreateBlob(_fbb, _o->weightIA.get(), _rehasher) : 0;
  auto _quantScale = _o->quantScale;
  return ace::CreateLSTM(
      _fbb,
      _outputCount,
      _weightSize,
      _clippingThreshold,
      _weightI,
      _weightH,
      _bias,
      _weightIQ,
      _weightIA,
      _quantScale);
}

inline SliceT *Slice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SliceT>(new SliceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Slice::UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = slicePoints(); if (_e) { _o->slicePoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slicePoints[_i] = _e->Get(_i); } } }
  { auto _e = sourceType(); _o->sourceType = _e; }
}

inline flatbuffers::Offset<Slice> Slice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSlice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _slicePoints = _o->slicePoints.size() ? _fbb.CreateVector(_o->slicePoints) : 0;
  auto _sourceType = _o->sourceType;
  return ace::CreateSlice(
      _fbb,
      _axis,
      _slicePoints,
      _sourceType);
}

inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormT>(new BatchNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; }
  { auto _e = slopeData(); if (_e) { _o->slopeData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slopeData[_i] = _e->Get(_i); } } }
  { auto _e = meanData(); if (_e) { _o->meanData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meanData[_i] = _e->Get(_i); } } }
  { auto _e = varData(); if (_e) { _o->varData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->varData[_i] = _e->Get(_i); } } }
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } }
  { auto _e = Adata(); if (_e) { _o->Adata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Adata[_i] = _e->Get(_i); } } }
  { auto _e = Bdata(); if (_e) { _o->Bdata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Bdata[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _slopeData = _o->slopeData.size() ? _fbb.CreateVector(_o->slopeData) : 0;
  auto _meanData = _o->meanData.size() ? _fbb.CreateVector(_o->meanData) : 0;
  auto _varData = _o->varData.size() ? _fbb.CreateVector(_o->varData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _Adata = _o->Adata.size() ? _fbb.CreateVector(_o->Adata) : 0;
  auto _Bdata = _o->Bdata.size() ? _fbb.CreateVector(_o->Bdata) : 0;
  auto _epsilon = _o->epsilon;
  return ace::CreateBatchNorm(
      _fbb,
      _channels,
      _slopeData,
      _meanData,
      _varData,
      _biasData,
      _Adata,
      _Bdata,
      _epsilon);
}

inline ScaleT *Scale::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScaleT>(new ScaleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Scale::UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; }
  { auto _e = scaleData(); if (_e) { _o->scaleData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scaleData[_i] = _e->Get(_i); } } }
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } }
  { auto _e = external(); if (_e) { _o->external.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->external[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Scale> Scale::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScale(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _scaleData = _o->scaleData.size() ? _fbb.CreateVector(_o->scaleData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _external = _o->external.size() ? _fbb.CreateVector(_o->external) : 0;
  return ace::CreateScale(
      _fbb,
      _channels,
      _scaleData,
      _biasData,
      _external);
}

inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EltwiseT>(new EltwiseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = coeff(); if (_e) { _o->coeff.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->coeff[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwise(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _coeff = _o->coeff.size() ? _fbb.CreateVector(_o->coeff) : 0;
  return ace::CreateEltwise(
      _fbb,
      _type,
      _coeff);
}

inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenT>(new FlattenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = endAxis(); _o->endAxis = _e; }
}

inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatten(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _endAxis = _o->endAxis;
  return ace::CreateFlatten(
      _fbb,
      _axis,
      _endAxis);
}

inline PermuteT *Permute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PermuteT>(new PermuteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Permute::UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Permute> Permute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return ace::CreatePermute(
      _fbb,
      _dims);
}

inline ReshapeT *Reshape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReshapeT>(new ReshapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reshape::UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
  { auto _e = dimType(); _o->dimType = _e; }
}

inline flatbuffers::Offset<Reshape> Reshape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dimType = _o->dimType;
  return ace::CreateReshape(
      _fbb,
      _dims,
      _dimType);
}

inline DetectionOutputT *DetectionOutput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectionOutputT>(new DetectionOutputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectionOutput::UnPackTo(DetectionOutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = classCount(); _o->classCount = _e; }
  { auto _e = nmsThresholdold(); _o->nmsThresholdold = _e; }
  { auto _e = nmsTopK(); _o->nmsTopK = _e; }
  { auto _e = keepTopK(); _o->keepTopK = _e; }
  { auto _e = confidenceThreshold(); _o->confidenceThreshold = _e; }
  { auto _e = shareLocation(); _o->shareLocation = _e; }
  { auto _e = backgroundLable(); _o->backgroundLable = _e; }
  { auto _e = varianceEncodedTarget(); _o->varianceEncodedTarget = _e; }
  { auto _e = codeType(); _o->codeType = _e; }
  { auto _e = objectnessScore(); _o->objectnessScore = _e; }
}

inline flatbuffers::Offset<DetectionOutput> DetectionOutput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionOutput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionOutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _classCount = _o->classCount;
  auto _nmsThresholdold = _o->nmsThresholdold;
  auto _nmsTopK = _o->nmsTopK;
  auto _keepTopK = _o->keepTopK;
  auto _confidenceThreshold = _o->confidenceThreshold;
  auto _shareLocation = _o->shareLocation;
  auto _backgroundLable = _o->backgroundLable;
  auto _varianceEncodedTarget = _o->varianceEncodedTarget;
  auto _codeType = _o->codeType;
  auto _objectnessScore = _o->objectnessScore;
  return ace::CreateDetectionOutput(
      _fbb,
      _classCount,
      _nmsThresholdold,
      _nmsTopK,
      _keepTopK,
      _confidenceThreshold,
      _shareLocation,
      _backgroundLable,
      _varianceEncodedTarget,
      _codeType,
      _objectnessScore);
}

inline RoiParametersT *RoiParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoiParametersT>(new RoiParametersT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoiParameters::UnPackTo(RoiParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooledWidth(); _o->pooledWidth = _e; }
  { auto _e = pooledHeight(); _o->pooledHeight = _e; }
  { auto _e = spatialScale(); _o->spatialScale = _e; }
  { auto _e = samplingRatio(); _o->samplingRatio = _e; }
  { auto _e = aligned(); _o->aligned = _e; }
  { auto _e = poolType(); _o->poolType = _e; }
}

inline flatbuffers::Offset<RoiParameters> RoiParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoiParameters(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoiParameters> CreateRoiParameters(flatbuffers::FlatBufferBuilder &_fbb, const RoiParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoiParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooledWidth = _o->pooledWidth;
  auto _pooledHeight = _o->pooledHeight;
  auto _spatialScale = _o->spatialScale;
  auto _samplingRatio = _o->samplingRatio;
  auto _aligned = _o->aligned;
  auto _poolType = _o->poolType;
  return ace::CreateRoiParameters(
      _fbb,
      _pooledWidth,
      _pooledHeight,
      _spatialScale,
      _samplingRatio,
      _aligned,
      _poolType);
}

inline ProposalT::ProposalT(const ProposalT &o)
      : featStride(o.featStride),
        baseSize(o.baseSize),
        preNmsTopN(o.preNmsTopN),
        afterNmsTopN(o.afterNmsTopN),
        nmsThreshold(o.nmsThreshold),
        minSize(o.minSize),
        ratios((o.ratios) ? new ace::BlobT(*o.ratios) : nullptr),
        scales((o.scales) ? new ace::BlobT(*o.scales) : nullptr),
        anchors((o.anchors) ? new ace::BlobT(*o.anchors) : nullptr) {
}

inline ProposalT &ProposalT::operator=(ProposalT o) FLATBUFFERS_NOEXCEPT {
  std::swap(featStride, o.featStride);
  std::swap(baseSize, o.baseSize);
  std::swap(preNmsTopN, o.preNmsTopN);
  std::swap(afterNmsTopN, o.afterNmsTopN);
  std::swap(nmsThreshold, o.nmsThreshold);
  std::swap(minSize, o.minSize);
  std::swap(ratios, o.ratios);
  std::swap(scales, o.scales);
  std::swap(anchors, o.anchors);
  return *this;
}

inline ProposalT *Proposal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProposalT>(new ProposalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Proposal::UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = featStride(); _o->featStride = _e; }
  { auto _e = baseSize(); _o->baseSize = _e; }
  { auto _e = preNmsTopN(); _o->preNmsTopN = _e; }
  { auto _e = afterNmsTopN(); _o->afterNmsTopN = _e; }
  { auto _e = nmsThreshold(); _o->nmsThreshold = _e; }
  { auto _e = minSize(); _o->minSize = _e; }
  { auto _e = ratios(); if (_e) _o->ratios = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = scales(); if (_e) _o->scales = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
  { auto _e = anchors(); if (_e) _o->anchors = std::unique_ptr<ace::BlobT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Proposal> Proposal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _featStride = _o->featStride;
  auto _baseSize = _o->baseSize;
  auto _preNmsTopN = _o->preNmsTopN;
  auto _afterNmsTopN = _o->afterNmsTopN;
  auto _nmsThreshold = _o->nmsThreshold;
  auto _minSize = _o->minSize;
  auto _ratios = _o->ratios ? CreateBlob(_fbb, _o->ratios.get(), _rehasher) : 0;
  auto _scales = _o->scales ? CreateBlob(_fbb, _o->scales.get(), _rehasher) : 0;
  auto _anchors = _o->anchors ? CreateBlob(_fbb, _o->anchors.get(), _rehasher) : 0;
  return ace::CreateProposal(
      _fbb,
      _featStride,
      _baseSize,
      _preNmsTopN,
      _afterNmsTopN,
      _nmsThreshold,
      _minSize,
      _ratios,
      _scales,
      _anchors);
}

inline InterpT *Interp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InterpT>(new InterpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Interp::UnPackTo(InterpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = widthScale(); _o->widthScale = _e; }
  { auto _e = heightScale(); _o->heightScale = _e; }
  { auto _e = outputWidth(); _o->outputWidth = _e; }
  { auto _e = outputHeight(); _o->outputHeight = _e; }
  { auto _e = resizeType(); _o->resizeType = _e; }
  { auto _e = alignCorners(); _o->alignCorners = _e; }
  { auto _e = halfPixelCenters(); _o->halfPixelCenters = _e; }
  { auto _e = widthOffset(); _o->widthOffset = _e; }
  { auto _e = heightOffset(); _o->heightOffset = _e; }
  { auto _e = cubicCoeffA(); _o->cubicCoeffA = _e; }
  { auto _e = ctm(); _o->ctm = _e; }
  { auto _e = depthScale(); _o->depthScale = _e; }
  { auto _e = outputDepth(); _o->outputDepth = _e; }
  { auto _e = depthOffset(); _o->depthOffset = _e; }
}

inline flatbuffers::Offset<Interp> Interp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInterp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Interp> CreateInterp(flatbuffers::FlatBufferBuilder &_fbb, const InterpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InterpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _widthScale = _o->widthScale;
  auto _heightScale = _o->heightScale;
  auto _outputWidth = _o->outputWidth;
  auto _outputHeight = _o->outputHeight;
  auto _resizeType = _o->resizeType;
  auto _alignCorners = _o->alignCorners;
  auto _halfPixelCenters = _o->halfPixelCenters;
  auto _widthOffset = _o->widthOffset;
  auto _heightOffset = _o->heightOffset;
  auto _cubicCoeffA = _o->cubicCoeffA;
  auto _ctm = _o->ctm;
  auto _depthScale = _o->depthScale;
  auto _outputDepth = _o->outputDepth;
  auto _depthOffset = _o->depthOffset;
  return ace::CreateInterp(
      _fbb,
      _widthScale,
      _heightScale,
      _outputWidth,
      _outputHeight,
      _resizeType,
      _alignCorners,
      _halfPixelCenters,
      _widthOffset,
      _heightOffset,
      _cubicCoeffA,
      _ctm,
      _depthScale,
      _outputDepth,
      _depthOffset);
}

inline ResizeT *Resize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeT>(new ResizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Resize::UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = xScale(); _o->xScale = _e; }
  { auto _e = yScale(); _o->yScale = _e; }
}

inline flatbuffers::Offset<Resize> Resize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _xScale = _o->xScale;
  auto _yScale = _o->yScale;
  return ace::CreateResize(
      _fbb,
      _xScale,
      _yScale);
}

inline PriorBoxT *PriorBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriorBoxT>(new PriorBoxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriorBox::UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minSizes(); if (_e) { _o->minSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->minSizes[_i] = _e->Get(_i); } } }
  { auto _e = maxSizes(); if (_e) { _o->maxSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->maxSizes[_i] = _e->Get(_i); } } }
  { auto _e = aspectRatios(); if (_e) { _o->aspectRatios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspectRatios[_i] = _e->Get(_i); } } }
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } }
  { auto _e = flip(); _o->flip = _e; }
  { auto _e = clip(); _o->clip = _e; }
  { auto _e = imageWidth(); _o->imageWidth = _e; }
  { auto _e = imageHeight(); _o->imageHeight = _e; }
  { auto _e = stepWidth(); _o->stepWidth = _e; }
  { auto _e = stepHeight(); _o->stepHeight = _e; }
  { auto _e = offset(); _o->offset = _e; }
}

inline flatbuffers::Offset<PriorBox> PriorBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBox(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minSizes = _o->minSizes.size() ? _fbb.CreateVector(_o->minSizes) : 0;
  auto _maxSizes = _o->maxSizes.size() ? _fbb.CreateVector(_o->maxSizes) : 0;
  auto _aspectRatios = _o->aspectRatios.size() ? _fbb.CreateVector(_o->aspectRatios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _flip = _o->flip;
  auto _clip = _o->clip;
  auto _imageWidth = _o->imageWidth;
  auto _imageHeight = _o->imageHeight;
  auto _stepWidth = _o->stepWidth;
  auto _stepHeight = _o->stepHeight;
  auto _offset = _o->offset;
  return ace::CreatePriorBox(
      _fbb,
      _minSizes,
      _maxSizes,
      _aspectRatios,
      _variances,
      _flip,
      _clip,
      _imageWidth,
      _imageHeight,
      _stepWidth,
      _stepHeight,
      _offset);
}

inline NormalizeT *Normalize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NormalizeT>(new NormalizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Normalize::UnPackTo(NormalizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acrossSpatial(); _o->acrossSpatial = _e; }
  { auto _e = channelShared(); _o->channelShared = _e; }
  { auto _e = eps(); _o->eps = _e; }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Normalize> Normalize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Normalize> CreateNormalize(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _acrossSpatial = _o->acrossSpatial;
  auto _channelShared = _o->channelShared;
  auto _eps = _o->eps;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  return ace::CreateNormalize(
      _fbb,
      _acrossSpatial,
      _channelShared,
      _eps,
      _scale);
}

inline EltwiseInt8T::EltwiseInt8T(const EltwiseInt8T &o)
      : type(o.type),
        inputQuan0((o.inputQuan0) ? new ace::QuantizedFloatParamT(*o.inputQuan0) : nullptr),
        inputQuan1((o.inputQuan1) ? new ace::QuantizedFloatParamT(*o.inputQuan1) : nullptr),
        outputQuan((o.outputQuan) ? new ace::QuantizedFloatParamT(*o.outputQuan) : nullptr) {
}

inline EltwiseInt8T &EltwiseInt8T::operator=(EltwiseInt8T o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(inputQuan0, o.inputQuan0);
  std::swap(inputQuan1, o.inputQuan1);
  std::swap(outputQuan, o.outputQuan);
  return *this;
}

inline EltwiseInt8T *EltwiseInt8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EltwiseInt8T>(new EltwiseInt8T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EltwiseInt8::UnPackTo(EltwiseInt8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = inputQuan0(); if (_e) _o->inputQuan0 = std::unique_ptr<ace::QuantizedFloatParamT>(_e->UnPack(_resolver)); }
  { auto _e = inputQuan1(); if (_e) _o->inputQuan1 = std::unique_ptr<ace::QuantizedFloatParamT>(_e->UnPack(_resolver)); }
  { auto _e = outputQuan(); if (_e) _o->outputQuan = std::unique_ptr<ace::QuantizedFloatParamT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<EltwiseInt8> EltwiseInt8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwiseInt8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseInt8T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _inputQuan0 = _o->inputQuan0 ? CreateQuantizedFloatParam(_fbb, _o->inputQuan0.get(), _rehasher) : 0;
  auto _inputQuan1 = _o->inputQuan1 ? CreateQuantizedFloatParam(_fbb, _o->inputQuan1.get(), _rehasher) : 0;
  auto _outputQuan = _o->outputQuan ? CreateQuantizedFloatParam(_fbb, _o->outputQuan.get(), _rehasher) : 0;
  return ace::CreateEltwiseInt8(
      _fbb,
      _type,
      _inputQuan0,
      _inputQuan1,
      _outputQuan);
}

inline CumSumT *CumSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CumSumT>(new CumSumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CumSum::UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exclusive(); _o->exclusive = _e; }
  { auto _e = reverse(); _o->reverse = _e; }
}

inline flatbuffers::Offset<CumSum> CumSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCumSum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return ace::CreateCumSum(
      _fbb,
      _exclusive,
      _reverse);
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseAlgoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::SparseAlgoTypeTable
  };
  static const char * const names[] = {
    "RANDOM",
    "SIMD_OC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizeAlgoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::QuantizeAlgoTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "OVERFLOW_AWARE",
    "WINOGRAD_AWARE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolPadTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AvgPoolCountTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::AvgPoolCountTypeTypeTable
  };
  static const char * const names[] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CoordinateTransformationModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::CoordinateTransformationModeTypeTable
  };
  static const char * const names[] = {
    "NotSet",
    "AlignCorners",
    "HalfPixels",
    "PytorchHalfPixels",
    "Asymmetric",
    "TensorflowHalfPixels",
    "TensorflowCropAndResize"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PadModeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "dilateX",
    "dilateY",
    "padMode",
    "group",
    "outputCount",
    "inputCount",
    "relu",
    "relu6",
    "pads",
    "outPads",
    "hasOutputShape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution3DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PadModeTypeTable
  };
  static const char * const names[] = {
    "dilates",
    "strides",
    "kernels",
    "pads",
    "padMode",
    "inputCount",
    "outputCount",
    "relu",
    "relu6",
    "group",
    "outPads",
    "hasOutputShape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::SparseAlgoTypeTable,
    ace::AttributeTypeTable
  };
  static const char * const names[] = {
    "method",
    "args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IDSTQuanTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "buffer",
    "alpha",
    "type",
    "useInt32",
    "quantScale",
    "scaleIn",
    "scaleOut",
    "aMax",
    "aMin",
    "readType",
    "has_scaleInt"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizedFloatParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::QuantizeAlgoTypeTable
  };
  static const char * const names[] = {
    "weight",
    "bias",
    "scale",
    "tensorScale",
    "method",
    "nbits",
    "zeroPoint",
    "outputZeroPoint",
    "clampMin",
    "clampMax",
    "winogradAttr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::Convolution2DCommonTypeTable,
    ace::IDSTQuanTypeTable,
    ace::QuantizedFloatParamTypeTable,
    ace::SparseCommonTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias",
    "quanParameter",
    "symmetricQuan",
    "sparseParameter",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution3DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::Convolution3DCommonTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InnerProductTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::IDSTQuanTypeTable
  };
  static const char * const names[] = {
    "outputCount",
    "biasTerm",
    "weightSize",
    "weight",
    "bias",
    "axis",
    "transpose",
    "quanParameter"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, 2 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolTypeTypeTable,
    ace::PoolPadTypeTypeTable,
    ace::DataTypeTypeTable,
    ace::AvgPoolCountTypeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "isGlobal",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "type",
    "padType",
    "dataType",
    "ceilModel",
    "pads",
    "countType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool3DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolTypeTypeTable,
    ace::PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "strides",
    "kernels",
    "pads",
    "type",
    "padType",
    "isGlobal"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Relu6TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minValue",
    "maxValue"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "slopeCount",
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ELUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "regionType",
    "localSize",
    "alpha",
    "beta",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outMaxVal",
    "topK",
    "axis",
    "softmaxThreshold"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AxisTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DataTypeTypeTable,
    ace::DataFormatTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dtype",
    "dformat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::BlobTypeTable
  };
  static const char * const names[] = {
    "outputCount",
    "weightSize",
    "clippingThreshold",
    "weightI",
    "weightH",
    "bias",
    "weightIQ",
    "weightIA",
    "quantScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::NetSourceTypeTable
  };
  static const char * const names[] = {
    "axis",
    "slicePoints",
    "sourceType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "channels",
    "slopeData",
    "meanData",
    "varData",
    "biasData",
    "Adata",
    "Bdata",
    "epsilon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const char * const names[] = {
    "channels",
    "scaleData",
    "biasData",
    "external"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::EltwiseTypeTypeTable
  };
  static const char * const names[] = {
    "type",
    "coeff"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "endAxis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PermuteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DataFormatTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dimType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionOutputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "classCount",
    "nmsThresholdold",
    "nmsTopK",
    "keepTopK",
    "confidenceThreshold",
    "shareLocation",
    "backgroundLable",
    "varianceEncodedTarget",
    "codeType",
    "objectnessScore"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoiParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolTypeTypeTable
  };
  static const char * const names[] = {
    "pooledWidth",
    "pooledHeight",
    "spatialScale",
    "samplingRatio",
    "aligned",
    "poolType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProposalTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::BlobTypeTable
  };
  static const char * const names[] = {
    "featStride",
    "baseSize",
    "preNmsTopN",
    "afterNmsTopN",
    "nmsThreshold",
    "minSize",
    "ratios",
    "scales",
    "anchors"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InterpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::CoordinateTransformationModeTypeTable
  };
  static const char * const names[] = {
    "widthScale",
    "heightScale",
    "outputWidth",
    "outputHeight",
    "resizeType",
    "alignCorners",
    "halfPixelCenters",
    "widthOffset",
    "heightOffset",
    "cubicCoeffA",
    "ctm",
    "depthScale",
    "outputDepth",
    "depthOffset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "xScale",
    "yScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minSizes",
    "maxSizes",
    "aspectRatios",
    "variances",
    "flip",
    "clip",
    "imageWidth",
    "imageHeight",
    "stepWidth",
    "stepHeight",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NormalizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "acrossSpatial",
    "channelShared",
    "eps",
    "scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseInt8TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::EltwiseTypeTypeTable,
    ace::QuantizedFloatParamTypeTable
  };
  static const char * const names[] = {
    "type",
    "inputQuan0",
    "inputQuan1",
    "outputQuan"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CumSumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "exclusive",
    "reverse"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace ace

#endif  // FLATBUFFERS_GENERATED_CAFFEOP_ACE_H_
