// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_USERDEFINE_ACE_H_
#define FLATBUFFERS_GENERATED_USERDEFINE_ACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "tensor_generated.h"

namespace ace {

struct TensorConvertInfo;
struct TensorConvertInfoBuilder;
struct TensorConvertInfoT;

struct GridSample;
struct GridSampleBuilder;
struct GridSampleT;

struct ImageProcessParam;
struct ImageProcessParamBuilder;
struct ImageProcessParamT;

inline const flatbuffers::TypeTable *TensorConvertInfoTypeTable();

inline const flatbuffers::TypeTable *GridSampleTypeTable();

inline const flatbuffers::TypeTable *ImageProcessParamTypeTable();

enum SampleMode : int8_t {
  SampleMode_BILINEAR = 0,
  SampleMode_NEAREST = 1,
  SampleMode_MIN = SampleMode_BILINEAR,
  SampleMode_MAX = SampleMode_NEAREST
};

inline const SampleMode (&EnumValuesSampleMode())[2] {
  static const SampleMode values[] = {
    SampleMode_BILINEAR,
    SampleMode_NEAREST
  };
  return values;
}

inline const char * const *EnumNamesSampleMode() {
  static const char * const names[3] = {
    "BILINEAR",
    "NEAREST",
    nullptr
  };
  return names;
}

inline const char *EnumNameSampleMode(SampleMode e) {
  if (flatbuffers::IsOutRange(e, SampleMode_BILINEAR, SampleMode_NEAREST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSampleMode()[index];
}

enum BorderMode : int8_t {
  BorderMode_ZEROS = 0,
  BorderMode_CLAMP = 1,
  BorderMode_REFLECTION = 2,
  BorderMode_MIN = BorderMode_ZEROS,
  BorderMode_MAX = BorderMode_REFLECTION
};

inline const BorderMode (&EnumValuesBorderMode())[3] {
  static const BorderMode values[] = {
    BorderMode_ZEROS,
    BorderMode_CLAMP,
    BorderMode_REFLECTION
  };
  return values;
}

inline const char * const *EnumNamesBorderMode() {
  static const char * const names[4] = {
    "ZEROS",
    "CLAMP",
    "REFLECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameBorderMode(BorderMode e) {
  if (flatbuffers::IsOutRange(e, BorderMode_ZEROS, BorderMode_REFLECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBorderMode()[index];
}

enum ImageFormatType : int32_t {
  ImageFormatType_RGBA = 0,
  ImageFormatType_RGB = 1,
  ImageFormatType_BGR = 2,
  ImageFormatType_GRAY = 3,
  ImageFormatType_BGRA = 4,
  ImageFormatType_YCrCb = 5,
  ImageFormatType_YUV = 6,
  ImageFormatType_HSV = 7,
  ImageFormatType_XYZ = 8,
  ImageFormatType_BGR555 = 9,
  ImageFormatType_BGR565 = 10,
  ImageFormatType_YUV_NV21 = 11,
  ImageFormatType_YUV_NV12 = 12,
  ImageFormatType_YUV_I420 = 13,
  ImageFormatType_HSV_FULL = 14,
  ImageFormatType_MIN = ImageFormatType_RGBA,
  ImageFormatType_MAX = ImageFormatType_HSV_FULL
};

inline const ImageFormatType (&EnumValuesImageFormatType())[15] {
  static const ImageFormatType values[] = {
    ImageFormatType_RGBA,
    ImageFormatType_RGB,
    ImageFormatType_BGR,
    ImageFormatType_GRAY,
    ImageFormatType_BGRA,
    ImageFormatType_YCrCb,
    ImageFormatType_YUV,
    ImageFormatType_HSV,
    ImageFormatType_XYZ,
    ImageFormatType_BGR555,
    ImageFormatType_BGR565,
    ImageFormatType_YUV_NV21,
    ImageFormatType_YUV_NV12,
    ImageFormatType_YUV_I420,
    ImageFormatType_HSV_FULL
  };
  return values;
}

inline const char * const *EnumNamesImageFormatType() {
  static const char * const names[16] = {
    "RGBA",
    "RGB",
    "BGR",
    "GRAY",
    "BGRA",
    "YCrCb",
    "YUV",
    "HSV",
    "XYZ",
    "BGR555",
    "BGR565",
    "YUV_NV21",
    "YUV_NV12",
    "YUV_I420",
    "HSV_FULL",
    nullptr
  };
  return names;
}

inline const char *EnumNameImageFormatType(ImageFormatType e) {
  if (flatbuffers::IsOutRange(e, ImageFormatType_RGBA, ImageFormatType_HSV_FULL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImageFormatType()[index];
}

enum FilterType : int8_t {
  FilterType_NEAREST = 0,
  FilterType_BILINEAR = 1,
  FilterType_BICUBIC = 2,
  FilterType_MIN = FilterType_NEAREST,
  FilterType_MAX = FilterType_BICUBIC
};

inline const FilterType (&EnumValuesFilterType())[3] {
  static const FilterType values[] = {
    FilterType_NEAREST,
    FilterType_BILINEAR,
    FilterType_BICUBIC
  };
  return values;
}

inline const char * const *EnumNamesFilterType() {
  static const char * const names[4] = {
    "NEAREST",
    "BILINEAR",
    "BICUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilterType(FilterType e) {
  if (flatbuffers::IsOutRange(e, FilterType_NEAREST, FilterType_BICUBIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilterType()[index];
}

enum WrapType : int8_t {
  WrapType_CLAMP_TO_EDGE = 0,
  WrapType_ZERO = 1,
  WrapType_REPEAT = 2,
  WrapType_MIN = WrapType_CLAMP_TO_EDGE,
  WrapType_MAX = WrapType_REPEAT
};

inline const WrapType (&EnumValuesWrapType())[3] {
  static const WrapType values[] = {
    WrapType_CLAMP_TO_EDGE,
    WrapType_ZERO,
    WrapType_REPEAT
  };
  return values;
}

inline const char * const *EnumNamesWrapType() {
  static const char * const names[4] = {
    "CLAMP_TO_EDGE",
    "ZERO",
    "REPEAT",
    nullptr
  };
  return names;
}

inline const char *EnumNameWrapType(WrapType e) {
  if (flatbuffers::IsOutRange(e, WrapType_CLAMP_TO_EDGE, WrapType_REPEAT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWrapType()[index];
}

struct TensorConvertInfoT : public flatbuffers::NativeTable {
  typedef TensorConvertInfo TableType;
  ace::DataFormat source = ace::DataFormat_NCHW;
  ace::DataFormat dest = ace::DataFormat_NCHW;
};

struct TensorConvertInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorConvertInfoT NativeTableType;
  typedef TensorConvertInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorConvertInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DEST = 6
  };
  ace::DataFormat source() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_SOURCE, 0));
  }
  ace::DataFormat dest() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_DEST, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SOURCE, 1) &&
           VerifyField<int8_t>(verifier, VT_DEST, 1) &&
           verifier.EndTable();
  }
  TensorConvertInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorConvertInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorConvertInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorConvertInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorConvertInfoBuilder {
  typedef TensorConvertInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source(ace::DataFormat source) {
    fbb_.AddElement<int8_t>(TensorConvertInfo::VT_SOURCE, static_cast<int8_t>(source), 0);
  }
  void add_dest(ace::DataFormat dest) {
    fbb_.AddElement<int8_t>(TensorConvertInfo::VT_DEST, static_cast<int8_t>(dest), 0);
  }
  explicit TensorConvertInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorConvertInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorConvertInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorConvertInfo> CreateTensorConvertInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::DataFormat source = ace::DataFormat_NCHW,
    ace::DataFormat dest = ace::DataFormat_NCHW) {
  TensorConvertInfoBuilder builder_(_fbb);
  builder_.add_dest(dest);
  builder_.add_source(source);
  return builder_.Finish();
}

flatbuffers::Offset<TensorConvertInfo> CreateTensorConvertInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorConvertInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GridSampleT : public flatbuffers::NativeTable {
  typedef GridSample TableType;
  ace::SampleMode mode = ace::SampleMode_BILINEAR;
  ace::BorderMode paddingMode = ace::BorderMode_ZEROS;
  bool alignCorners = false;
};

struct GridSample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GridSampleT NativeTableType;
  typedef GridSampleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GridSampleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_PADDINGMODE = 6,
    VT_ALIGNCORNERS = 8
  };
  ace::SampleMode mode() const {
    return static_cast<ace::SampleMode>(GetField<int8_t>(VT_MODE, 0));
  }
  ace::BorderMode paddingMode() const {
    return static_cast<ace::BorderMode>(GetField<int8_t>(VT_PADDINGMODE, 0));
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_PADDINGMODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS, 1) &&
           verifier.EndTable();
  }
  GridSampleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GridSampleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GridSample> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GridSampleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GridSampleBuilder {
  typedef GridSample Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(ace::SampleMode mode) {
    fbb_.AddElement<int8_t>(GridSample::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_paddingMode(ace::BorderMode paddingMode) {
    fbb_.AddElement<int8_t>(GridSample::VT_PADDINGMODE, static_cast<int8_t>(paddingMode), 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(GridSample::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  explicit GridSampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GridSample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GridSample>(end);
    return o;
  }
};

inline flatbuffers::Offset<GridSample> CreateGridSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::SampleMode mode = ace::SampleMode_BILINEAR,
    ace::BorderMode paddingMode = ace::BorderMode_ZEROS,
    bool alignCorners = false) {
  GridSampleBuilder builder_(_fbb);
  builder_.add_alignCorners(alignCorners);
  builder_.add_paddingMode(paddingMode);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<GridSample> CreateGridSample(flatbuffers::FlatBufferBuilder &_fbb, const GridSampleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ImageProcessParamT : public flatbuffers::NativeTable {
  typedef ImageProcessParam TableType;
  ace::FilterType filterType = ace::FilterType_NEAREST;
  ace::ImageFormatType sourceFormat = ace::ImageFormatType_RGBA;
  ace::ImageFormatType destFormat = ace::ImageFormatType_RGBA;
  ace::WrapType wrap = ace::WrapType_CLAMP_TO_EDGE;
  std::vector<float> mean{};
  std::vector<float> normal{};
  std::vector<float> transform{};
  int8_t paddingValue = 0;
  std::vector<int32_t> shape{};
  ace::DataType outputType = ace::DataType_DT_INVALID;
  bool draw = false;
};

struct ImageProcessParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageProcessParamT NativeTableType;
  typedef ImageProcessParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ImageProcessParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTERTYPE = 4,
    VT_SOURCEFORMAT = 6,
    VT_DESTFORMAT = 8,
    VT_WRAP = 10,
    VT_MEAN = 12,
    VT_NORMAL = 14,
    VT_TRANSFORM = 16,
    VT_PADDINGVALUE = 18,
    VT_SHAPE = 20,
    VT_OUTPUTTYPE = 22,
    VT_DRAW = 24
  };
  ace::FilterType filterType() const {
    return static_cast<ace::FilterType>(GetField<int8_t>(VT_FILTERTYPE, 0));
  }
  ace::ImageFormatType sourceFormat() const {
    return static_cast<ace::ImageFormatType>(GetField<int32_t>(VT_SOURCEFORMAT, 0));
  }
  ace::ImageFormatType destFormat() const {
    return static_cast<ace::ImageFormatType>(GetField<int32_t>(VT_DESTFORMAT, 0));
  }
  ace::WrapType wrap() const {
    return static_cast<ace::WrapType>(GetField<int8_t>(VT_WRAP, 0));
  }
  const flatbuffers::Vector<float> *mean() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MEAN);
  }
  const flatbuffers::Vector<float> *normal() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_NORMAL);
  }
  const flatbuffers::Vector<float> *transform() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TRANSFORM);
  }
  int8_t paddingValue() const {
    return GetField<int8_t>(VT_PADDINGVALUE, 0);
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  ace::DataType outputType() const {
    return static_cast<ace::DataType>(GetField<int32_t>(VT_OUTPUTTYPE, 0));
  }
  bool draw() const {
    return GetField<uint8_t>(VT_DRAW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FILTERTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_SOURCEFORMAT, 4) &&
           VerifyField<int32_t>(verifier, VT_DESTFORMAT, 4) &&
           VerifyField<int8_t>(verifier, VT_WRAP, 1) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyVector(mean()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(normal()) &&
           VerifyOffset(verifier, VT_TRANSFORM) &&
           verifier.VerifyVector(transform()) &&
           VerifyField<int8_t>(verifier, VT_PADDINGVALUE, 1) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DRAW, 1) &&
           verifier.EndTable();
  }
  ImageProcessParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ImageProcessParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ImageProcessParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageProcessParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ImageProcessParamBuilder {
  typedef ImageProcessParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filterType(ace::FilterType filterType) {
    fbb_.AddElement<int8_t>(ImageProcessParam::VT_FILTERTYPE, static_cast<int8_t>(filterType), 0);
  }
  void add_sourceFormat(ace::ImageFormatType sourceFormat) {
    fbb_.AddElement<int32_t>(ImageProcessParam::VT_SOURCEFORMAT, static_cast<int32_t>(sourceFormat), 0);
  }
  void add_destFormat(ace::ImageFormatType destFormat) {
    fbb_.AddElement<int32_t>(ImageProcessParam::VT_DESTFORMAT, static_cast<int32_t>(destFormat), 0);
  }
  void add_wrap(ace::WrapType wrap) {
    fbb_.AddElement<int8_t>(ImageProcessParam::VT_WRAP, static_cast<int8_t>(wrap), 0);
  }
  void add_mean(flatbuffers::Offset<flatbuffers::Vector<float>> mean) {
    fbb_.AddOffset(ImageProcessParam::VT_MEAN, mean);
  }
  void add_normal(flatbuffers::Offset<flatbuffers::Vector<float>> normal) {
    fbb_.AddOffset(ImageProcessParam::VT_NORMAL, normal);
  }
  void add_transform(flatbuffers::Offset<flatbuffers::Vector<float>> transform) {
    fbb_.AddOffset(ImageProcessParam::VT_TRANSFORM, transform);
  }
  void add_paddingValue(int8_t paddingValue) {
    fbb_.AddElement<int8_t>(ImageProcessParam::VT_PADDINGVALUE, paddingValue, 0);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(ImageProcessParam::VT_SHAPE, shape);
  }
  void add_outputType(ace::DataType outputType) {
    fbb_.AddElement<int32_t>(ImageProcessParam::VT_OUTPUTTYPE, static_cast<int32_t>(outputType), 0);
  }
  void add_draw(bool draw) {
    fbb_.AddElement<uint8_t>(ImageProcessParam::VT_DRAW, static_cast<uint8_t>(draw), 0);
  }
  explicit ImageProcessParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImageProcessParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageProcessParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImageProcessParam> CreateImageProcessParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::FilterType filterType = ace::FilterType_NEAREST,
    ace::ImageFormatType sourceFormat = ace::ImageFormatType_RGBA,
    ace::ImageFormatType destFormat = ace::ImageFormatType_RGBA,
    ace::WrapType wrap = ace::WrapType_CLAMP_TO_EDGE,
    flatbuffers::Offset<flatbuffers::Vector<float>> mean = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> normal = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> transform = 0,
    int8_t paddingValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    ace::DataType outputType = ace::DataType_DT_INVALID,
    bool draw = false) {
  ImageProcessParamBuilder builder_(_fbb);
  builder_.add_outputType(outputType);
  builder_.add_shape(shape);
  builder_.add_transform(transform);
  builder_.add_normal(normal);
  builder_.add_mean(mean);
  builder_.add_destFormat(destFormat);
  builder_.add_sourceFormat(sourceFormat);
  builder_.add_draw(draw);
  builder_.add_paddingValue(paddingValue);
  builder_.add_wrap(wrap);
  builder_.add_filterType(filterType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ImageProcessParam> CreateImageProcessParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ace::FilterType filterType = ace::FilterType_NEAREST,
    ace::ImageFormatType sourceFormat = ace::ImageFormatType_RGBA,
    ace::ImageFormatType destFormat = ace::ImageFormatType_RGBA,
    ace::WrapType wrap = ace::WrapType_CLAMP_TO_EDGE,
    const std::vector<float> *mean = nullptr,
    const std::vector<float> *normal = nullptr,
    const std::vector<float> *transform = nullptr,
    int8_t paddingValue = 0,
    const std::vector<int32_t> *shape = nullptr,
    ace::DataType outputType = ace::DataType_DT_INVALID,
    bool draw = false) {
  auto mean__ = mean ? _fbb.CreateVector<float>(*mean) : 0;
  auto normal__ = normal ? _fbb.CreateVector<float>(*normal) : 0;
  auto transform__ = transform ? _fbb.CreateVector<float>(*transform) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return ace::CreateImageProcessParam(
      _fbb,
      filterType,
      sourceFormat,
      destFormat,
      wrap,
      mean__,
      normal__,
      transform__,
      paddingValue,
      shape__,
      outputType,
      draw);
}

flatbuffers::Offset<ImageProcessParam> CreateImageProcessParam(flatbuffers::FlatBufferBuilder &_fbb, const ImageProcessParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TensorConvertInfoT *TensorConvertInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorConvertInfoT>(new TensorConvertInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorConvertInfo::UnPackTo(TensorConvertInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = source(); _o->source = _e; }
  { auto _e = dest(); _o->dest = _e; }
}

inline flatbuffers::Offset<TensorConvertInfo> TensorConvertInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorConvertInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorConvertInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorConvertInfo> CreateTensorConvertInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorConvertInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorConvertInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _source = _o->source;
  auto _dest = _o->dest;
  return ace::CreateTensorConvertInfo(
      _fbb,
      _source,
      _dest);
}

inline GridSampleT *GridSample::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GridSampleT>(new GridSampleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GridSample::UnPackTo(GridSampleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = paddingMode(); _o->paddingMode = _e; }
  { auto _e = alignCorners(); _o->alignCorners = _e; }
}

inline flatbuffers::Offset<GridSample> GridSample::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GridSampleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGridSample(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GridSample> CreateGridSample(flatbuffers::FlatBufferBuilder &_fbb, const GridSampleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GridSampleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  auto _paddingMode = _o->paddingMode;
  auto _alignCorners = _o->alignCorners;
  return ace::CreateGridSample(
      _fbb,
      _mode,
      _paddingMode,
      _alignCorners);
}

inline ImageProcessParamT *ImageProcessParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ImageProcessParamT>(new ImageProcessParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ImageProcessParam::UnPackTo(ImageProcessParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = filterType(); _o->filterType = _e; }
  { auto _e = sourceFormat(); _o->sourceFormat = _e; }
  { auto _e = destFormat(); _o->destFormat = _e; }
  { auto _e = wrap(); _o->wrap = _e; }
  { auto _e = mean(); if (_e) { _o->mean.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mean[_i] = _e->Get(_i); } } }
  { auto _e = normal(); if (_e) { _o->normal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normal[_i] = _e->Get(_i); } } }
  { auto _e = transform(); if (_e) { _o->transform.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transform[_i] = _e->Get(_i); } } }
  { auto _e = paddingValue(); _o->paddingValue = _e; }
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
  { auto _e = outputType(); _o->outputType = _e; }
  { auto _e = draw(); _o->draw = _e; }
}

inline flatbuffers::Offset<ImageProcessParam> ImageProcessParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageProcessParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateImageProcessParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ImageProcessParam> CreateImageProcessParam(flatbuffers::FlatBufferBuilder &_fbb, const ImageProcessParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ImageProcessParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _filterType = _o->filterType;
  auto _sourceFormat = _o->sourceFormat;
  auto _destFormat = _o->destFormat;
  auto _wrap = _o->wrap;
  auto _mean = _o->mean.size() ? _fbb.CreateVector(_o->mean) : 0;
  auto _normal = _o->normal.size() ? _fbb.CreateVector(_o->normal) : 0;
  auto _transform = _o->transform.size() ? _fbb.CreateVector(_o->transform) : 0;
  auto _paddingValue = _o->paddingValue;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _outputType = _o->outputType;
  auto _draw = _o->draw;
  return ace::CreateImageProcessParam(
      _fbb,
      _filterType,
      _sourceFormat,
      _destFormat,
      _wrap,
      _mean,
      _normal,
      _transform,
      _paddingValue,
      _shape,
      _outputType,
      _draw);
}

inline const flatbuffers::TypeTable *SampleModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::SampleModeTypeTable
  };
  static const char * const names[] = {
    "BILINEAR",
    "NEAREST"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BorderModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::BorderModeTypeTable
  };
  static const char * const names[] = {
    "ZEROS",
    "CLAMP",
    "REFLECTION"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ImageFormatTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::ImageFormatTypeTypeTable
  };
  static const char * const names[] = {
    "RGBA",
    "RGB",
    "BGR",
    "GRAY",
    "BGRA",
    "YCrCb",
    "YUV",
    "HSV",
    "XYZ",
    "BGR555",
    "BGR565",
    "YUV_NV21",
    "YUV_NV12",
    "YUV_I420",
    "HSV_FULL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FilterTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::FilterTypeTypeTable
  };
  static const char * const names[] = {
    "NEAREST",
    "BILINEAR",
    "BICUBIC"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WrapTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::WrapTypeTypeTable
  };
  static const char * const names[] = {
    "CLAMP_TO_EDGE",
    "ZERO",
    "REPEAT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorConvertInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DataFormatTypeTable
  };
  static const char * const names[] = {
    "source",
    "dest"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GridSampleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::SampleModeTypeTable,
    ace::BorderModeTypeTable
  };
  static const char * const names[] = {
    "mode",
    "paddingMode",
    "alignCorners"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ImageProcessParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 3 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::FilterTypeTypeTable,
    ace::ImageFormatTypeTypeTable,
    ace::WrapTypeTypeTable,
    ace::DataTypeTypeTable
  };
  static const char * const names[] = {
    "filterType",
    "sourceFormat",
    "destFormat",
    "wrap",
    "mean",
    "normal",
    "transform",
    "paddingValue",
    "shape",
    "outputType",
    "draw"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace ace

#endif  // FLATBUFFERS_GENERATED_USERDEFINE_ACE_H_
