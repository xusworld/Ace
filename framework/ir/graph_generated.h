// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRAPH_ACE_H_
#define FLATBUFFERS_GENERATED_GRAPH_ACE_H_


#include "op_generated.h"
#include "op_option_generated.h"
#include "tensor_generated.h"
#include "types_generated.h"

namespace ace {

struct Version;
struct VersionT;

struct SubGraphProto;
struct SubGraphProtoT;

struct GraphProto;
struct GraphProtoT;

inline const flatbuffers::TypeTable *VersionTypeTable();

inline const flatbuffers::TypeTable *SubGraphProtoTypeTable();

inline const flatbuffers::TypeTable *GraphProtoTypeTable();

struct VersionT : public flatbuffers::NativeTable {
  typedef Version TableType;
  int32_t major;
  int32_t minor;
  int32_t patch;
  int32_t version;
  VersionT()
      : major(0),
        minor(0),
        patch(0),
        version(0) {
  }
};

struct Version FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VersionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VersionTypeTable();
  }
  int32_t major() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t minor() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t patch() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t version() const {
    return GetField<int32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  VersionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VersionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Version> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VersionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VersionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_major(int32_t major) {
    fbb_.AddElement<int32_t>(4, major, 0);
  }
  void add_minor(int32_t minor) {
    fbb_.AddElement<int32_t>(6, minor, 0);
  }
  void add_patch(int32_t patch) {
    fbb_.AddElement<int32_t>(8, patch, 0);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(10, version, 0);
  }
  explicit VersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VersionBuilder &operator=(const VersionBuilder &);
  flatbuffers::Offset<Version> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Version>(end);
    return o;
  }
};

inline flatbuffers::Offset<Version> CreateVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t major = 0,
    int32_t minor = 0,
    int32_t patch = 0,
    int32_t version = 0) {
  VersionBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_patch(patch);
  builder_.add_minor(minor);
  builder_.add_major(major);
  return builder_.Finish();
}

flatbuffers::Offset<Version> CreateVersion(flatbuffers::FlatBufferBuilder &_fbb, const VersionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphProtoT : public flatbuffers::NativeTable {
  typedef SubGraphProto TableType;
  std::string name;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  std::vector<std::string> tensors;
  std::vector<std::unique_ptr<OpT>> nodes;
  SubGraphProtoT() {
  }
};

struct SubGraphProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphProtoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGraphProtoTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Op>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Op>> *>(12);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfStrings(tensors()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
  SubGraphProtoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraphProto> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphProtoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(6, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(8, outputs);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors) {
    fbb_.AddOffset(10, tensors);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> nodes) {
    fbb_.AddOffset(12, nodes);
  }
  explicit SubGraphProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphProtoBuilder &operator=(const SubGraphProtoBuilder &);
  flatbuffers::Offset<SubGraphProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraphProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> nodes = 0) {
  SubGraphProtoBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_tensors(tensors);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_name(name);
  return builder_.Finish();
}

flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GraphProtoT : public flatbuffers::NativeTable {
  typedef GraphProto TableType;
  std::string name;
  std::vector<std::unique_ptr<OpT>> ops;
  std::vector<int32_t> inputs;
  std::vector<int32_t> outputs;
  std::vector<std::string> inputs_name;
  std::vector<std::string> outputs_name;
  FrontendFramework ir;
  std::vector<std::string> tensors;
  std::vector<std::unique_ptr<SubGraphProtoT>> subgraphs;
  std::unique_ptr<VersionT> version;
  std::string desc;
  GraphProtoT()
      : ir(FrontendFramework_ONNX) {
  }
};

struct GraphProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphProtoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GraphProtoTypeTable();
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Op>> *ops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Op>> *>(6);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(10);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs_name() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(12);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs_name() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(14);
  }
  FrontendFramework ir() const {
    return static_cast<FrontendFramework>(GetField<int8_t>(16, 1));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(18);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>> *>(20);
  }
  const Version *version() const {
    return GetPointer<const Version *>(22);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(24);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(ops()) &&
           verifier.VerifyVectorOfTables(ops()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(inputs_name()) &&
           verifier.VerifyVectorOfStrings(inputs_name()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(outputs_name()) &&
           verifier.VerifyVectorOfStrings(outputs_name()) &&
           VerifyField<int8_t>(verifier, 16) &&
           VerifyOffset(verifier, 18) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfStrings(tensors()) &&
           VerifyOffset(verifier, 20) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, 22) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, 24) &&
           verifier.VerifyString(desc()) &&
           verifier.EndTable();
  }
  GraphProtoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GraphProto> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GraphProtoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(4, name);
  }
  void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> ops) {
    fbb_.AddOffset(6, ops);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(8, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(10, outputs);
  }
  void add_inputs_name(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs_name) {
    fbb_.AddOffset(12, inputs_name);
  }
  void add_outputs_name(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs_name) {
    fbb_.AddOffset(14, outputs_name);
  }
  void add_ir(FrontendFramework ir) {
    fbb_.AddElement<int8_t>(16, static_cast<int8_t>(ir), 1);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors) {
    fbb_.AddOffset(18, tensors);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>>> subgraphs) {
    fbb_.AddOffset(20, subgraphs);
  }
  void add_version(flatbuffers::Offset<Version> version) {
    fbb_.AddOffset(22, version);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(24, desc);
  }
  explicit GraphProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GraphProtoBuilder &operator=(const GraphProtoBuilder &);
  flatbuffers::Offset<GraphProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GraphProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<GraphProto> CreateGraphProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Op>>> ops = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs_name = 0,
    FrontendFramework ir = FrontendFramework_ONNX,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraphProto>>> subgraphs = 0,
    flatbuffers::Offset<Version> version = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0) {
  GraphProtoBuilder builder_(_fbb);
  builder_.add_desc(desc);
  builder_.add_version(version);
  builder_.add_subgraphs(subgraphs);
  builder_.add_tensors(tensors);
  builder_.add_outputs_name(outputs_name);
  builder_.add_inputs_name(inputs_name);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_ops(ops);
  builder_.add_name(name);
  builder_.add_ir(ir);
  return builder_.Finish();
}

flatbuffers::Offset<GraphProto> CreateGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const GraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline VersionT *Version::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new VersionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Version::UnPackTo(VersionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = major(); _o->major = _e; };
  { auto _e = minor(); _o->minor = _e; };
  { auto _e = patch(); _o->patch = _e; };
  { auto _e = version(); _o->version = _e; };
}

inline flatbuffers::Offset<Version> Version::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VersionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVersion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Version> CreateVersion(flatbuffers::FlatBufferBuilder &_fbb, const VersionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VersionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _major = _o->major;
  auto _minor = _o->minor;
  auto _patch = _o->patch;
  auto _version = _o->version;
  return ace::CreateVersion(
      _fbb,
      _major,
      _minor,
      _patch,
      _version);
}

inline SubGraphProtoT *SubGraphProto::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SubGraphProtoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SubGraphProto::UnPackTo(SubGraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } };
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = _e->Get(_i)->str(); } } };
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<OpT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SubGraphProto> SubGraphProto::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraphProto(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphProtoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVectorOfStrings(_o->tensors) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<Op>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateSubGraphProto(
      _fbb,
      _name,
      _inputs,
      _outputs,
      _tensors,
      _nodes);
}

inline GraphProtoT *GraphProto::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GraphProtoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GraphProto::UnPackTo(GraphProtoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = ops(); if (_e) { _o->ops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ops[_i] = std::unique_ptr<OpT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } };
  { auto _e = inputs_name(); if (_e) { _o->inputs_name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs_name[_i] = _e->Get(_i)->str(); } } };
  { auto _e = outputs_name(); if (_e) { _o->outputs_name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs_name[_i] = _e->Get(_i)->str(); } } };
  { auto _e = ir(); _o->ir = _e; };
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = _e->Get(_i)->str(); } } };
  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subgraphs[_i] = std::unique_ptr<SubGraphProtoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = version(); if (_e) _o->version = std::unique_ptr<VersionT>(_e->UnPack(_resolver)); };
  { auto _e = desc(); if (_e) _o->desc = _e->str(); };
}

inline flatbuffers::Offset<GraphProto> GraphProto::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGraphProto(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GraphProto> CreateGraphProto(flatbuffers::FlatBufferBuilder &_fbb, const GraphProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GraphProtoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _ops = _o->ops.size() ? _fbb.CreateVector<flatbuffers::Offset<Op>> (_o->ops.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->ops[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _inputs_name = _o->inputs_name.size() ? _fbb.CreateVectorOfStrings(_o->inputs_name) : 0;
  auto _outputs_name = _o->outputs_name.size() ? _fbb.CreateVectorOfStrings(_o->outputs_name) : 0;
  auto _ir = _o->ir;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVectorOfStrings(_o->tensors) : 0;
  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<SubGraphProto>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraphProto(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _version = _o->version ? CreateVersion(_fbb, _o->version.get(), _rehasher) : 0;
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  return ace::CreateGraphProto(
      _fbb,
      _name,
      _ops,
      _inputs,
      _outputs,
      _inputs_name,
      _outputs_name,
      _ir,
      _tensors,
      _subgraphs,
      _version,
      _desc);
}

inline const flatbuffers::TypeTable *VersionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "major",
    "minor",
    "patch",
    "version"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGraphProtoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OpTypeTable
  };
  static const char * const names[] = {
    "name",
    "inputs",
    "outputs",
    "tensors",
    "nodes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GraphProtoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OpTypeTable,
    FrontendFrameworkTypeTable,
    SubGraphProtoTypeTable,
    VersionTypeTable
  };
  static const char * const names[] = {
    "name",
    "ops",
    "inputs",
    "outputs",
    "inputs_name",
    "outputs_name",
    "ir",
    "tensors",
    "subgraphs",
    "version",
    "desc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const ace::GraphProto *GetGraphProto(const void *buf) {
  return flatbuffers::GetRoot<ace::GraphProto>(buf);
}

inline const ace::GraphProto *GetSizePrefixedGraphProto(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ace::GraphProto>(buf);
}

inline bool VerifyGraphProtoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ace::GraphProto>(nullptr);
}

inline bool VerifySizePrefixedGraphProtoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ace::GraphProto>(nullptr);
}

inline void FinishGraphProtoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ace::GraphProto> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphProtoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ace::GraphProto> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<GraphProtoT> UnPackGraphProto(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GraphProtoT>(GetGraphProto(buf)->UnPack(res));
}

}  // namespace ace

#endif  // FLATBUFFERS_GENERATED_GRAPH_ACE_H_
