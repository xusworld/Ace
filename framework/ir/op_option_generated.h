// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPOPTION_ACE_H_
#define FLATBUFFERS_GENERATED_OPOPTION_ACE_H_


#include "tensor_generated.h"
#include "types_generated.h"

namespace ace {

struct AbsOption;
struct AbsOptionT;

struct BoundedReluOption;
struct BoundedReluOptionT;

struct ClipOption;
struct ClipOptionT;

struct ClipV2Option;
struct ClipV2OptionT;

struct EluOption;
struct EluOptionT;

struct ExpOption;
struct ExpOptionT;

struct GeluTanhOption;
struct GeluTanhOptionT;

struct HardSigmoidOption;
struct HardSigmoidOptionT;

struct HardSwishOption;
struct HardSwishOptionT;

struct LinearOption;
struct LinearOptionT;

struct LogOption;
struct LogOptionT;

struct LogisticOption;
struct LogisticOptionT;

struct MishOption;
struct MishOptionT;

struct PowOption;
struct PowOptionT;

struct PReluOption;
struct PReluOptionT;

struct ReluOption;
struct ReluOptionT;

struct Relu6Option;
struct Relu6OptionT;

struct ClippedReluOption;
struct ClippedReluOptionT;

struct LeakyReluOption;
struct LeakyReluOptionT;

struct LogSigmoidOption;
struct LogSigmoidOptionT;

struct RoundOption;
struct RoundOptionT;

struct SeluOption;
struct SeluOptionT;

struct SigmoidOption;
struct SigmoidOptionT;

struct SoftReluOption;
struct SoftReluOptionT;

struct SoftReluV2Option;
struct SoftReluV2OptionT;

struct SqrtOption;
struct SqrtOptionT;

struct SwishOption;
struct SwishOptionT;

struct TanhOption;
struct TanhOptionT;

struct ConstOption;
struct ConstOptionT;

struct NoneElementwiseOption;
struct NoneElementwiseOptionT;

struct AddOption;
struct AddOptionT;

struct MulOption;
struct MulOptionT;

struct MinOption;
struct MinOptionT;

struct MaxOption;
struct MaxOptionT;

struct MeanOption;
struct MeanOptionT;

struct DivOption;
struct DivOptionT;

struct GreaterEqualOption;
struct GreaterEqualOptionT;

struct GreaterThanOption;
struct GreaterThanOptionT;

struct LessEqualOption;
struct LessEqualOptionT;

struct LessThanOption;
struct LessThanOptionT;

struct EqualToOption;
struct EqualToOptionT;

struct NotEqualOption;
struct NotEqualOptionT;

struct ReduceMinOption;
struct ReduceMinOptionT;

struct ReduceMaxOption;
struct ReduceMaxOptionT;

struct ReduceMeanOption;
struct ReduceMeanOptionT;

struct ReduceSumOption;
struct ReduceSumOptionT;

struct ReduceMulOption;
struct ReduceMulOptionT;

struct Pool2DOption;
struct Pool2DOptionT;

struct Pool3DOption;
struct Pool3DOptionT;

struct ReshapeOption;
struct ReshapeOptionT;

struct SliceOption;
struct SliceOptionT;

struct FlattenOption;
struct FlattenOptionT;

struct PermuteOption;
struct PermuteOptionT;

struct ArgMaxOption;
struct ArgMaxOptionT;

struct BatchNormOption;
struct BatchNormOptionT;

struct Conv2DOption;
struct Conv2DOptionT;

struct Conv3DOption;
struct Conv3DOptionT;

struct InnerProductOption;
struct InnerProductOptionT;

struct LRNOption;
struct LRNOptionT;

struct NormalizeOption;
struct NormalizeOptionT;

struct PriorBoxOption;
struct PriorBoxOptionT;

struct ProposalOption;
struct ProposalOptionT;

struct ResizeOption;
struct ResizeOptionT;

struct RoiPoolingOption;
struct RoiPoolingOptionT;

struct ScaleOption;
struct ScaleOptionT;

struct SoftmaxOption;
struct SoftmaxOptionT;

struct InputOption;
struct InputOptionT;

struct DefaultOption;
struct DefaultOptionT;

inline const flatbuffers::TypeTable *AbsOptionTypeTable();

inline const flatbuffers::TypeTable *BoundedReluOptionTypeTable();

inline const flatbuffers::TypeTable *ClipOptionTypeTable();

inline const flatbuffers::TypeTable *ClipV2OptionTypeTable();

inline const flatbuffers::TypeTable *EluOptionTypeTable();

inline const flatbuffers::TypeTable *ExpOptionTypeTable();

inline const flatbuffers::TypeTable *GeluTanhOptionTypeTable();

inline const flatbuffers::TypeTable *HardSigmoidOptionTypeTable();

inline const flatbuffers::TypeTable *HardSwishOptionTypeTable();

inline const flatbuffers::TypeTable *LinearOptionTypeTable();

inline const flatbuffers::TypeTable *LogOptionTypeTable();

inline const flatbuffers::TypeTable *LogisticOptionTypeTable();

inline const flatbuffers::TypeTable *MishOptionTypeTable();

inline const flatbuffers::TypeTable *PowOptionTypeTable();

inline const flatbuffers::TypeTable *PReluOptionTypeTable();

inline const flatbuffers::TypeTable *ReluOptionTypeTable();

inline const flatbuffers::TypeTable *Relu6OptionTypeTable();

inline const flatbuffers::TypeTable *ClippedReluOptionTypeTable();

inline const flatbuffers::TypeTable *LeakyReluOptionTypeTable();

inline const flatbuffers::TypeTable *LogSigmoidOptionTypeTable();

inline const flatbuffers::TypeTable *RoundOptionTypeTable();

inline const flatbuffers::TypeTable *SeluOptionTypeTable();

inline const flatbuffers::TypeTable *SigmoidOptionTypeTable();

inline const flatbuffers::TypeTable *SoftReluOptionTypeTable();

inline const flatbuffers::TypeTable *SoftReluV2OptionTypeTable();

inline const flatbuffers::TypeTable *SqrtOptionTypeTable();

inline const flatbuffers::TypeTable *SwishOptionTypeTable();

inline const flatbuffers::TypeTable *TanhOptionTypeTable();

inline const flatbuffers::TypeTable *ConstOptionTypeTable();

inline const flatbuffers::TypeTable *NoneElementwiseOptionTypeTable();

inline const flatbuffers::TypeTable *AddOptionTypeTable();

inline const flatbuffers::TypeTable *MulOptionTypeTable();

inline const flatbuffers::TypeTable *MinOptionTypeTable();

inline const flatbuffers::TypeTable *MaxOptionTypeTable();

inline const flatbuffers::TypeTable *MeanOptionTypeTable();

inline const flatbuffers::TypeTable *DivOptionTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualOptionTypeTable();

inline const flatbuffers::TypeTable *GreaterThanOptionTypeTable();

inline const flatbuffers::TypeTable *LessEqualOptionTypeTable();

inline const flatbuffers::TypeTable *LessThanOptionTypeTable();

inline const flatbuffers::TypeTable *EqualToOptionTypeTable();

inline const flatbuffers::TypeTable *NotEqualOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMinOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMaxOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMeanOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceSumOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMulOptionTypeTable();

inline const flatbuffers::TypeTable *Pool2DOptionTypeTable();

inline const flatbuffers::TypeTable *Pool3DOptionTypeTable();

inline const flatbuffers::TypeTable *ReshapeOptionTypeTable();

inline const flatbuffers::TypeTable *SliceOptionTypeTable();

inline const flatbuffers::TypeTable *FlattenOptionTypeTable();

inline const flatbuffers::TypeTable *PermuteOptionTypeTable();

inline const flatbuffers::TypeTable *ArgMaxOptionTypeTable();

inline const flatbuffers::TypeTable *BatchNormOptionTypeTable();

inline const flatbuffers::TypeTable *Conv2DOptionTypeTable();

inline const flatbuffers::TypeTable *Conv3DOptionTypeTable();

inline const flatbuffers::TypeTable *InnerProductOptionTypeTable();

inline const flatbuffers::TypeTable *LRNOptionTypeTable();

inline const flatbuffers::TypeTable *NormalizeOptionTypeTable();

inline const flatbuffers::TypeTable *PriorBoxOptionTypeTable();

inline const flatbuffers::TypeTable *ProposalOptionTypeTable();

inline const flatbuffers::TypeTable *ResizeOptionTypeTable();

inline const flatbuffers::TypeTable *RoiPoolingOptionTypeTable();

inline const flatbuffers::TypeTable *ScaleOptionTypeTable();

inline const flatbuffers::TypeTable *SoftmaxOptionTypeTable();

inline const flatbuffers::TypeTable *InputOptionTypeTable();

inline const flatbuffers::TypeTable *DefaultOptionTypeTable();

enum ElementwiseOption {
  ElementwiseOption_NONE = 0,
  ElementwiseOption_AbsOption = 1,
  ElementwiseOption_BoundedReluOption = 2,
  ElementwiseOption_ClipOption = 3,
  ElementwiseOption_ClipV2Option = 4,
  ElementwiseOption_ClippedReluOption = 5,
  ElementwiseOption_EluOption = 6,
  ElementwiseOption_ExpOption = 7,
  ElementwiseOption_GeluTanhOption = 8,
  ElementwiseOption_HardSigmoidOption = 9,
  ElementwiseOption_HardSwishOption = 10,
  ElementwiseOption_LeakyReluOption = 11,
  ElementwiseOption_LinearOption = 12,
  ElementwiseOption_LogOption = 13,
  ElementwiseOption_LogisticOption = 14,
  ElementwiseOption_LogSigmoidOption = 15,
  ElementwiseOption_MishOption = 16,
  ElementwiseOption_PowOption = 17,
  ElementwiseOption_PReluOption = 18,
  ElementwiseOption_ReluOption = 19,
  ElementwiseOption_Relu6Option = 20,
  ElementwiseOption_RoundOption = 21,
  ElementwiseOption_SeluOption = 22,
  ElementwiseOption_SigmoidOption = 23,
  ElementwiseOption_SoftReluOption = 24,
  ElementwiseOption_SoftReluV2Option = 25,
  ElementwiseOption_SqrtOption = 26,
  ElementwiseOption_SwishOption = 27,
  ElementwiseOption_TanhOption = 28,
  ElementwiseOption_NoneElementwiseOption = 29,
  ElementwiseOption_MIN = ElementwiseOption_NONE,
  ElementwiseOption_MAX = ElementwiseOption_NoneElementwiseOption
};

inline const ElementwiseOption (&EnumValuesElementwiseOption())[30] {
  static const ElementwiseOption values[] = {
    ElementwiseOption_NONE,
    ElementwiseOption_AbsOption,
    ElementwiseOption_BoundedReluOption,
    ElementwiseOption_ClipOption,
    ElementwiseOption_ClipV2Option,
    ElementwiseOption_ClippedReluOption,
    ElementwiseOption_EluOption,
    ElementwiseOption_ExpOption,
    ElementwiseOption_GeluTanhOption,
    ElementwiseOption_HardSigmoidOption,
    ElementwiseOption_HardSwishOption,
    ElementwiseOption_LeakyReluOption,
    ElementwiseOption_LinearOption,
    ElementwiseOption_LogOption,
    ElementwiseOption_LogisticOption,
    ElementwiseOption_LogSigmoidOption,
    ElementwiseOption_MishOption,
    ElementwiseOption_PowOption,
    ElementwiseOption_PReluOption,
    ElementwiseOption_ReluOption,
    ElementwiseOption_Relu6Option,
    ElementwiseOption_RoundOption,
    ElementwiseOption_SeluOption,
    ElementwiseOption_SigmoidOption,
    ElementwiseOption_SoftReluOption,
    ElementwiseOption_SoftReluV2Option,
    ElementwiseOption_SqrtOption,
    ElementwiseOption_SwishOption,
    ElementwiseOption_TanhOption,
    ElementwiseOption_NoneElementwiseOption
  };
  return values;
}

inline const char * const *EnumNamesElementwiseOption() {
  static const char * const names[] = {
    "NONE",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "NoneElementwiseOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameElementwiseOption(ElementwiseOption e) {
  if (e < ElementwiseOption_NONE || e > ElementwiseOption_NoneElementwiseOption) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesElementwiseOption()[index];
}

template<typename T> struct ElementwiseOptionTraits {
  static const ElementwiseOption enum_value = ElementwiseOption_NONE;
};

template<> struct ElementwiseOptionTraits<AbsOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_AbsOption;
};

template<> struct ElementwiseOptionTraits<BoundedReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_BoundedReluOption;
};

template<> struct ElementwiseOptionTraits<ClipOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClipOption;
};

template<> struct ElementwiseOptionTraits<ClipV2Option> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClipV2Option;
};

template<> struct ElementwiseOptionTraits<ClippedReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClippedReluOption;
};

template<> struct ElementwiseOptionTraits<EluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_EluOption;
};

template<> struct ElementwiseOptionTraits<ExpOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ExpOption;
};

template<> struct ElementwiseOptionTraits<GeluTanhOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_GeluTanhOption;
};

template<> struct ElementwiseOptionTraits<HardSigmoidOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_HardSigmoidOption;
};

template<> struct ElementwiseOptionTraits<HardSwishOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_HardSwishOption;
};

template<> struct ElementwiseOptionTraits<LeakyReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LeakyReluOption;
};

template<> struct ElementwiseOptionTraits<LinearOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LinearOption;
};

template<> struct ElementwiseOptionTraits<LogOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogOption;
};

template<> struct ElementwiseOptionTraits<LogisticOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogisticOption;
};

template<> struct ElementwiseOptionTraits<LogSigmoidOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogSigmoidOption;
};

template<> struct ElementwiseOptionTraits<MishOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_MishOption;
};

template<> struct ElementwiseOptionTraits<PowOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_PowOption;
};

template<> struct ElementwiseOptionTraits<PReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_PReluOption;
};

template<> struct ElementwiseOptionTraits<ReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ReluOption;
};

template<> struct ElementwiseOptionTraits<Relu6Option> {
  static const ElementwiseOption enum_value = ElementwiseOption_Relu6Option;
};

template<> struct ElementwiseOptionTraits<RoundOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_RoundOption;
};

template<> struct ElementwiseOptionTraits<SeluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SeluOption;
};

template<> struct ElementwiseOptionTraits<SigmoidOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SigmoidOption;
};

template<> struct ElementwiseOptionTraits<SoftReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SoftReluOption;
};

template<> struct ElementwiseOptionTraits<SoftReluV2Option> {
  static const ElementwiseOption enum_value = ElementwiseOption_SoftReluV2Option;
};

template<> struct ElementwiseOptionTraits<SqrtOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SqrtOption;
};

template<> struct ElementwiseOptionTraits<SwishOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SwishOption;
};

template<> struct ElementwiseOptionTraits<TanhOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_TanhOption;
};

template<> struct ElementwiseOptionTraits<NoneElementwiseOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_NoneElementwiseOption;
};

struct ElementwiseOptionUnion {
  ElementwiseOption type;
  void *value;

  ElementwiseOptionUnion() : type(ElementwiseOption_NONE), value(nullptr) {}
  ElementwiseOptionUnion(ElementwiseOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ElementwiseOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ElementwiseOptionUnion(const ElementwiseOptionUnion &) FLATBUFFERS_NOEXCEPT;
  ElementwiseOptionUnion &operator=(const ElementwiseOptionUnion &u) FLATBUFFERS_NOEXCEPT
    { ElementwiseOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ElementwiseOptionUnion &operator=(ElementwiseOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ElementwiseOptionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ElementwiseOptionTraits<typename T::TableType>::enum_value;
    if (type != ElementwiseOption_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ElementwiseOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AbsOptionT *AsAbsOption() {
    return type == ElementwiseOption_AbsOption ?
      reinterpret_cast<AbsOptionT *>(value) : nullptr;
  }
  const AbsOptionT *AsAbsOption() const {
    return type == ElementwiseOption_AbsOption ?
      reinterpret_cast<const AbsOptionT *>(value) : nullptr;
  }
  BoundedReluOptionT *AsBoundedReluOption() {
    return type == ElementwiseOption_BoundedReluOption ?
      reinterpret_cast<BoundedReluOptionT *>(value) : nullptr;
  }
  const BoundedReluOptionT *AsBoundedReluOption() const {
    return type == ElementwiseOption_BoundedReluOption ?
      reinterpret_cast<const BoundedReluOptionT *>(value) : nullptr;
  }
  ClipOptionT *AsClipOption() {
    return type == ElementwiseOption_ClipOption ?
      reinterpret_cast<ClipOptionT *>(value) : nullptr;
  }
  const ClipOptionT *AsClipOption() const {
    return type == ElementwiseOption_ClipOption ?
      reinterpret_cast<const ClipOptionT *>(value) : nullptr;
  }
  ClipV2OptionT *AsClipV2Option() {
    return type == ElementwiseOption_ClipV2Option ?
      reinterpret_cast<ClipV2OptionT *>(value) : nullptr;
  }
  const ClipV2OptionT *AsClipV2Option() const {
    return type == ElementwiseOption_ClipV2Option ?
      reinterpret_cast<const ClipV2OptionT *>(value) : nullptr;
  }
  ClippedReluOptionT *AsClippedReluOption() {
    return type == ElementwiseOption_ClippedReluOption ?
      reinterpret_cast<ClippedReluOptionT *>(value) : nullptr;
  }
  const ClippedReluOptionT *AsClippedReluOption() const {
    return type == ElementwiseOption_ClippedReluOption ?
      reinterpret_cast<const ClippedReluOptionT *>(value) : nullptr;
  }
  EluOptionT *AsEluOption() {
    return type == ElementwiseOption_EluOption ?
      reinterpret_cast<EluOptionT *>(value) : nullptr;
  }
  const EluOptionT *AsEluOption() const {
    return type == ElementwiseOption_EluOption ?
      reinterpret_cast<const EluOptionT *>(value) : nullptr;
  }
  ExpOptionT *AsExpOption() {
    return type == ElementwiseOption_ExpOption ?
      reinterpret_cast<ExpOptionT *>(value) : nullptr;
  }
  const ExpOptionT *AsExpOption() const {
    return type == ElementwiseOption_ExpOption ?
      reinterpret_cast<const ExpOptionT *>(value) : nullptr;
  }
  GeluTanhOptionT *AsGeluTanhOption() {
    return type == ElementwiseOption_GeluTanhOption ?
      reinterpret_cast<GeluTanhOptionT *>(value) : nullptr;
  }
  const GeluTanhOptionT *AsGeluTanhOption() const {
    return type == ElementwiseOption_GeluTanhOption ?
      reinterpret_cast<const GeluTanhOptionT *>(value) : nullptr;
  }
  HardSigmoidOptionT *AsHardSigmoidOption() {
    return type == ElementwiseOption_HardSigmoidOption ?
      reinterpret_cast<HardSigmoidOptionT *>(value) : nullptr;
  }
  const HardSigmoidOptionT *AsHardSigmoidOption() const {
    return type == ElementwiseOption_HardSigmoidOption ?
      reinterpret_cast<const HardSigmoidOptionT *>(value) : nullptr;
  }
  HardSwishOptionT *AsHardSwishOption() {
    return type == ElementwiseOption_HardSwishOption ?
      reinterpret_cast<HardSwishOptionT *>(value) : nullptr;
  }
  const HardSwishOptionT *AsHardSwishOption() const {
    return type == ElementwiseOption_HardSwishOption ?
      reinterpret_cast<const HardSwishOptionT *>(value) : nullptr;
  }
  LeakyReluOptionT *AsLeakyReluOption() {
    return type == ElementwiseOption_LeakyReluOption ?
      reinterpret_cast<LeakyReluOptionT *>(value) : nullptr;
  }
  const LeakyReluOptionT *AsLeakyReluOption() const {
    return type == ElementwiseOption_LeakyReluOption ?
      reinterpret_cast<const LeakyReluOptionT *>(value) : nullptr;
  }
  LinearOptionT *AsLinearOption() {
    return type == ElementwiseOption_LinearOption ?
      reinterpret_cast<LinearOptionT *>(value) : nullptr;
  }
  const LinearOptionT *AsLinearOption() const {
    return type == ElementwiseOption_LinearOption ?
      reinterpret_cast<const LinearOptionT *>(value) : nullptr;
  }
  LogOptionT *AsLogOption() {
    return type == ElementwiseOption_LogOption ?
      reinterpret_cast<LogOptionT *>(value) : nullptr;
  }
  const LogOptionT *AsLogOption() const {
    return type == ElementwiseOption_LogOption ?
      reinterpret_cast<const LogOptionT *>(value) : nullptr;
  }
  LogisticOptionT *AsLogisticOption() {
    return type == ElementwiseOption_LogisticOption ?
      reinterpret_cast<LogisticOptionT *>(value) : nullptr;
  }
  const LogisticOptionT *AsLogisticOption() const {
    return type == ElementwiseOption_LogisticOption ?
      reinterpret_cast<const LogisticOptionT *>(value) : nullptr;
  }
  LogSigmoidOptionT *AsLogSigmoidOption() {
    return type == ElementwiseOption_LogSigmoidOption ?
      reinterpret_cast<LogSigmoidOptionT *>(value) : nullptr;
  }
  const LogSigmoidOptionT *AsLogSigmoidOption() const {
    return type == ElementwiseOption_LogSigmoidOption ?
      reinterpret_cast<const LogSigmoidOptionT *>(value) : nullptr;
  }
  MishOptionT *AsMishOption() {
    return type == ElementwiseOption_MishOption ?
      reinterpret_cast<MishOptionT *>(value) : nullptr;
  }
  const MishOptionT *AsMishOption() const {
    return type == ElementwiseOption_MishOption ?
      reinterpret_cast<const MishOptionT *>(value) : nullptr;
  }
  PowOptionT *AsPowOption() {
    return type == ElementwiseOption_PowOption ?
      reinterpret_cast<PowOptionT *>(value) : nullptr;
  }
  const PowOptionT *AsPowOption() const {
    return type == ElementwiseOption_PowOption ?
      reinterpret_cast<const PowOptionT *>(value) : nullptr;
  }
  PReluOptionT *AsPReluOption() {
    return type == ElementwiseOption_PReluOption ?
      reinterpret_cast<PReluOptionT *>(value) : nullptr;
  }
  const PReluOptionT *AsPReluOption() const {
    return type == ElementwiseOption_PReluOption ?
      reinterpret_cast<const PReluOptionT *>(value) : nullptr;
  }
  ReluOptionT *AsReluOption() {
    return type == ElementwiseOption_ReluOption ?
      reinterpret_cast<ReluOptionT *>(value) : nullptr;
  }
  const ReluOptionT *AsReluOption() const {
    return type == ElementwiseOption_ReluOption ?
      reinterpret_cast<const ReluOptionT *>(value) : nullptr;
  }
  Relu6OptionT *AsRelu6Option() {
    return type == ElementwiseOption_Relu6Option ?
      reinterpret_cast<Relu6OptionT *>(value) : nullptr;
  }
  const Relu6OptionT *AsRelu6Option() const {
    return type == ElementwiseOption_Relu6Option ?
      reinterpret_cast<const Relu6OptionT *>(value) : nullptr;
  }
  RoundOptionT *AsRoundOption() {
    return type == ElementwiseOption_RoundOption ?
      reinterpret_cast<RoundOptionT *>(value) : nullptr;
  }
  const RoundOptionT *AsRoundOption() const {
    return type == ElementwiseOption_RoundOption ?
      reinterpret_cast<const RoundOptionT *>(value) : nullptr;
  }
  SeluOptionT *AsSeluOption() {
    return type == ElementwiseOption_SeluOption ?
      reinterpret_cast<SeluOptionT *>(value) : nullptr;
  }
  const SeluOptionT *AsSeluOption() const {
    return type == ElementwiseOption_SeluOption ?
      reinterpret_cast<const SeluOptionT *>(value) : nullptr;
  }
  SigmoidOptionT *AsSigmoidOption() {
    return type == ElementwiseOption_SigmoidOption ?
      reinterpret_cast<SigmoidOptionT *>(value) : nullptr;
  }
  const SigmoidOptionT *AsSigmoidOption() const {
    return type == ElementwiseOption_SigmoidOption ?
      reinterpret_cast<const SigmoidOptionT *>(value) : nullptr;
  }
  SoftReluOptionT *AsSoftReluOption() {
    return type == ElementwiseOption_SoftReluOption ?
      reinterpret_cast<SoftReluOptionT *>(value) : nullptr;
  }
  const SoftReluOptionT *AsSoftReluOption() const {
    return type == ElementwiseOption_SoftReluOption ?
      reinterpret_cast<const SoftReluOptionT *>(value) : nullptr;
  }
  SoftReluV2OptionT *AsSoftReluV2Option() {
    return type == ElementwiseOption_SoftReluV2Option ?
      reinterpret_cast<SoftReluV2OptionT *>(value) : nullptr;
  }
  const SoftReluV2OptionT *AsSoftReluV2Option() const {
    return type == ElementwiseOption_SoftReluV2Option ?
      reinterpret_cast<const SoftReluV2OptionT *>(value) : nullptr;
  }
  SqrtOptionT *AsSqrtOption() {
    return type == ElementwiseOption_SqrtOption ?
      reinterpret_cast<SqrtOptionT *>(value) : nullptr;
  }
  const SqrtOptionT *AsSqrtOption() const {
    return type == ElementwiseOption_SqrtOption ?
      reinterpret_cast<const SqrtOptionT *>(value) : nullptr;
  }
  SwishOptionT *AsSwishOption() {
    return type == ElementwiseOption_SwishOption ?
      reinterpret_cast<SwishOptionT *>(value) : nullptr;
  }
  const SwishOptionT *AsSwishOption() const {
    return type == ElementwiseOption_SwishOption ?
      reinterpret_cast<const SwishOptionT *>(value) : nullptr;
  }
  TanhOptionT *AsTanhOption() {
    return type == ElementwiseOption_TanhOption ?
      reinterpret_cast<TanhOptionT *>(value) : nullptr;
  }
  const TanhOptionT *AsTanhOption() const {
    return type == ElementwiseOption_TanhOption ?
      reinterpret_cast<const TanhOptionT *>(value) : nullptr;
  }
  NoneElementwiseOptionT *AsNoneElementwiseOption() {
    return type == ElementwiseOption_NoneElementwiseOption ?
      reinterpret_cast<NoneElementwiseOptionT *>(value) : nullptr;
  }
  const NoneElementwiseOptionT *AsNoneElementwiseOption() const {
    return type == ElementwiseOption_NoneElementwiseOption ?
      reinterpret_cast<const NoneElementwiseOptionT *>(value) : nullptr;
  }
};

bool VerifyElementwiseOption(flatbuffers::Verifier &verifier, const void *obj, ElementwiseOption type);
bool VerifyElementwiseOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BinaryOption {
  BinaryOption_NONE = 0,
  BinaryOption_AddOption = 1,
  BinaryOption_MulOption = 2,
  BinaryOption_MinOption = 3,
  BinaryOption_MaxOption = 4,
  BinaryOption_MeanOption = 5,
  BinaryOption_DivOption = 6,
  BinaryOption_GreaterEqualOption = 7,
  BinaryOption_GreaterThanOption = 8,
  BinaryOption_LessEqualOption = 9,
  BinaryOption_LessThanOption = 10,
  BinaryOption_EqualToOption = 11,
  BinaryOption_NotEqualOption = 12,
  BinaryOption_MIN = BinaryOption_NONE,
  BinaryOption_MAX = BinaryOption_NotEqualOption
};

inline const BinaryOption (&EnumValuesBinaryOption())[13] {
  static const BinaryOption values[] = {
    BinaryOption_NONE,
    BinaryOption_AddOption,
    BinaryOption_MulOption,
    BinaryOption_MinOption,
    BinaryOption_MaxOption,
    BinaryOption_MeanOption,
    BinaryOption_DivOption,
    BinaryOption_GreaterEqualOption,
    BinaryOption_GreaterThanOption,
    BinaryOption_LessEqualOption,
    BinaryOption_LessThanOption,
    BinaryOption_EqualToOption,
    BinaryOption_NotEqualOption
  };
  return values;
}

inline const char * const *EnumNamesBinaryOption() {
  static const char * const names[] = {
    "NONE",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameBinaryOption(BinaryOption e) {
  if (e < BinaryOption_NONE || e > BinaryOption_NotEqualOption) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesBinaryOption()[index];
}

template<typename T> struct BinaryOptionTraits {
  static const BinaryOption enum_value = BinaryOption_NONE;
};

template<> struct BinaryOptionTraits<AddOption> {
  static const BinaryOption enum_value = BinaryOption_AddOption;
};

template<> struct BinaryOptionTraits<MulOption> {
  static const BinaryOption enum_value = BinaryOption_MulOption;
};

template<> struct BinaryOptionTraits<MinOption> {
  static const BinaryOption enum_value = BinaryOption_MinOption;
};

template<> struct BinaryOptionTraits<MaxOption> {
  static const BinaryOption enum_value = BinaryOption_MaxOption;
};

template<> struct BinaryOptionTraits<MeanOption> {
  static const BinaryOption enum_value = BinaryOption_MeanOption;
};

template<> struct BinaryOptionTraits<DivOption> {
  static const BinaryOption enum_value = BinaryOption_DivOption;
};

template<> struct BinaryOptionTraits<GreaterEqualOption> {
  static const BinaryOption enum_value = BinaryOption_GreaterEqualOption;
};

template<> struct BinaryOptionTraits<GreaterThanOption> {
  static const BinaryOption enum_value = BinaryOption_GreaterThanOption;
};

template<> struct BinaryOptionTraits<LessEqualOption> {
  static const BinaryOption enum_value = BinaryOption_LessEqualOption;
};

template<> struct BinaryOptionTraits<LessThanOption> {
  static const BinaryOption enum_value = BinaryOption_LessThanOption;
};

template<> struct BinaryOptionTraits<EqualToOption> {
  static const BinaryOption enum_value = BinaryOption_EqualToOption;
};

template<> struct BinaryOptionTraits<NotEqualOption> {
  static const BinaryOption enum_value = BinaryOption_NotEqualOption;
};

struct BinaryOptionUnion {
  BinaryOption type;
  void *value;

  BinaryOptionUnion() : type(BinaryOption_NONE), value(nullptr) {}
  BinaryOptionUnion(BinaryOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BinaryOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BinaryOptionUnion(const BinaryOptionUnion &) FLATBUFFERS_NOEXCEPT;
  BinaryOptionUnion &operator=(const BinaryOptionUnion &u) FLATBUFFERS_NOEXCEPT
    { BinaryOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BinaryOptionUnion &operator=(BinaryOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BinaryOptionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = BinaryOptionTraits<typename T::TableType>::enum_value;
    if (type != BinaryOption_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, BinaryOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AddOptionT *AsAddOption() {
    return type == BinaryOption_AddOption ?
      reinterpret_cast<AddOptionT *>(value) : nullptr;
  }
  const AddOptionT *AsAddOption() const {
    return type == BinaryOption_AddOption ?
      reinterpret_cast<const AddOptionT *>(value) : nullptr;
  }
  MulOptionT *AsMulOption() {
    return type == BinaryOption_MulOption ?
      reinterpret_cast<MulOptionT *>(value) : nullptr;
  }
  const MulOptionT *AsMulOption() const {
    return type == BinaryOption_MulOption ?
      reinterpret_cast<const MulOptionT *>(value) : nullptr;
  }
  MinOptionT *AsMinOption() {
    return type == BinaryOption_MinOption ?
      reinterpret_cast<MinOptionT *>(value) : nullptr;
  }
  const MinOptionT *AsMinOption() const {
    return type == BinaryOption_MinOption ?
      reinterpret_cast<const MinOptionT *>(value) : nullptr;
  }
  MaxOptionT *AsMaxOption() {
    return type == BinaryOption_MaxOption ?
      reinterpret_cast<MaxOptionT *>(value) : nullptr;
  }
  const MaxOptionT *AsMaxOption() const {
    return type == BinaryOption_MaxOption ?
      reinterpret_cast<const MaxOptionT *>(value) : nullptr;
  }
  MeanOptionT *AsMeanOption() {
    return type == BinaryOption_MeanOption ?
      reinterpret_cast<MeanOptionT *>(value) : nullptr;
  }
  const MeanOptionT *AsMeanOption() const {
    return type == BinaryOption_MeanOption ?
      reinterpret_cast<const MeanOptionT *>(value) : nullptr;
  }
  DivOptionT *AsDivOption() {
    return type == BinaryOption_DivOption ?
      reinterpret_cast<DivOptionT *>(value) : nullptr;
  }
  const DivOptionT *AsDivOption() const {
    return type == BinaryOption_DivOption ?
      reinterpret_cast<const DivOptionT *>(value) : nullptr;
  }
  GreaterEqualOptionT *AsGreaterEqualOption() {
    return type == BinaryOption_GreaterEqualOption ?
      reinterpret_cast<GreaterEqualOptionT *>(value) : nullptr;
  }
  const GreaterEqualOptionT *AsGreaterEqualOption() const {
    return type == BinaryOption_GreaterEqualOption ?
      reinterpret_cast<const GreaterEqualOptionT *>(value) : nullptr;
  }
  GreaterThanOptionT *AsGreaterThanOption() {
    return type == BinaryOption_GreaterThanOption ?
      reinterpret_cast<GreaterThanOptionT *>(value) : nullptr;
  }
  const GreaterThanOptionT *AsGreaterThanOption() const {
    return type == BinaryOption_GreaterThanOption ?
      reinterpret_cast<const GreaterThanOptionT *>(value) : nullptr;
  }
  LessEqualOptionT *AsLessEqualOption() {
    return type == BinaryOption_LessEqualOption ?
      reinterpret_cast<LessEqualOptionT *>(value) : nullptr;
  }
  const LessEqualOptionT *AsLessEqualOption() const {
    return type == BinaryOption_LessEqualOption ?
      reinterpret_cast<const LessEqualOptionT *>(value) : nullptr;
  }
  LessThanOptionT *AsLessThanOption() {
    return type == BinaryOption_LessThanOption ?
      reinterpret_cast<LessThanOptionT *>(value) : nullptr;
  }
  const LessThanOptionT *AsLessThanOption() const {
    return type == BinaryOption_LessThanOption ?
      reinterpret_cast<const LessThanOptionT *>(value) : nullptr;
  }
  EqualToOptionT *AsEqualToOption() {
    return type == BinaryOption_EqualToOption ?
      reinterpret_cast<EqualToOptionT *>(value) : nullptr;
  }
  const EqualToOptionT *AsEqualToOption() const {
    return type == BinaryOption_EqualToOption ?
      reinterpret_cast<const EqualToOptionT *>(value) : nullptr;
  }
  NotEqualOptionT *AsNotEqualOption() {
    return type == BinaryOption_NotEqualOption ?
      reinterpret_cast<NotEqualOptionT *>(value) : nullptr;
  }
  const NotEqualOptionT *AsNotEqualOption() const {
    return type == BinaryOption_NotEqualOption ?
      reinterpret_cast<const NotEqualOptionT *>(value) : nullptr;
  }
};

bool VerifyBinaryOption(flatbuffers::Verifier &verifier, const void *obj, BinaryOption type);
bool VerifyBinaryOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ReduceOption {
  ReduceOption_NONE = 0,
  ReduceOption_ReduceMinOption = 1,
  ReduceOption_ReduceMaxOption = 2,
  ReduceOption_ReduceMeanOption = 3,
  ReduceOption_ReduceSumOption = 4,
  ReduceOption_ReduceMulOption = 5,
  ReduceOption_MIN = ReduceOption_NONE,
  ReduceOption_MAX = ReduceOption_ReduceMulOption
};

inline const ReduceOption (&EnumValuesReduceOption())[6] {
  static const ReduceOption values[] = {
    ReduceOption_NONE,
    ReduceOption_ReduceMinOption,
    ReduceOption_ReduceMaxOption,
    ReduceOption_ReduceMeanOption,
    ReduceOption_ReduceSumOption,
    ReduceOption_ReduceMulOption
  };
  return values;
}

inline const char * const *EnumNamesReduceOption() {
  static const char * const names[] = {
    "NONE",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceOption(ReduceOption e) {
  if (e < ReduceOption_NONE || e > ReduceOption_ReduceMulOption) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesReduceOption()[index];
}

template<typename T> struct ReduceOptionTraits {
  static const ReduceOption enum_value = ReduceOption_NONE;
};

template<> struct ReduceOptionTraits<ReduceMinOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMinOption;
};

template<> struct ReduceOptionTraits<ReduceMaxOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMaxOption;
};

template<> struct ReduceOptionTraits<ReduceMeanOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMeanOption;
};

template<> struct ReduceOptionTraits<ReduceSumOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceSumOption;
};

template<> struct ReduceOptionTraits<ReduceMulOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMulOption;
};

struct ReduceOptionUnion {
  ReduceOption type;
  void *value;

  ReduceOptionUnion() : type(ReduceOption_NONE), value(nullptr) {}
  ReduceOptionUnion(ReduceOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ReduceOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ReduceOptionUnion(const ReduceOptionUnion &) FLATBUFFERS_NOEXCEPT;
  ReduceOptionUnion &operator=(const ReduceOptionUnion &u) FLATBUFFERS_NOEXCEPT
    { ReduceOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ReduceOptionUnion &operator=(ReduceOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ReduceOptionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ReduceOptionTraits<typename T::TableType>::enum_value;
    if (type != ReduceOption_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ReduceOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ReduceMinOptionT *AsReduceMinOption() {
    return type == ReduceOption_ReduceMinOption ?
      reinterpret_cast<ReduceMinOptionT *>(value) : nullptr;
  }
  const ReduceMinOptionT *AsReduceMinOption() const {
    return type == ReduceOption_ReduceMinOption ?
      reinterpret_cast<const ReduceMinOptionT *>(value) : nullptr;
  }
  ReduceMaxOptionT *AsReduceMaxOption() {
    return type == ReduceOption_ReduceMaxOption ?
      reinterpret_cast<ReduceMaxOptionT *>(value) : nullptr;
  }
  const ReduceMaxOptionT *AsReduceMaxOption() const {
    return type == ReduceOption_ReduceMaxOption ?
      reinterpret_cast<const ReduceMaxOptionT *>(value) : nullptr;
  }
  ReduceMeanOptionT *AsReduceMeanOption() {
    return type == ReduceOption_ReduceMeanOption ?
      reinterpret_cast<ReduceMeanOptionT *>(value) : nullptr;
  }
  const ReduceMeanOptionT *AsReduceMeanOption() const {
    return type == ReduceOption_ReduceMeanOption ?
      reinterpret_cast<const ReduceMeanOptionT *>(value) : nullptr;
  }
  ReduceSumOptionT *AsReduceSumOption() {
    return type == ReduceOption_ReduceSumOption ?
      reinterpret_cast<ReduceSumOptionT *>(value) : nullptr;
  }
  const ReduceSumOptionT *AsReduceSumOption() const {
    return type == ReduceOption_ReduceSumOption ?
      reinterpret_cast<const ReduceSumOptionT *>(value) : nullptr;
  }
  ReduceMulOptionT *AsReduceMulOption() {
    return type == ReduceOption_ReduceMulOption ?
      reinterpret_cast<ReduceMulOptionT *>(value) : nullptr;
  }
  const ReduceMulOptionT *AsReduceMulOption() const {
    return type == ReduceOption_ReduceMulOption ?
      reinterpret_cast<const ReduceMulOptionT *>(value) : nullptr;
  }
};

bool VerifyReduceOption(flatbuffers::Verifier &verifier, const void *obj, ReduceOption type);
bool VerifyReduceOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum PoolType {
  PoolType_MAX_POOL = 0,
  PoolType_AVG_POOL = 1,
  PoolType_GLOBAL_MAX_POOL = 2,
  PoolType_GLOBAL_AVG_POOL = 3,
  PoolType_MIN = PoolType_MAX_POOL,
  PoolType_MAX = PoolType_GLOBAL_AVG_POOL
};

inline const PoolType (&EnumValuesPoolType())[4] {
  static const PoolType values[] = {
    PoolType_MAX_POOL,
    PoolType_AVG_POOL,
    PoolType_GLOBAL_MAX_POOL,
    PoolType_GLOBAL_AVG_POOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[] = {
    "MAX_POOL",
    "AVG_POOL",
    "GLOBAL_MAX_POOL",
    "GLOBAL_AVG_POOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (e < PoolType_MAX_POOL || e > PoolType_GLOBAL_AVG_POOL) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolType()[index];
}

enum PaddingType {
  PaddingType_VALID = 0,
  PaddingType_SAME = 1,
  PaddingType_MIN = PaddingType_VALID,
  PaddingType_MAX = PaddingType_SAME
};

inline const PaddingType (&EnumValuesPaddingType())[2] {
  static const PaddingType values[] = {
    PaddingType_VALID,
    PaddingType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPaddingType() {
  static const char * const names[] = {
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingType(PaddingType e) {
  if (e < PaddingType_VALID || e > PaddingType_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPaddingType()[index];
}

enum PadMode {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (e < PadMode_CAFFE || e > PadMode_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPadMode()[index];
}

enum OpOption {
  OpOption_NONE = 0,
  OpOption_DefaultOption = 1,
  OpOption_ConstOption = 2,
  OpOption_AbsOption = 3,
  OpOption_BoundedReluOption = 4,
  OpOption_ClipOption = 5,
  OpOption_ClipV2Option = 6,
  OpOption_ClippedReluOption = 7,
  OpOption_EluOption = 8,
  OpOption_ExpOption = 9,
  OpOption_GeluTanhOption = 10,
  OpOption_HardSigmoidOption = 11,
  OpOption_HardSwishOption = 12,
  OpOption_LeakyReluOption = 13,
  OpOption_LinearOption = 14,
  OpOption_LogOption = 15,
  OpOption_LogisticOption = 16,
  OpOption_LogSigmoidOption = 17,
  OpOption_MishOption = 18,
  OpOption_PowOption = 19,
  OpOption_PReluOption = 20,
  OpOption_ReluOption = 21,
  OpOption_Relu6Option = 22,
  OpOption_RoundOption = 23,
  OpOption_SeluOption = 24,
  OpOption_SigmoidOption = 25,
  OpOption_SoftReluOption = 26,
  OpOption_SoftReluV2Option = 27,
  OpOption_SqrtOption = 28,
  OpOption_SwishOption = 29,
  OpOption_TanhOption = 30,
  OpOption_AddOption = 31,
  OpOption_MulOption = 32,
  OpOption_MinOption = 33,
  OpOption_MaxOption = 34,
  OpOption_MeanOption = 35,
  OpOption_DivOption = 36,
  OpOption_GreaterEqualOption = 37,
  OpOption_GreaterThanOption = 38,
  OpOption_LessEqualOption = 39,
  OpOption_LessThanOption = 40,
  OpOption_EqualToOption = 41,
  OpOption_NotEqualOption = 42,
  OpOption_ReduceMinOption = 43,
  OpOption_ReduceMaxOption = 44,
  OpOption_ReduceMeanOption = 45,
  OpOption_ReduceSumOption = 46,
  OpOption_ReduceMulOption = 47,
  OpOption_Pool2DOption = 48,
  OpOption_Pool3DOption = 49,
  OpOption_ReshapeOption = 50,
  OpOption_SliceOption = 51,
  OpOption_FlattenOption = 52,
  OpOption_PermuteOption = 53,
  OpOption_ArgMaxOption = 54,
  OpOption_BatchNormOption = 55,
  OpOption_Conv2DOption = 56,
  OpOption_Conv3DOption = 57,
  OpOption_InnerProductOption = 58,
  OpOption_LRNOption = 59,
  OpOption_NormalizeOption = 60,
  OpOption_PriorBoxOption = 61,
  OpOption_ProposalOption = 62,
  OpOption_ResizeOption = 63,
  OpOption_RoiPoolingOption = 64,
  OpOption_ScaleOption = 65,
  OpOption_SoftmaxOption = 66,
  OpOption_InputOption = 67,
  OpOption_MIN = OpOption_NONE,
  OpOption_MAX = OpOption_InputOption
};

inline const OpOption (&EnumValuesOpOption())[68] {
  static const OpOption values[] = {
    OpOption_NONE,
    OpOption_DefaultOption,
    OpOption_ConstOption,
    OpOption_AbsOption,
    OpOption_BoundedReluOption,
    OpOption_ClipOption,
    OpOption_ClipV2Option,
    OpOption_ClippedReluOption,
    OpOption_EluOption,
    OpOption_ExpOption,
    OpOption_GeluTanhOption,
    OpOption_HardSigmoidOption,
    OpOption_HardSwishOption,
    OpOption_LeakyReluOption,
    OpOption_LinearOption,
    OpOption_LogOption,
    OpOption_LogisticOption,
    OpOption_LogSigmoidOption,
    OpOption_MishOption,
    OpOption_PowOption,
    OpOption_PReluOption,
    OpOption_ReluOption,
    OpOption_Relu6Option,
    OpOption_RoundOption,
    OpOption_SeluOption,
    OpOption_SigmoidOption,
    OpOption_SoftReluOption,
    OpOption_SoftReluV2Option,
    OpOption_SqrtOption,
    OpOption_SwishOption,
    OpOption_TanhOption,
    OpOption_AddOption,
    OpOption_MulOption,
    OpOption_MinOption,
    OpOption_MaxOption,
    OpOption_MeanOption,
    OpOption_DivOption,
    OpOption_GreaterEqualOption,
    OpOption_GreaterThanOption,
    OpOption_LessEqualOption,
    OpOption_LessThanOption,
    OpOption_EqualToOption,
    OpOption_NotEqualOption,
    OpOption_ReduceMinOption,
    OpOption_ReduceMaxOption,
    OpOption_ReduceMeanOption,
    OpOption_ReduceSumOption,
    OpOption_ReduceMulOption,
    OpOption_Pool2DOption,
    OpOption_Pool3DOption,
    OpOption_ReshapeOption,
    OpOption_SliceOption,
    OpOption_FlattenOption,
    OpOption_PermuteOption,
    OpOption_ArgMaxOption,
    OpOption_BatchNormOption,
    OpOption_Conv2DOption,
    OpOption_Conv3DOption,
    OpOption_InnerProductOption,
    OpOption_LRNOption,
    OpOption_NormalizeOption,
    OpOption_PriorBoxOption,
    OpOption_ProposalOption,
    OpOption_ResizeOption,
    OpOption_RoiPoolingOption,
    OpOption_ScaleOption,
    OpOption_SoftmaxOption,
    OpOption_InputOption
  };
  return values;
}

inline const char * const *EnumNamesOpOption() {
  static const char * const names[] = {
    "NONE",
    "DefaultOption",
    "ConstOption",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption",
    "Pool2DOption",
    "Pool3DOption",
    "ReshapeOption",
    "SliceOption",
    "FlattenOption",
    "PermuteOption",
    "ArgMaxOption",
    "BatchNormOption",
    "Conv2DOption",
    "Conv3DOption",
    "InnerProductOption",
    "LRNOption",
    "NormalizeOption",
    "PriorBoxOption",
    "ProposalOption",
    "ResizeOption",
    "RoiPoolingOption",
    "ScaleOption",
    "SoftmaxOption",
    "InputOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpOption(OpOption e) {
  if (e < OpOption_NONE || e > OpOption_InputOption) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesOpOption()[index];
}

template<typename T> struct OpOptionTraits {
  static const OpOption enum_value = OpOption_NONE;
};

template<> struct OpOptionTraits<DefaultOption> {
  static const OpOption enum_value = OpOption_DefaultOption;
};

template<> struct OpOptionTraits<ConstOption> {
  static const OpOption enum_value = OpOption_ConstOption;
};

template<> struct OpOptionTraits<AbsOption> {
  static const OpOption enum_value = OpOption_AbsOption;
};

template<> struct OpOptionTraits<BoundedReluOption> {
  static const OpOption enum_value = OpOption_BoundedReluOption;
};

template<> struct OpOptionTraits<ClipOption> {
  static const OpOption enum_value = OpOption_ClipOption;
};

template<> struct OpOptionTraits<ClipV2Option> {
  static const OpOption enum_value = OpOption_ClipV2Option;
};

template<> struct OpOptionTraits<ClippedReluOption> {
  static const OpOption enum_value = OpOption_ClippedReluOption;
};

template<> struct OpOptionTraits<EluOption> {
  static const OpOption enum_value = OpOption_EluOption;
};

template<> struct OpOptionTraits<ExpOption> {
  static const OpOption enum_value = OpOption_ExpOption;
};

template<> struct OpOptionTraits<GeluTanhOption> {
  static const OpOption enum_value = OpOption_GeluTanhOption;
};

template<> struct OpOptionTraits<HardSigmoidOption> {
  static const OpOption enum_value = OpOption_HardSigmoidOption;
};

template<> struct OpOptionTraits<HardSwishOption> {
  static const OpOption enum_value = OpOption_HardSwishOption;
};

template<> struct OpOptionTraits<LeakyReluOption> {
  static const OpOption enum_value = OpOption_LeakyReluOption;
};

template<> struct OpOptionTraits<LinearOption> {
  static const OpOption enum_value = OpOption_LinearOption;
};

template<> struct OpOptionTraits<LogOption> {
  static const OpOption enum_value = OpOption_LogOption;
};

template<> struct OpOptionTraits<LogisticOption> {
  static const OpOption enum_value = OpOption_LogisticOption;
};

template<> struct OpOptionTraits<LogSigmoidOption> {
  static const OpOption enum_value = OpOption_LogSigmoidOption;
};

template<> struct OpOptionTraits<MishOption> {
  static const OpOption enum_value = OpOption_MishOption;
};

template<> struct OpOptionTraits<PowOption> {
  static const OpOption enum_value = OpOption_PowOption;
};

template<> struct OpOptionTraits<PReluOption> {
  static const OpOption enum_value = OpOption_PReluOption;
};

template<> struct OpOptionTraits<ReluOption> {
  static const OpOption enum_value = OpOption_ReluOption;
};

template<> struct OpOptionTraits<Relu6Option> {
  static const OpOption enum_value = OpOption_Relu6Option;
};

template<> struct OpOptionTraits<RoundOption> {
  static const OpOption enum_value = OpOption_RoundOption;
};

template<> struct OpOptionTraits<SeluOption> {
  static const OpOption enum_value = OpOption_SeluOption;
};

template<> struct OpOptionTraits<SigmoidOption> {
  static const OpOption enum_value = OpOption_SigmoidOption;
};

template<> struct OpOptionTraits<SoftReluOption> {
  static const OpOption enum_value = OpOption_SoftReluOption;
};

template<> struct OpOptionTraits<SoftReluV2Option> {
  static const OpOption enum_value = OpOption_SoftReluV2Option;
};

template<> struct OpOptionTraits<SqrtOption> {
  static const OpOption enum_value = OpOption_SqrtOption;
};

template<> struct OpOptionTraits<SwishOption> {
  static const OpOption enum_value = OpOption_SwishOption;
};

template<> struct OpOptionTraits<TanhOption> {
  static const OpOption enum_value = OpOption_TanhOption;
};

template<> struct OpOptionTraits<AddOption> {
  static const OpOption enum_value = OpOption_AddOption;
};

template<> struct OpOptionTraits<MulOption> {
  static const OpOption enum_value = OpOption_MulOption;
};

template<> struct OpOptionTraits<MinOption> {
  static const OpOption enum_value = OpOption_MinOption;
};

template<> struct OpOptionTraits<MaxOption> {
  static const OpOption enum_value = OpOption_MaxOption;
};

template<> struct OpOptionTraits<MeanOption> {
  static const OpOption enum_value = OpOption_MeanOption;
};

template<> struct OpOptionTraits<DivOption> {
  static const OpOption enum_value = OpOption_DivOption;
};

template<> struct OpOptionTraits<GreaterEqualOption> {
  static const OpOption enum_value = OpOption_GreaterEqualOption;
};

template<> struct OpOptionTraits<GreaterThanOption> {
  static const OpOption enum_value = OpOption_GreaterThanOption;
};

template<> struct OpOptionTraits<LessEqualOption> {
  static const OpOption enum_value = OpOption_LessEqualOption;
};

template<> struct OpOptionTraits<LessThanOption> {
  static const OpOption enum_value = OpOption_LessThanOption;
};

template<> struct OpOptionTraits<EqualToOption> {
  static const OpOption enum_value = OpOption_EqualToOption;
};

template<> struct OpOptionTraits<NotEqualOption> {
  static const OpOption enum_value = OpOption_NotEqualOption;
};

template<> struct OpOptionTraits<ReduceMinOption> {
  static const OpOption enum_value = OpOption_ReduceMinOption;
};

template<> struct OpOptionTraits<ReduceMaxOption> {
  static const OpOption enum_value = OpOption_ReduceMaxOption;
};

template<> struct OpOptionTraits<ReduceMeanOption> {
  static const OpOption enum_value = OpOption_ReduceMeanOption;
};

template<> struct OpOptionTraits<ReduceSumOption> {
  static const OpOption enum_value = OpOption_ReduceSumOption;
};

template<> struct OpOptionTraits<ReduceMulOption> {
  static const OpOption enum_value = OpOption_ReduceMulOption;
};

template<> struct OpOptionTraits<Pool2DOption> {
  static const OpOption enum_value = OpOption_Pool2DOption;
};

template<> struct OpOptionTraits<Pool3DOption> {
  static const OpOption enum_value = OpOption_Pool3DOption;
};

template<> struct OpOptionTraits<ReshapeOption> {
  static const OpOption enum_value = OpOption_ReshapeOption;
};

template<> struct OpOptionTraits<SliceOption> {
  static const OpOption enum_value = OpOption_SliceOption;
};

template<> struct OpOptionTraits<FlattenOption> {
  static const OpOption enum_value = OpOption_FlattenOption;
};

template<> struct OpOptionTraits<PermuteOption> {
  static const OpOption enum_value = OpOption_PermuteOption;
};

template<> struct OpOptionTraits<ArgMaxOption> {
  static const OpOption enum_value = OpOption_ArgMaxOption;
};

template<> struct OpOptionTraits<BatchNormOption> {
  static const OpOption enum_value = OpOption_BatchNormOption;
};

template<> struct OpOptionTraits<Conv2DOption> {
  static const OpOption enum_value = OpOption_Conv2DOption;
};

template<> struct OpOptionTraits<Conv3DOption> {
  static const OpOption enum_value = OpOption_Conv3DOption;
};

template<> struct OpOptionTraits<InnerProductOption> {
  static const OpOption enum_value = OpOption_InnerProductOption;
};

template<> struct OpOptionTraits<LRNOption> {
  static const OpOption enum_value = OpOption_LRNOption;
};

template<> struct OpOptionTraits<NormalizeOption> {
  static const OpOption enum_value = OpOption_NormalizeOption;
};

template<> struct OpOptionTraits<PriorBoxOption> {
  static const OpOption enum_value = OpOption_PriorBoxOption;
};

template<> struct OpOptionTraits<ProposalOption> {
  static const OpOption enum_value = OpOption_ProposalOption;
};

template<> struct OpOptionTraits<ResizeOption> {
  static const OpOption enum_value = OpOption_ResizeOption;
};

template<> struct OpOptionTraits<RoiPoolingOption> {
  static const OpOption enum_value = OpOption_RoiPoolingOption;
};

template<> struct OpOptionTraits<ScaleOption> {
  static const OpOption enum_value = OpOption_ScaleOption;
};

template<> struct OpOptionTraits<SoftmaxOption> {
  static const OpOption enum_value = OpOption_SoftmaxOption;
};

template<> struct OpOptionTraits<InputOption> {
  static const OpOption enum_value = OpOption_InputOption;
};

struct OpOptionUnion {
  OpOption type;
  void *value;

  OpOptionUnion() : type(OpOption_NONE), value(nullptr) {}
  OpOptionUnion(OpOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpOptionUnion(const OpOptionUnion &) FLATBUFFERS_NOEXCEPT;
  OpOptionUnion &operator=(const OpOptionUnion &u) FLATBUFFERS_NOEXCEPT
    { OpOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpOptionUnion &operator=(OpOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpOptionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = OpOptionTraits<typename T::TableType>::enum_value;
    if (type != OpOption_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, OpOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  DefaultOptionT *AsDefaultOption() {
    return type == OpOption_DefaultOption ?
      reinterpret_cast<DefaultOptionT *>(value) : nullptr;
  }
  const DefaultOptionT *AsDefaultOption() const {
    return type == OpOption_DefaultOption ?
      reinterpret_cast<const DefaultOptionT *>(value) : nullptr;
  }
  ConstOptionT *AsConstOption() {
    return type == OpOption_ConstOption ?
      reinterpret_cast<ConstOptionT *>(value) : nullptr;
  }
  const ConstOptionT *AsConstOption() const {
    return type == OpOption_ConstOption ?
      reinterpret_cast<const ConstOptionT *>(value) : nullptr;
  }
  AbsOptionT *AsAbsOption() {
    return type == OpOption_AbsOption ?
      reinterpret_cast<AbsOptionT *>(value) : nullptr;
  }
  const AbsOptionT *AsAbsOption() const {
    return type == OpOption_AbsOption ?
      reinterpret_cast<const AbsOptionT *>(value) : nullptr;
  }
  BoundedReluOptionT *AsBoundedReluOption() {
    return type == OpOption_BoundedReluOption ?
      reinterpret_cast<BoundedReluOptionT *>(value) : nullptr;
  }
  const BoundedReluOptionT *AsBoundedReluOption() const {
    return type == OpOption_BoundedReluOption ?
      reinterpret_cast<const BoundedReluOptionT *>(value) : nullptr;
  }
  ClipOptionT *AsClipOption() {
    return type == OpOption_ClipOption ?
      reinterpret_cast<ClipOptionT *>(value) : nullptr;
  }
  const ClipOptionT *AsClipOption() const {
    return type == OpOption_ClipOption ?
      reinterpret_cast<const ClipOptionT *>(value) : nullptr;
  }
  ClipV2OptionT *AsClipV2Option() {
    return type == OpOption_ClipV2Option ?
      reinterpret_cast<ClipV2OptionT *>(value) : nullptr;
  }
  const ClipV2OptionT *AsClipV2Option() const {
    return type == OpOption_ClipV2Option ?
      reinterpret_cast<const ClipV2OptionT *>(value) : nullptr;
  }
  ClippedReluOptionT *AsClippedReluOption() {
    return type == OpOption_ClippedReluOption ?
      reinterpret_cast<ClippedReluOptionT *>(value) : nullptr;
  }
  const ClippedReluOptionT *AsClippedReluOption() const {
    return type == OpOption_ClippedReluOption ?
      reinterpret_cast<const ClippedReluOptionT *>(value) : nullptr;
  }
  EluOptionT *AsEluOption() {
    return type == OpOption_EluOption ?
      reinterpret_cast<EluOptionT *>(value) : nullptr;
  }
  const EluOptionT *AsEluOption() const {
    return type == OpOption_EluOption ?
      reinterpret_cast<const EluOptionT *>(value) : nullptr;
  }
  ExpOptionT *AsExpOption() {
    return type == OpOption_ExpOption ?
      reinterpret_cast<ExpOptionT *>(value) : nullptr;
  }
  const ExpOptionT *AsExpOption() const {
    return type == OpOption_ExpOption ?
      reinterpret_cast<const ExpOptionT *>(value) : nullptr;
  }
  GeluTanhOptionT *AsGeluTanhOption() {
    return type == OpOption_GeluTanhOption ?
      reinterpret_cast<GeluTanhOptionT *>(value) : nullptr;
  }
  const GeluTanhOptionT *AsGeluTanhOption() const {
    return type == OpOption_GeluTanhOption ?
      reinterpret_cast<const GeluTanhOptionT *>(value) : nullptr;
  }
  HardSigmoidOptionT *AsHardSigmoidOption() {
    return type == OpOption_HardSigmoidOption ?
      reinterpret_cast<HardSigmoidOptionT *>(value) : nullptr;
  }
  const HardSigmoidOptionT *AsHardSigmoidOption() const {
    return type == OpOption_HardSigmoidOption ?
      reinterpret_cast<const HardSigmoidOptionT *>(value) : nullptr;
  }
  HardSwishOptionT *AsHardSwishOption() {
    return type == OpOption_HardSwishOption ?
      reinterpret_cast<HardSwishOptionT *>(value) : nullptr;
  }
  const HardSwishOptionT *AsHardSwishOption() const {
    return type == OpOption_HardSwishOption ?
      reinterpret_cast<const HardSwishOptionT *>(value) : nullptr;
  }
  LeakyReluOptionT *AsLeakyReluOption() {
    return type == OpOption_LeakyReluOption ?
      reinterpret_cast<LeakyReluOptionT *>(value) : nullptr;
  }
  const LeakyReluOptionT *AsLeakyReluOption() const {
    return type == OpOption_LeakyReluOption ?
      reinterpret_cast<const LeakyReluOptionT *>(value) : nullptr;
  }
  LinearOptionT *AsLinearOption() {
    return type == OpOption_LinearOption ?
      reinterpret_cast<LinearOptionT *>(value) : nullptr;
  }
  const LinearOptionT *AsLinearOption() const {
    return type == OpOption_LinearOption ?
      reinterpret_cast<const LinearOptionT *>(value) : nullptr;
  }
  LogOptionT *AsLogOption() {
    return type == OpOption_LogOption ?
      reinterpret_cast<LogOptionT *>(value) : nullptr;
  }
  const LogOptionT *AsLogOption() const {
    return type == OpOption_LogOption ?
      reinterpret_cast<const LogOptionT *>(value) : nullptr;
  }
  LogisticOptionT *AsLogisticOption() {
    return type == OpOption_LogisticOption ?
      reinterpret_cast<LogisticOptionT *>(value) : nullptr;
  }
  const LogisticOptionT *AsLogisticOption() const {
    return type == OpOption_LogisticOption ?
      reinterpret_cast<const LogisticOptionT *>(value) : nullptr;
  }
  LogSigmoidOptionT *AsLogSigmoidOption() {
    return type == OpOption_LogSigmoidOption ?
      reinterpret_cast<LogSigmoidOptionT *>(value) : nullptr;
  }
  const LogSigmoidOptionT *AsLogSigmoidOption() const {
    return type == OpOption_LogSigmoidOption ?
      reinterpret_cast<const LogSigmoidOptionT *>(value) : nullptr;
  }
  MishOptionT *AsMishOption() {
    return type == OpOption_MishOption ?
      reinterpret_cast<MishOptionT *>(value) : nullptr;
  }
  const MishOptionT *AsMishOption() const {
    return type == OpOption_MishOption ?
      reinterpret_cast<const MishOptionT *>(value) : nullptr;
  }
  PowOptionT *AsPowOption() {
    return type == OpOption_PowOption ?
      reinterpret_cast<PowOptionT *>(value) : nullptr;
  }
  const PowOptionT *AsPowOption() const {
    return type == OpOption_PowOption ?
      reinterpret_cast<const PowOptionT *>(value) : nullptr;
  }
  PReluOptionT *AsPReluOption() {
    return type == OpOption_PReluOption ?
      reinterpret_cast<PReluOptionT *>(value) : nullptr;
  }
  const PReluOptionT *AsPReluOption() const {
    return type == OpOption_PReluOption ?
      reinterpret_cast<const PReluOptionT *>(value) : nullptr;
  }
  ReluOptionT *AsReluOption() {
    return type == OpOption_ReluOption ?
      reinterpret_cast<ReluOptionT *>(value) : nullptr;
  }
  const ReluOptionT *AsReluOption() const {
    return type == OpOption_ReluOption ?
      reinterpret_cast<const ReluOptionT *>(value) : nullptr;
  }
  Relu6OptionT *AsRelu6Option() {
    return type == OpOption_Relu6Option ?
      reinterpret_cast<Relu6OptionT *>(value) : nullptr;
  }
  const Relu6OptionT *AsRelu6Option() const {
    return type == OpOption_Relu6Option ?
      reinterpret_cast<const Relu6OptionT *>(value) : nullptr;
  }
  RoundOptionT *AsRoundOption() {
    return type == OpOption_RoundOption ?
      reinterpret_cast<RoundOptionT *>(value) : nullptr;
  }
  const RoundOptionT *AsRoundOption() const {
    return type == OpOption_RoundOption ?
      reinterpret_cast<const RoundOptionT *>(value) : nullptr;
  }
  SeluOptionT *AsSeluOption() {
    return type == OpOption_SeluOption ?
      reinterpret_cast<SeluOptionT *>(value) : nullptr;
  }
  const SeluOptionT *AsSeluOption() const {
    return type == OpOption_SeluOption ?
      reinterpret_cast<const SeluOptionT *>(value) : nullptr;
  }
  SigmoidOptionT *AsSigmoidOption() {
    return type == OpOption_SigmoidOption ?
      reinterpret_cast<SigmoidOptionT *>(value) : nullptr;
  }
  const SigmoidOptionT *AsSigmoidOption() const {
    return type == OpOption_SigmoidOption ?
      reinterpret_cast<const SigmoidOptionT *>(value) : nullptr;
  }
  SoftReluOptionT *AsSoftReluOption() {
    return type == OpOption_SoftReluOption ?
      reinterpret_cast<SoftReluOptionT *>(value) : nullptr;
  }
  const SoftReluOptionT *AsSoftReluOption() const {
    return type == OpOption_SoftReluOption ?
      reinterpret_cast<const SoftReluOptionT *>(value) : nullptr;
  }
  SoftReluV2OptionT *AsSoftReluV2Option() {
    return type == OpOption_SoftReluV2Option ?
      reinterpret_cast<SoftReluV2OptionT *>(value) : nullptr;
  }
  const SoftReluV2OptionT *AsSoftReluV2Option() const {
    return type == OpOption_SoftReluV2Option ?
      reinterpret_cast<const SoftReluV2OptionT *>(value) : nullptr;
  }
  SqrtOptionT *AsSqrtOption() {
    return type == OpOption_SqrtOption ?
      reinterpret_cast<SqrtOptionT *>(value) : nullptr;
  }
  const SqrtOptionT *AsSqrtOption() const {
    return type == OpOption_SqrtOption ?
      reinterpret_cast<const SqrtOptionT *>(value) : nullptr;
  }
  SwishOptionT *AsSwishOption() {
    return type == OpOption_SwishOption ?
      reinterpret_cast<SwishOptionT *>(value) : nullptr;
  }
  const SwishOptionT *AsSwishOption() const {
    return type == OpOption_SwishOption ?
      reinterpret_cast<const SwishOptionT *>(value) : nullptr;
  }
  TanhOptionT *AsTanhOption() {
    return type == OpOption_TanhOption ?
      reinterpret_cast<TanhOptionT *>(value) : nullptr;
  }
  const TanhOptionT *AsTanhOption() const {
    return type == OpOption_TanhOption ?
      reinterpret_cast<const TanhOptionT *>(value) : nullptr;
  }
  AddOptionT *AsAddOption() {
    return type == OpOption_AddOption ?
      reinterpret_cast<AddOptionT *>(value) : nullptr;
  }
  const AddOptionT *AsAddOption() const {
    return type == OpOption_AddOption ?
      reinterpret_cast<const AddOptionT *>(value) : nullptr;
  }
  MulOptionT *AsMulOption() {
    return type == OpOption_MulOption ?
      reinterpret_cast<MulOptionT *>(value) : nullptr;
  }
  const MulOptionT *AsMulOption() const {
    return type == OpOption_MulOption ?
      reinterpret_cast<const MulOptionT *>(value) : nullptr;
  }
  MinOptionT *AsMinOption() {
    return type == OpOption_MinOption ?
      reinterpret_cast<MinOptionT *>(value) : nullptr;
  }
  const MinOptionT *AsMinOption() const {
    return type == OpOption_MinOption ?
      reinterpret_cast<const MinOptionT *>(value) : nullptr;
  }
  MaxOptionT *AsMaxOption() {
    return type == OpOption_MaxOption ?
      reinterpret_cast<MaxOptionT *>(value) : nullptr;
  }
  const MaxOptionT *AsMaxOption() const {
    return type == OpOption_MaxOption ?
      reinterpret_cast<const MaxOptionT *>(value) : nullptr;
  }
  MeanOptionT *AsMeanOption() {
    return type == OpOption_MeanOption ?
      reinterpret_cast<MeanOptionT *>(value) : nullptr;
  }
  const MeanOptionT *AsMeanOption() const {
    return type == OpOption_MeanOption ?
      reinterpret_cast<const MeanOptionT *>(value) : nullptr;
  }
  DivOptionT *AsDivOption() {
    return type == OpOption_DivOption ?
      reinterpret_cast<DivOptionT *>(value) : nullptr;
  }
  const DivOptionT *AsDivOption() const {
    return type == OpOption_DivOption ?
      reinterpret_cast<const DivOptionT *>(value) : nullptr;
  }
  GreaterEqualOptionT *AsGreaterEqualOption() {
    return type == OpOption_GreaterEqualOption ?
      reinterpret_cast<GreaterEqualOptionT *>(value) : nullptr;
  }
  const GreaterEqualOptionT *AsGreaterEqualOption() const {
    return type == OpOption_GreaterEqualOption ?
      reinterpret_cast<const GreaterEqualOptionT *>(value) : nullptr;
  }
  GreaterThanOptionT *AsGreaterThanOption() {
    return type == OpOption_GreaterThanOption ?
      reinterpret_cast<GreaterThanOptionT *>(value) : nullptr;
  }
  const GreaterThanOptionT *AsGreaterThanOption() const {
    return type == OpOption_GreaterThanOption ?
      reinterpret_cast<const GreaterThanOptionT *>(value) : nullptr;
  }
  LessEqualOptionT *AsLessEqualOption() {
    return type == OpOption_LessEqualOption ?
      reinterpret_cast<LessEqualOptionT *>(value) : nullptr;
  }
  const LessEqualOptionT *AsLessEqualOption() const {
    return type == OpOption_LessEqualOption ?
      reinterpret_cast<const LessEqualOptionT *>(value) : nullptr;
  }
  LessThanOptionT *AsLessThanOption() {
    return type == OpOption_LessThanOption ?
      reinterpret_cast<LessThanOptionT *>(value) : nullptr;
  }
  const LessThanOptionT *AsLessThanOption() const {
    return type == OpOption_LessThanOption ?
      reinterpret_cast<const LessThanOptionT *>(value) : nullptr;
  }
  EqualToOptionT *AsEqualToOption() {
    return type == OpOption_EqualToOption ?
      reinterpret_cast<EqualToOptionT *>(value) : nullptr;
  }
  const EqualToOptionT *AsEqualToOption() const {
    return type == OpOption_EqualToOption ?
      reinterpret_cast<const EqualToOptionT *>(value) : nullptr;
  }
  NotEqualOptionT *AsNotEqualOption() {
    return type == OpOption_NotEqualOption ?
      reinterpret_cast<NotEqualOptionT *>(value) : nullptr;
  }
  const NotEqualOptionT *AsNotEqualOption() const {
    return type == OpOption_NotEqualOption ?
      reinterpret_cast<const NotEqualOptionT *>(value) : nullptr;
  }
  ReduceMinOptionT *AsReduceMinOption() {
    return type == OpOption_ReduceMinOption ?
      reinterpret_cast<ReduceMinOptionT *>(value) : nullptr;
  }
  const ReduceMinOptionT *AsReduceMinOption() const {
    return type == OpOption_ReduceMinOption ?
      reinterpret_cast<const ReduceMinOptionT *>(value) : nullptr;
  }
  ReduceMaxOptionT *AsReduceMaxOption() {
    return type == OpOption_ReduceMaxOption ?
      reinterpret_cast<ReduceMaxOptionT *>(value) : nullptr;
  }
  const ReduceMaxOptionT *AsReduceMaxOption() const {
    return type == OpOption_ReduceMaxOption ?
      reinterpret_cast<const ReduceMaxOptionT *>(value) : nullptr;
  }
  ReduceMeanOptionT *AsReduceMeanOption() {
    return type == OpOption_ReduceMeanOption ?
      reinterpret_cast<ReduceMeanOptionT *>(value) : nullptr;
  }
  const ReduceMeanOptionT *AsReduceMeanOption() const {
    return type == OpOption_ReduceMeanOption ?
      reinterpret_cast<const ReduceMeanOptionT *>(value) : nullptr;
  }
  ReduceSumOptionT *AsReduceSumOption() {
    return type == OpOption_ReduceSumOption ?
      reinterpret_cast<ReduceSumOptionT *>(value) : nullptr;
  }
  const ReduceSumOptionT *AsReduceSumOption() const {
    return type == OpOption_ReduceSumOption ?
      reinterpret_cast<const ReduceSumOptionT *>(value) : nullptr;
  }
  ReduceMulOptionT *AsReduceMulOption() {
    return type == OpOption_ReduceMulOption ?
      reinterpret_cast<ReduceMulOptionT *>(value) : nullptr;
  }
  const ReduceMulOptionT *AsReduceMulOption() const {
    return type == OpOption_ReduceMulOption ?
      reinterpret_cast<const ReduceMulOptionT *>(value) : nullptr;
  }
  Pool2DOptionT *AsPool2DOption() {
    return type == OpOption_Pool2DOption ?
      reinterpret_cast<Pool2DOptionT *>(value) : nullptr;
  }
  const Pool2DOptionT *AsPool2DOption() const {
    return type == OpOption_Pool2DOption ?
      reinterpret_cast<const Pool2DOptionT *>(value) : nullptr;
  }
  Pool3DOptionT *AsPool3DOption() {
    return type == OpOption_Pool3DOption ?
      reinterpret_cast<Pool3DOptionT *>(value) : nullptr;
  }
  const Pool3DOptionT *AsPool3DOption() const {
    return type == OpOption_Pool3DOption ?
      reinterpret_cast<const Pool3DOptionT *>(value) : nullptr;
  }
  ReshapeOptionT *AsReshapeOption() {
    return type == OpOption_ReshapeOption ?
      reinterpret_cast<ReshapeOptionT *>(value) : nullptr;
  }
  const ReshapeOptionT *AsReshapeOption() const {
    return type == OpOption_ReshapeOption ?
      reinterpret_cast<const ReshapeOptionT *>(value) : nullptr;
  }
  SliceOptionT *AsSliceOption() {
    return type == OpOption_SliceOption ?
      reinterpret_cast<SliceOptionT *>(value) : nullptr;
  }
  const SliceOptionT *AsSliceOption() const {
    return type == OpOption_SliceOption ?
      reinterpret_cast<const SliceOptionT *>(value) : nullptr;
  }
  FlattenOptionT *AsFlattenOption() {
    return type == OpOption_FlattenOption ?
      reinterpret_cast<FlattenOptionT *>(value) : nullptr;
  }
  const FlattenOptionT *AsFlattenOption() const {
    return type == OpOption_FlattenOption ?
      reinterpret_cast<const FlattenOptionT *>(value) : nullptr;
  }
  PermuteOptionT *AsPermuteOption() {
    return type == OpOption_PermuteOption ?
      reinterpret_cast<PermuteOptionT *>(value) : nullptr;
  }
  const PermuteOptionT *AsPermuteOption() const {
    return type == OpOption_PermuteOption ?
      reinterpret_cast<const PermuteOptionT *>(value) : nullptr;
  }
  ArgMaxOptionT *AsArgMaxOption() {
    return type == OpOption_ArgMaxOption ?
      reinterpret_cast<ArgMaxOptionT *>(value) : nullptr;
  }
  const ArgMaxOptionT *AsArgMaxOption() const {
    return type == OpOption_ArgMaxOption ?
      reinterpret_cast<const ArgMaxOptionT *>(value) : nullptr;
  }
  BatchNormOptionT *AsBatchNormOption() {
    return type == OpOption_BatchNormOption ?
      reinterpret_cast<BatchNormOptionT *>(value) : nullptr;
  }
  const BatchNormOptionT *AsBatchNormOption() const {
    return type == OpOption_BatchNormOption ?
      reinterpret_cast<const BatchNormOptionT *>(value) : nullptr;
  }
  Conv2DOptionT *AsConv2DOption() {
    return type == OpOption_Conv2DOption ?
      reinterpret_cast<Conv2DOptionT *>(value) : nullptr;
  }
  const Conv2DOptionT *AsConv2DOption() const {
    return type == OpOption_Conv2DOption ?
      reinterpret_cast<const Conv2DOptionT *>(value) : nullptr;
  }
  Conv3DOptionT *AsConv3DOption() {
    return type == OpOption_Conv3DOption ?
      reinterpret_cast<Conv3DOptionT *>(value) : nullptr;
  }
  const Conv3DOptionT *AsConv3DOption() const {
    return type == OpOption_Conv3DOption ?
      reinterpret_cast<const Conv3DOptionT *>(value) : nullptr;
  }
  InnerProductOptionT *AsInnerProductOption() {
    return type == OpOption_InnerProductOption ?
      reinterpret_cast<InnerProductOptionT *>(value) : nullptr;
  }
  const InnerProductOptionT *AsInnerProductOption() const {
    return type == OpOption_InnerProductOption ?
      reinterpret_cast<const InnerProductOptionT *>(value) : nullptr;
  }
  LRNOptionT *AsLRNOption() {
    return type == OpOption_LRNOption ?
      reinterpret_cast<LRNOptionT *>(value) : nullptr;
  }
  const LRNOptionT *AsLRNOption() const {
    return type == OpOption_LRNOption ?
      reinterpret_cast<const LRNOptionT *>(value) : nullptr;
  }
  NormalizeOptionT *AsNormalizeOption() {
    return type == OpOption_NormalizeOption ?
      reinterpret_cast<NormalizeOptionT *>(value) : nullptr;
  }
  const NormalizeOptionT *AsNormalizeOption() const {
    return type == OpOption_NormalizeOption ?
      reinterpret_cast<const NormalizeOptionT *>(value) : nullptr;
  }
  PriorBoxOptionT *AsPriorBoxOption() {
    return type == OpOption_PriorBoxOption ?
      reinterpret_cast<PriorBoxOptionT *>(value) : nullptr;
  }
  const PriorBoxOptionT *AsPriorBoxOption() const {
    return type == OpOption_PriorBoxOption ?
      reinterpret_cast<const PriorBoxOptionT *>(value) : nullptr;
  }
  ProposalOptionT *AsProposalOption() {
    return type == OpOption_ProposalOption ?
      reinterpret_cast<ProposalOptionT *>(value) : nullptr;
  }
  const ProposalOptionT *AsProposalOption() const {
    return type == OpOption_ProposalOption ?
      reinterpret_cast<const ProposalOptionT *>(value) : nullptr;
  }
  ResizeOptionT *AsResizeOption() {
    return type == OpOption_ResizeOption ?
      reinterpret_cast<ResizeOptionT *>(value) : nullptr;
  }
  const ResizeOptionT *AsResizeOption() const {
    return type == OpOption_ResizeOption ?
      reinterpret_cast<const ResizeOptionT *>(value) : nullptr;
  }
  RoiPoolingOptionT *AsRoiPoolingOption() {
    return type == OpOption_RoiPoolingOption ?
      reinterpret_cast<RoiPoolingOptionT *>(value) : nullptr;
  }
  const RoiPoolingOptionT *AsRoiPoolingOption() const {
    return type == OpOption_RoiPoolingOption ?
      reinterpret_cast<const RoiPoolingOptionT *>(value) : nullptr;
  }
  ScaleOptionT *AsScaleOption() {
    return type == OpOption_ScaleOption ?
      reinterpret_cast<ScaleOptionT *>(value) : nullptr;
  }
  const ScaleOptionT *AsScaleOption() const {
    return type == OpOption_ScaleOption ?
      reinterpret_cast<const ScaleOptionT *>(value) : nullptr;
  }
  SoftmaxOptionT *AsSoftmaxOption() {
    return type == OpOption_SoftmaxOption ?
      reinterpret_cast<SoftmaxOptionT *>(value) : nullptr;
  }
  const SoftmaxOptionT *AsSoftmaxOption() const {
    return type == OpOption_SoftmaxOption ?
      reinterpret_cast<const SoftmaxOptionT *>(value) : nullptr;
  }
  InputOptionT *AsInputOption() {
    return type == OpOption_InputOption ?
      reinterpret_cast<InputOptionT *>(value) : nullptr;
  }
  const InputOptionT *AsInputOption() const {
    return type == OpOption_InputOption ?
      reinterpret_cast<const InputOptionT *>(value) : nullptr;
  }
};

bool VerifyOpOption(flatbuffers::Verifier &verifier, const void *obj, OpOption type);
bool VerifyOpOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AbsOptionT : public flatbuffers::NativeTable {
  typedef AbsOption TableType;
  AbsOptionT() {
  }
};

struct AbsOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AbsOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionBuilder &operator=(const AbsOptionBuilder &);
  flatbuffers::Offset<AbsOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOption> CreateAbsOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsOption> CreateAbsOption(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BoundedReluOptionT : public flatbuffers::NativeTable {
  typedef BoundedReluOption TableType;
  BoundedReluOptionT() {
  }
};

struct BoundedReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoundedReluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BoundedReluOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BoundedReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoundedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BoundedReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoundedReluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BoundedReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoundedReluOptionBuilder &operator=(const BoundedReluOptionBuilder &);
  flatbuffers::Offset<BoundedReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoundedReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoundedReluOption> CreateBoundedReluOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BoundedReluOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BoundedReluOption> CreateBoundedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClipOptionT : public flatbuffers::NativeTable {
  typedef ClipOption TableType;
  ClipOptionT() {
  }
};

struct ClipOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClipOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ClipOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClipOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClipOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClipOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClipOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClipOptionBuilder &operator=(const ClipOptionBuilder &);
  flatbuffers::Offset<ClipOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClipOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClipOption> CreateClipOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClipOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ClipOption> CreateClipOption(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClipV2OptionT : public flatbuffers::NativeTable {
  typedef ClipV2Option TableType;
  ClipV2OptionT() {
  }
};

struct ClipV2Option FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipV2OptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClipV2OptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ClipV2OptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClipV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClipV2Option> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClipV2OptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClipV2OptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClipV2OptionBuilder &operator=(const ClipV2OptionBuilder &);
  flatbuffers::Offset<ClipV2Option> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClipV2Option>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClipV2Option> CreateClipV2Option(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClipV2OptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ClipV2Option> CreateClipV2Option(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EluOptionT : public flatbuffers::NativeTable {
  typedef EluOption TableType;
  float alpha;
  EluOptionT()
      : alpha(1.0f) {
  }
};

struct EluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EluOptionTypeTable();
  }
  float alpha() const {
    return GetField<float>(4, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  EluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(4, alpha, 1.0f);
  }
  explicit EluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EluOptionBuilder &operator=(const EluOptionBuilder &);
  flatbuffers::Offset<EluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<EluOption> CreateEluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 1.0f) {
  EluOptionBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<EluOption> CreateEluOption(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionT : public flatbuffers::NativeTable {
  typedef ExpOption TableType;
  ExpOptionT() {
  }
};

struct ExpOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionBuilder &operator=(const ExpOptionBuilder &);
  flatbuffers::Offset<ExpOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOption> CreateExpOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpOption> CreateExpOption(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeluTanhOptionT : public flatbuffers::NativeTable {
  typedef GeluTanhOption TableType;
  GeluTanhOptionT() {
  }
};

struct GeluTanhOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeluTanhOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeluTanhOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GeluTanhOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeluTanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeluTanhOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeluTanhOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GeluTanhOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeluTanhOptionBuilder &operator=(const GeluTanhOptionBuilder &);
  flatbuffers::Offset<GeluTanhOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeluTanhOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeluTanhOption> CreateGeluTanhOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GeluTanhOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GeluTanhOption> CreateGeluTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSigmoidOptionT : public flatbuffers::NativeTable {
  typedef HardSigmoidOption TableType;
  HardSigmoidOptionT() {
  }
};

struct HardSigmoidOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardSigmoidOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HardSigmoidOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSigmoidOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSigmoidOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSigmoidOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSigmoidOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HardSigmoidOptionBuilder &operator=(const HardSigmoidOptionBuilder &);
  flatbuffers::Offset<HardSigmoidOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSigmoidOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSigmoidOption> CreateHardSigmoidOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSigmoidOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSigmoidOption> CreateHardSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionT : public flatbuffers::NativeTable {
  typedef HardSwishOption TableType;
  HardSwishOptionT() {
  }
};

struct HardSwishOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardSwishOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HardSwishOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSwishOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSwishOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HardSwishOptionBuilder &operator=(const HardSwishOptionBuilder &);
  flatbuffers::Offset<HardSwishOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOption> CreateHardSwishOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSwishOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSwishOption> CreateHardSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LinearOptionT : public flatbuffers::NativeTable {
  typedef LinearOption TableType;
  LinearOptionT() {
  }
};

struct LinearOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinearOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LinearOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LinearOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LinearOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LinearOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LinearOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LinearOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LinearOptionBuilder &operator=(const LinearOptionBuilder &);
  flatbuffers::Offset<LinearOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinearOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LinearOption> CreateLinearOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LinearOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LinearOption> CreateLinearOption(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogOptionT : public flatbuffers::NativeTable {
  typedef LogOption TableType;
  LogOptionT() {
  }
};

struct LogOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogOptionBuilder &operator=(const LogOptionBuilder &);
  flatbuffers::Offset<LogOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogOption> CreateLogOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogOption> CreateLogOption(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogisticOptionT : public flatbuffers::NativeTable {
  typedef LogisticOption TableType;
  LogisticOptionT() {
  }
};

struct LogisticOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogisticOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogisticOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogisticOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogisticOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogisticOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogisticOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogisticOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogisticOptionBuilder &operator=(const LogisticOptionBuilder &);
  flatbuffers::Offset<LogisticOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogisticOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogisticOption> CreateLogisticOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogisticOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogisticOption> CreateLogisticOption(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MishOptionT : public flatbuffers::NativeTable {
  typedef MishOption TableType;
  MishOptionT() {
  }
};

struct MishOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MishOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MishOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MishOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MishOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MishOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MishOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MishOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MishOptionBuilder &operator=(const MishOptionBuilder &);
  flatbuffers::Offset<MishOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MishOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MishOption> CreateMishOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MishOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MishOption> CreateMishOption(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionT : public flatbuffers::NativeTable {
  typedef PowOption TableType;
  PowOptionT() {
  }
};

struct PowOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PowOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionBuilder &operator=(const PowOptionBuilder &);
  flatbuffers::Offset<PowOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOption> CreatePowOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PowOption> CreatePowOption(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReluOptionT : public flatbuffers::NativeTable {
  typedef PReluOption TableType;
  int32_t slopeCount;
  std::vector<float> slope;
  PReluOptionT()
      : slopeCount(0) {
  }
};

struct PReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReluOptionTypeTable();
  }
  int32_t slopeCount() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slopeCount(int32_t slopeCount) {
    fbb_.AddElement<int32_t>(4, slopeCount, 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(6, slope);
  }
  explicit PReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PReluOptionBuilder &operator=(const PReluOptionBuilder &);
  flatbuffers::Offset<PReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReluOption> CreatePReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReluOptionBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slopeCount(slopeCount);
  return builder_.Finish();
}

flatbuffers::Offset<PReluOption> CreatePReluOption(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReluOptionT : public flatbuffers::NativeTable {
  typedef ReluOption TableType;
  float slope;
  ReluOptionT()
      : slope(0.0f) {
  }
};

struct ReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReluOptionTypeTable();
  }
  float slope() const {
    return GetField<float>(4, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  ReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(4, slope, 0.0f);
  }
  explicit ReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluOptionBuilder &operator=(const ReluOptionBuilder &);
  flatbuffers::Offset<ReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReluOption> CreateReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluOptionBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<ReluOption> CreateReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Relu6OptionT : public flatbuffers::NativeTable {
  typedef Relu6Option TableType;
  float minval;
  float maxval;
  Relu6OptionT()
      : minval(0.0f),
        maxval(6.0f) {
  }
};

struct Relu6Option FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Relu6OptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Relu6OptionTypeTable();
  }
  float minval() const {
    return GetField<float>(4, 0.0f);
  }
  float maxval() const {
    return GetField<float>(6, 6.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           verifier.EndTable();
  }
  Relu6OptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Relu6OptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu6Option> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Relu6OptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minval(float minval) {
    fbb_.AddElement<float>(4, minval, 0.0f);
  }
  void add_maxval(float maxval) {
    fbb_.AddElement<float>(6, maxval, 6.0f);
  }
  explicit Relu6OptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Relu6OptionBuilder &operator=(const Relu6OptionBuilder &);
  flatbuffers::Offset<Relu6Option> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu6Option>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu6Option> CreateRelu6Option(
    flatbuffers::FlatBufferBuilder &_fbb,
    float minval = 0.0f,
    float maxval = 6.0f) {
  Relu6OptionBuilder builder_(_fbb);
  builder_.add_maxval(maxval);
  builder_.add_minval(minval);
  return builder_.Finish();
}

flatbuffers::Offset<Relu6Option> CreateRelu6Option(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClippedReluOptionT : public flatbuffers::NativeTable {
  typedef ClippedReluOption TableType;
  float threashod;
  ClippedReluOptionT()
      : threashod(0.0f) {
  }
};

struct ClippedReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClippedReluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClippedReluOptionTypeTable();
  }
  float threashod() const {
    return GetField<float>(4, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  ClippedReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClippedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClippedReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClippedReluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_threashod(float threashod) {
    fbb_.AddElement<float>(4, threashod, 0.0f);
  }
  explicit ClippedReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClippedReluOptionBuilder &operator=(const ClippedReluOptionBuilder &);
  flatbuffers::Offset<ClippedReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClippedReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClippedReluOption> CreateClippedReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float threashod = 0.0f) {
  ClippedReluOptionBuilder builder_(_fbb);
  builder_.add_threashod(threashod);
  return builder_.Finish();
}

flatbuffers::Offset<ClippedReluOption> CreateClippedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionT : public flatbuffers::NativeTable {
  typedef LeakyReluOption TableType;
  float negative_slope;
  LeakyReluOptionT()
      : negative_slope(0.01f) {
  }
};

struct LeakyReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LeakyReluOptionTypeTable();
  }
  float negative_slope() const {
    return GetField<float>(4, 0.01f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           verifier.EndTable();
  }
  LeakyReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negative_slope(float negative_slope) {
    fbb_.AddElement<float>(4, negative_slope, 0.01f);
  }
  explicit LeakyReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionBuilder &operator=(const LeakyReluOptionBuilder &);
  flatbuffers::Offset<LeakyReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOption> CreateLeakyReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negative_slope = 0.01f) {
  LeakyReluOptionBuilder builder_(_fbb);
  builder_.add_negative_slope(negative_slope);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOption> CreateLeakyReluOption(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSigmoidOptionT : public flatbuffers::NativeTable {
  typedef LogSigmoidOption TableType;
  LogSigmoidOptionT() {
  }
};

struct LogSigmoidOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogSigmoidOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogSigmoidOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogSigmoidOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSigmoidOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSigmoidOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSigmoidOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSigmoidOptionBuilder &operator=(const LogSigmoidOptionBuilder &);
  flatbuffers::Offset<LogSigmoidOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSigmoidOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSigmoidOption> CreateLogSigmoidOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSigmoidOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogSigmoidOption> CreateLogSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoundOptionT : public flatbuffers::NativeTable {
  typedef RoundOption TableType;
  RoundOptionT() {
  }
};

struct RoundOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoundOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoundOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RoundOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoundOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoundOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoundOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoundOptionBuilder &operator=(const RoundOptionBuilder &);
  flatbuffers::Offset<RoundOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoundOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoundOption> CreateRoundOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RoundOption> CreateRoundOption(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SeluOptionT : public flatbuffers::NativeTable {
  typedef SeluOption TableType;
  float scale;
  float alpha;
  SeluOptionT()
      : scale(1.050700f),
        alpha(1.673263f) {
  }
};

struct SeluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SeluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SeluOptionTypeTable();
  }
  float scale() const {
    return GetField<float>(4, 1.050700f);
  }
  float alpha() const {
    return GetField<float>(6, 1.673263f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           verifier.EndTable();
  }
  SeluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SeluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SeluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SeluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(4, scale, 1.050700f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(6, alpha, 1.673263f);
  }
  explicit SeluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeluOptionBuilder &operator=(const SeluOptionBuilder &);
  flatbuffers::Offset<SeluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeluOption> CreateSeluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 1.050700f,
    float alpha = 1.673263f) {
  SeluOptionBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<SeluOption> CreateSeluOption(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidOptionT : public flatbuffers::NativeTable {
  typedef SigmoidOption TableType;
  SigmoidOptionT() {
  }
};

struct SigmoidOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SigmoidOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SigmoidOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SigmoidOptionBuilder &operator=(const SigmoidOptionBuilder &);
  flatbuffers::Offset<SigmoidOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidOption> CreateSigmoidOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidOption> CreateSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftReluOptionT : public flatbuffers::NativeTable {
  typedef SoftReluOption TableType;
  SoftReluOptionT() {
  }
};

struct SoftReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftReluOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftReluOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SoftReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftReluOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftReluOptionBuilder &operator=(const SoftReluOptionBuilder &);
  flatbuffers::Offset<SoftReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftReluOption> CreateSoftReluOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftReluOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SoftReluOption> CreateSoftReluOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftReluV2OptionT : public flatbuffers::NativeTable {
  typedef SoftReluV2Option TableType;
  SoftReluV2OptionT() {
  }
};

struct SoftReluV2Option FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftReluV2OptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftReluV2OptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SoftReluV2OptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftReluV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftReluV2Option> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftReluV2OptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftReluV2OptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftReluV2OptionBuilder &operator=(const SoftReluV2OptionBuilder &);
  flatbuffers::Offset<SoftReluV2Option> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftReluV2Option>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftReluV2Option> CreateSoftReluV2Option(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftReluV2OptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SoftReluV2Option> CreateSoftReluV2Option(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqrtOptionT : public flatbuffers::NativeTable {
  typedef SqrtOption TableType;
  SqrtOptionT() {
  }
};

struct SqrtOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqrtOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SqrtOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqrtOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqrtOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqrtOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqrtOptionBuilder &operator=(const SqrtOptionBuilder &);
  flatbuffers::Offset<SqrtOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqrtOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqrtOption> CreateSqrtOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SqrtOption> CreateSqrtOption(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwishOptionT : public flatbuffers::NativeTable {
  typedef SwishOption TableType;
  SwishOptionT() {
  }
};

struct SwishOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwishOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SwishOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SwishOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SwishOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwishOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwishOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SwishOptionBuilder &operator=(const SwishOptionBuilder &);
  flatbuffers::Offset<SwishOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SwishOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SwishOption> CreateSwishOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwishOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SwishOption> CreateSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TanhOptionT : public flatbuffers::NativeTable {
  typedef TanhOption TableType;
  TanhOptionT() {
  }
};

struct TanhOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TanhOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TanhOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TanhOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TanhOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TanhOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TanhOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TanhOptionBuilder &operator=(const TanhOptionBuilder &);
  flatbuffers::Offset<TanhOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TanhOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<TanhOption> CreateTanhOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TanhOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TanhOption> CreateTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstOptionT : public flatbuffers::NativeTable {
  typedef ConstOption TableType;
  std::unique_ptr<TensorT> tensor;
  ConstOptionT() {
  }
};

struct ConstOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConstOptionTypeTable();
  }
  const Tensor *tensor() const {
    return GetPointer<const Tensor *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyTable(tensor()) &&
           verifier.EndTable();
  }
  ConstOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConstOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<Tensor> tensor) {
    fbb_.AddOffset(4, tensor);
  }
  explicit ConstOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstOptionBuilder &operator=(const ConstOptionBuilder &);
  flatbuffers::Offset<ConstOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstOption> CreateConstOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> tensor = 0) {
  ConstOptionBuilder builder_(_fbb);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

flatbuffers::Offset<ConstOption> CreateConstOption(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NoneElementwiseOptionT : public flatbuffers::NativeTable {
  typedef NoneElementwiseOption TableType;
  NoneElementwiseOptionT() {
  }
};

struct NoneElementwiseOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NoneElementwiseOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NoneElementwiseOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NoneElementwiseOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NoneElementwiseOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NoneElementwiseOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NoneElementwiseOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NoneElementwiseOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NoneElementwiseOptionBuilder &operator=(const NoneElementwiseOptionBuilder &);
  flatbuffers::Offset<NoneElementwiseOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoneElementwiseOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<NoneElementwiseOption> CreateNoneElementwiseOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NoneElementwiseOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NoneElementwiseOption> CreateNoneElementwiseOption(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionT : public flatbuffers::NativeTable {
  typedef AddOption TableType;
  AddOptionT() {
  }
};

struct AddOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionBuilder &operator=(const AddOptionBuilder &);
  flatbuffers::Offset<AddOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOption> CreateAddOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddOption> CreateAddOption(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionT : public flatbuffers::NativeTable {
  typedef MulOption TableType;
  MulOptionT() {
  }
};

struct MulOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MulOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionBuilder &operator=(const MulOptionBuilder &);
  flatbuffers::Offset<MulOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOption> CreateMulOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MulOption> CreateMulOption(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinOptionT : public flatbuffers::NativeTable {
  typedef MinOption TableType;
  MinOptionT() {
  }
};

struct MinOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MinOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinOptionBuilder &operator=(const MinOptionBuilder &);
  flatbuffers::Offset<MinOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MinOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MinOption> CreateMinOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MinOption> CreateMinOption(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaxOptionT : public flatbuffers::NativeTable {
  typedef MaxOption TableType;
  MaxOptionT() {
  }
};

struct MaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaxOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaxOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaxOptionBuilder &operator=(const MaxOptionBuilder &);
  flatbuffers::Offset<MaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxOption> CreateMaxOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaxOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaxOption> CreateMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeanOptionT : public flatbuffers::NativeTable {
  typedef MeanOption TableType;
  MeanOptionT() {
  }
};

struct MeanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeanOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MeanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MeanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeanOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MeanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeanOptionBuilder &operator=(const MeanOptionBuilder &);
  flatbuffers::Offset<MeanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeanOption> CreateMeanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MeanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MeanOption> CreateMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionT : public flatbuffers::NativeTable {
  typedef DivOption TableType;
  DivOptionT() {
  }
};

struct DivOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DivOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionBuilder &operator=(const DivOptionBuilder &);
  flatbuffers::Offset<DivOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOption> CreateDivOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DivOption> CreateDivOption(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionT : public flatbuffers::NativeTable {
  typedef GreaterEqualOption TableType;
  GreaterEqualOptionT() {
  }
};

struct GreaterEqualOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterEqualOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqualOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionBuilder &operator=(const GreaterEqualOptionBuilder &);
  flatbuffers::Offset<GreaterEqualOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOption> CreateGreaterEqualOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOption> CreateGreaterEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterThanOptionT : public flatbuffers::NativeTable {
  typedef GreaterThanOption TableType;
  GreaterThanOptionT() {
  }
};

struct GreaterThanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterThanOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterThanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterThanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterThanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterThanOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterThanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterThanOptionBuilder &operator=(const GreaterThanOptionBuilder &);
  flatbuffers::Offset<GreaterThanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterThanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterThanOption> CreateGreaterThanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterThanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterThanOption> CreateGreaterThanOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionT : public flatbuffers::NativeTable {
  typedef LessEqualOption TableType;
  LessEqualOptionT() {
  }
};

struct LessEqualOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessEqualOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqualOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionBuilder &operator=(const LessEqualOptionBuilder &);
  flatbuffers::Offset<LessEqualOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOption> CreateLessEqualOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqualOption> CreateLessEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessThanOptionT : public flatbuffers::NativeTable {
  typedef LessThanOption TableType;
  LessThanOptionT() {
  }
};

struct LessThanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessThanOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessThanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessThanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessThanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessThanOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessThanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessThanOptionBuilder &operator=(const LessThanOptionBuilder &);
  flatbuffers::Offset<LessThanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessThanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessThanOption> CreateLessThanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessThanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessThanOption> CreateLessThanOption(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualToOptionT : public flatbuffers::NativeTable {
  typedef EqualToOption TableType;
  EqualToOptionT() {
  }
};

struct EqualToOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualToOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EqualToOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualToOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualToOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EqualToOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualToOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualToOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualToOptionBuilder &operator=(const EqualToOptionBuilder &);
  flatbuffers::Offset<EqualToOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualToOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualToOption> CreateEqualToOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualToOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EqualToOption> CreateEqualToOption(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionT : public flatbuffers::NativeTable {
  typedef NotEqualOption TableType;
  NotEqualOptionT() {
  }
};

struct NotEqualOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NotEqualOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqualOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionBuilder &operator=(const NotEqualOptionBuilder &);
  flatbuffers::Offset<NotEqualOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOption> CreateNotEqualOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqualOption> CreateNotEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMinOptionT : public flatbuffers::NativeTable {
  typedef ReduceMinOption TableType;
  ReduceMinOptionT() {
  }
};

struct ReduceMinOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMinOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMinOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMinOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMinOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMinOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMinOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMinOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceMinOptionBuilder &operator=(const ReduceMinOptionBuilder &);
  flatbuffers::Offset<ReduceMinOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMinOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMinOption> CreateReduceMinOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMinOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMinOption> CreateReduceMinOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMaxOptionT : public flatbuffers::NativeTable {
  typedef ReduceMaxOption TableType;
  ReduceMaxOptionT() {
  }
};

struct ReduceMaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMaxOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMaxOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMaxOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceMaxOptionBuilder &operator=(const ReduceMaxOptionBuilder &);
  flatbuffers::Offset<ReduceMaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMaxOption> CreateReduceMaxOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMaxOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMaxOption> CreateReduceMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMeanOptionT : public flatbuffers::NativeTable {
  typedef ReduceMeanOption TableType;
  ReduceMeanOptionT() {
  }
};

struct ReduceMeanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMeanOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMeanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMeanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMeanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMeanOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMeanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceMeanOptionBuilder &operator=(const ReduceMeanOptionBuilder &);
  flatbuffers::Offset<ReduceMeanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMeanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMeanOption> CreateReduceMeanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMeanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMeanOption> CreateReduceMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceSumOptionT : public flatbuffers::NativeTable {
  typedef ReduceSumOption TableType;
  ReduceSumOptionT() {
  }
};

struct ReduceSumOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceSumOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceSumOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceSumOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceSumOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceSumOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceSumOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceSumOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceSumOptionBuilder &operator=(const ReduceSumOptionBuilder &);
  flatbuffers::Offset<ReduceSumOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceSumOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceSumOption> CreateReduceSumOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceSumOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceSumOption> CreateReduceSumOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMulOptionT : public flatbuffers::NativeTable {
  typedef ReduceMulOption TableType;
  ReduceMulOptionT() {
  }
};

struct ReduceMulOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMulOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMulOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMulOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMulOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMulOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMulOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMulOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceMulOptionBuilder &operator=(const ReduceMulOptionBuilder &);
  flatbuffers::Offset<ReduceMulOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMulOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMulOption> CreateReduceMulOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMulOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMulOption> CreateReduceMulOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionT : public flatbuffers::NativeTable {
  typedef Pool2DOption TableType;
  std::vector<int32_t> size;
  PoolType type;
  std::vector<int32_t> strides;
  std::vector<int32_t> padding;
  PaddingType padtype;
  bool global_pooling;
  bool ceil_mode;
  bool exclusive;
  Pool2DOptionT()
      : type(PoolType_MAX_POOL),
        padtype(PaddingType_VALID),
        global_pooling(false),
        ceil_mode(false),
        exclusive(true) {
  }
};

struct Pool2DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool2DOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool2DOptionTypeTable();
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  PoolType type() const {
    return static_cast<PoolType>(GetField<int8_t>(6, 0));
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<int32_t> *padding() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(10);
  }
  PaddingType padtype() const {
    return static_cast<PaddingType>(GetField<int8_t>(12, 0));
  }
  bool global_pooling() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  bool ceil_mode() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  bool exclusive() const {
    return GetField<uint8_t>(18, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(size()) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(padding()) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           VerifyField<uint8_t>(verifier, 18) &&
           verifier.EndTable();
  }
  Pool2DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool2DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(4, size);
  }
  void add_type(PoolType type) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(type), 0);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(8, strides);
  }
  void add_padding(flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding) {
    fbb_.AddOffset(10, padding);
  }
  void add_padtype(PaddingType padtype) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(padtype), 0);
  }
  void add_global_pooling(bool global_pooling) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(global_pooling), 0);
  }
  void add_ceil_mode(bool ceil_mode) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(ceil_mode), 0);
  }
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(18, static_cast<uint8_t>(exclusive), 1);
  }
  explicit Pool2DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionBuilder &operator=(const Pool2DOptionBuilder &);
  flatbuffers::Offset<Pool2DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOption> CreatePool2DOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    PoolType type = PoolType_MAX_POOL,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding = 0,
    PaddingType padtype = PaddingType_VALID,
    bool global_pooling = false,
    bool ceil_mode = false,
    bool exclusive = true) {
  Pool2DOptionBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_strides(strides);
  builder_.add_size(size);
  builder_.add_exclusive(exclusive);
  builder_.add_ceil_mode(ceil_mode);
  builder_.add_global_pooling(global_pooling);
  builder_.add_padtype(padtype);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Pool2DOption> CreatePool2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool3DOptionT : public flatbuffers::NativeTable {
  typedef Pool3DOption TableType;
  Pool3DOptionT() {
  }
};

struct Pool3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool3DOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool3DOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Pool3DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool3DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool3DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Pool3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool3DOptionBuilder &operator=(const Pool3DOptionBuilder &);
  flatbuffers::Offset<Pool3DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool3DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool3DOption> CreatePool3DOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Pool3DOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Pool3DOption> CreatePool3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionT : public flatbuffers::NativeTable {
  typedef ReshapeOption TableType;
  std::vector<int32_t> dims;
  DataFormat dimType;
  ReshapeOptionT()
      : dimType(DataFormat_NONE) {
  }
};

struct ReshapeOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeOptionTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  DataFormat dimType() const {
    return static_cast<DataFormat>(GetField<int8_t>(6, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, 6) &&
           verifier.EndTable();
  }
  ReshapeOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(4, dims);
  }
  void add_dimType(DataFormat dimType) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(dimType), 0);
  }
  explicit ReshapeOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionBuilder &operator=(const ReshapeOptionBuilder &);
  flatbuffers::Offset<ReshapeOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOption> CreateReshapeOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    DataFormat dimType = DataFormat_NONE) {
  ReshapeOptionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimType(dimType);
  return builder_.Finish();
}

flatbuffers::Offset<ReshapeOption> CreateReshapeOption(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionT : public flatbuffers::NativeTable {
  typedef SliceOption TableType;
  int32_t axis;
  std::vector<int32_t> slicePoints;
  FrontendFramework sourceType;
  SliceOptionT()
      : axis(0),
        sourceType(FrontendFramework_NONE) {
  }
};

struct SliceOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceOptionTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<int32_t> *slicePoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  FrontendFramework sourceType() const {
    return static_cast<FrontendFramework>(GetField<int8_t>(8, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(slicePoints()) &&
           VerifyField<int8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  SliceOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  void add_slicePoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints) {
    fbb_.AddOffset(6, slicePoints);
  }
  void add_sourceType(FrontendFramework sourceType) {
    fbb_.AddElement<int8_t>(8, static_cast<int8_t>(sourceType), 0);
  }
  explicit SliceOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionBuilder &operator=(const SliceOptionBuilder &);
  flatbuffers::Offset<SliceOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOption> CreateSliceOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints = 0,
    FrontendFramework sourceType = FrontendFramework_NONE) {
  SliceOptionBuilder builder_(_fbb);
  builder_.add_slicePoints(slicePoints);
  builder_.add_axis(axis);
  builder_.add_sourceType(sourceType);
  return builder_.Finish();
}

flatbuffers::Offset<SliceOption> CreateSliceOption(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenOptionT : public flatbuffers::NativeTable {
  typedef FlattenOption TableType;
  int32_t axis;
  int32_t endAxis;
  FlattenOptionT()
      : axis(0),
        endAxis(0) {
  }
};

struct FlattenOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenOptionTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t endAxis() const {
    return GetField<int32_t>(6, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           verifier.EndTable();
  }
  FlattenOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlattenOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  void add_endAxis(int32_t endAxis) {
    fbb_.AddElement<int32_t>(6, endAxis, 0);
  }
  explicit FlattenOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenOptionBuilder &operator=(const FlattenOptionBuilder &);
  flatbuffers::Offset<FlattenOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenOption> CreateFlattenOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t endAxis = 0) {
  FlattenOptionBuilder builder_(_fbb);
  builder_.add_endAxis(endAxis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<FlattenOption> CreateFlattenOption(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteOptionT : public flatbuffers::NativeTable {
  typedef PermuteOption TableType;
  std::vector<int32_t> dims;
  PermuteOptionT() {
  }
};

struct PermuteOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PermuteOptionTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  PermuteOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PermuteOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(4, dims);
  }
  explicit PermuteOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PermuteOptionBuilder &operator=(const PermuteOptionBuilder &);
  flatbuffers::Offset<PermuteOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PermuteOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PermuteOption> CreatePermuteOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  PermuteOptionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

flatbuffers::Offset<PermuteOption> CreatePermuteOption(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionT : public flatbuffers::NativeTable {
  typedef ArgMaxOption TableType;
  int32_t outMaxVal;
  int32_t topK;
  int32_t axis;
  int32_t softmaxThreshold;
  ArgMaxOptionT()
      : outMaxVal(0),
        topK(0),
        axis(0),
        softmaxThreshold(0) {
  }
};

struct ArgMaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxOptionTypeTable();
  }
  int32_t outMaxVal() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t softmaxThreshold() const {
    return GetField<int32_t>(10, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           verifier.EndTable();
  }
  ArgMaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outMaxVal(int32_t outMaxVal) {
    fbb_.AddElement<int32_t>(4, outMaxVal, 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(6, topK, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(8, axis, 0);
  }
  void add_softmaxThreshold(int32_t softmaxThreshold) {
    fbb_.AddElement<int32_t>(10, softmaxThreshold, 0);
  }
  explicit ArgMaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionBuilder &operator=(const ArgMaxOptionBuilder &);
  flatbuffers::Offset<ArgMaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOption> CreateArgMaxOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outMaxVal = 0,
    int32_t topK = 0,
    int32_t axis = 0,
    int32_t softmaxThreshold = 0) {
  ArgMaxOptionBuilder builder_(_fbb);
  builder_.add_softmaxThreshold(softmaxThreshold);
  builder_.add_axis(axis);
  builder_.add_topK(topK);
  builder_.add_outMaxVal(outMaxVal);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOption> CreateArgMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormOptionT : public flatbuffers::NativeTable {
  typedef BatchNormOption TableType;
  int32_t channels;
  std::vector<float> slopeData;
  std::vector<float> meanData;
  std::vector<float> varData;
  std::vector<float> biasData;
  std::vector<float> Adata;
  std::vector<float> Bdata;
  float epsilon;
  BatchNormOptionT()
      : channels(0),
        epsilon(0.001f) {
  }
};

struct BatchNormOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormOptionTypeTable();
  }
  int32_t channels() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<float> *slopeData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *meanData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<float> *varData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(12);
  }
  const flatbuffers::Vector<float> *Adata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(14);
  }
  const flatbuffers::Vector<float> *Bdata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(16);
  }
  float epsilon() const {
    return GetField<float>(18, 0.001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(slopeData()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(meanData()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(varData()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, 14) &&
           verifier.VerifyVector(Adata()) &&
           VerifyOffset(verifier, 16) &&
           verifier.VerifyVector(Bdata()) &&
           VerifyField<float>(verifier, 18) &&
           verifier.EndTable();
  }
  BatchNormOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNormOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(4, channels, 0);
  }
  void add_slopeData(flatbuffers::Offset<flatbuffers::Vector<float>> slopeData) {
    fbb_.AddOffset(6, slopeData);
  }
  void add_meanData(flatbuffers::Offset<flatbuffers::Vector<float>> meanData) {
    fbb_.AddOffset(8, meanData);
  }
  void add_varData(flatbuffers::Offset<flatbuffers::Vector<float>> varData) {
    fbb_.AddOffset(10, varData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(12, biasData);
  }
  void add_Adata(flatbuffers::Offset<flatbuffers::Vector<float>> Adata) {
    fbb_.AddOffset(14, Adata);
  }
  void add_Bdata(flatbuffers::Offset<flatbuffers::Vector<float>> Bdata) {
    fbb_.AddOffset(16, Bdata);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(18, epsilon, 0.001f);
  }
  explicit BatchNormOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchNormOptionBuilder &operator=(const BatchNormOptionBuilder &);
  flatbuffers::Offset<BatchNormOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormOption> CreateBatchNormOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slopeData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> meanData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> varData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Adata = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Bdata = 0,
    float epsilon = 0.001f) {
  BatchNormOptionBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_Bdata(Bdata);
  builder_.add_Adata(Adata);
  builder_.add_biasData(biasData);
  builder_.add_varData(varData);
  builder_.add_meanData(meanData);
  builder_.add_slopeData(slopeData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

flatbuffers::Offset<BatchNormOption> CreateBatchNormOption(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionT : public flatbuffers::NativeTable {
  typedef Conv2DOption TableType;
  int32_t padX;
  int32_t padY;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  int32_t dilateX;
  int32_t dilateY;
  PadMode padMode;
  int32_t group;
  int32_t outputCount;
  int32_t inputCount;
  bool relu;
  bool relu6;
  std::vector<int32_t> pads;
  std::vector<int32_t> outPads;
  bool hasOutputShape;
  Conv2DOptionT()
      : padX(0),
        padY(0),
        kernelX(1),
        kernelY(1),
        strideX(1),
        strideY(1),
        dilateX(1),
        dilateY(1),
        padMode(PadMode_CAFFE),
        group(1),
        outputCount(0),
        inputCount(0),
        relu(false),
        relu6(false),
        hasOutputShape(false) {
  }
};

struct Conv2DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DOptionTypeTable();
  }
  int32_t padX() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(8, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(10, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(12, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(14, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(16, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(18, 1);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(20, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(22, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(24, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(26, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(28, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(30, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(32);
  }
  const flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(34);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(36, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<int32_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           VerifyField<int8_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyField<int32_t>(verifier, 24) &&
           VerifyField<int32_t>(verifier, 26) &&
           VerifyField<uint8_t>(verifier, 28) &&
           VerifyField<uint8_t>(verifier, 30) &&
           VerifyOffset(verifier, 32) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, 34) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, 36) &&
           verifier.EndTable();
  }
  Conv2DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(4, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(6, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(8, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(10, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(12, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(14, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(16, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(18, dilateY, 1);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(20, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(22, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(24, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(26, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(28, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(30, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(32, pads);
  }
  void add_outPads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(34, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(36, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Conv2DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionBuilder &operator=(const Conv2DOptionBuilder &);
  flatbuffers::Offset<Conv2DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOption> CreateConv2DOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    PadMode padMode = PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Conv2DOptionBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_pads(pads);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2DOption> CreateConv2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv3DOptionT : public flatbuffers::NativeTable {
  typedef Conv3DOption TableType;
  std::vector<int32_t> dilates;
  std::vector<int32_t> strides;
  std::vector<int32_t> kernels;
  std::vector<int32_t> pads;
  PadMode padMode;
  int32_t inputCount;
  int32_t outputCount;
  bool relu;
  bool relu6;
  Conv3DOptionT()
      : padMode(PadMode_CAFFE),
        inputCount(0),
        outputCount(0),
        relu(false),
        relu6(false) {
  }
};

struct Conv3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv3DOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv3DOptionTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dilates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(6);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(8);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(10);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(12, 0));
  }
  int32_t inputCount() const {
    return GetField<int32_t>(14, 0);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(16, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(18, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(20, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dilates()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<uint8_t>(verifier, 18) &&
           VerifyField<uint8_t>(verifier, 20) &&
           verifier.EndTable();
  }
  Conv3DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv3DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv3DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dilates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates) {
    fbb_.AddOffset(4, dilates);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(6, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(8, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(10, pads);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(12, static_cast<int8_t>(padMode), 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(14, inputCount, 0);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(16, outputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(18, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(20, static_cast<uint8_t>(relu6), 0);
  }
  explicit Conv3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv3DOptionBuilder &operator=(const Conv3DOptionBuilder &);
  flatbuffers::Offset<Conv3DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOption> CreateConv3DOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    PadMode padMode = PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false) {
  Conv3DOptionBuilder builder_(_fbb);
  builder_.add_outputCount(outputCount);
  builder_.add_inputCount(inputCount);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_dilates(dilates);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Conv3DOption> CreateConv3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InnerProductOptionT : public flatbuffers::NativeTable {
  typedef InnerProductOption TableType;
  int32_t outputCount;
  int32_t biasTerm;
  int32_t weightSize;
  std::vector<float> weight;
  std::vector<float> bias;
  int32_t axis;
  bool transpose;
  InnerProductOptionT()
      : outputCount(0),
        biasTerm(0),
        weightSize(0),
        axis(0),
        transpose(false) {
  }
};

struct InnerProductOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InnerProductOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InnerProductOptionTypeTable();
  }
  int32_t outputCount() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(8, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(12);
  }
  int32_t axis() const {
    return GetField<int32_t>(14, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(16, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, 12) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, 14) &&
           VerifyField<uint8_t>(verifier, 16) &&
           verifier.EndTable();
  }
  InnerProductOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InnerProductOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InnerProductOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InnerProductOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(4, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(6, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(8, weightSize, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(10, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(12, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(14, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(16, static_cast<uint8_t>(transpose), 0);
  }
  explicit InnerProductOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InnerProductOptionBuilder &operator=(const InnerProductOptionBuilder &);
  flatbuffers::Offset<InnerProductOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InnerProductOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<InnerProductOption> CreateInnerProductOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false) {
  InnerProductOptionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

flatbuffers::Offset<InnerProductOption> CreateInnerProductOption(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNOptionT : public flatbuffers::NativeTable {
  typedef LRNOption TableType;
  int32_t regionType;
  int32_t localSize;
  float alpha;
  float beta;
  LRNOptionT()
      : regionType(0),
        localSize(0),
        alpha(0.0f),
        beta(0.0f) {
  }
};

struct LRNOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNOptionTypeTable();
  }
  int32_t regionType() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t localSize() const {
    return GetField<int32_t>(6, 0);
  }
  float alpha() const {
    return GetField<float>(8, 0.0f);
  }
  float beta() const {
    return GetField<float>(10, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyField<float>(verifier, 10) &&
           verifier.EndTable();
  }
  LRNOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRNOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regionType(int32_t regionType) {
    fbb_.AddElement<int32_t>(4, regionType, 0);
  }
  void add_localSize(int32_t localSize) {
    fbb_.AddElement<int32_t>(6, localSize, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(8, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(10, beta, 0.0f);
  }
  explicit LRNOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LRNOptionBuilder &operator=(const LRNOptionBuilder &);
  flatbuffers::Offset<LRNOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRNOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRNOption> CreateLRNOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t regionType = 0,
    int32_t localSize = 0,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LRNOptionBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_localSize(localSize);
  builder_.add_regionType(regionType);
  return builder_.Finish();
}

flatbuffers::Offset<LRNOption> CreateLRNOption(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizeOptionT : public flatbuffers::NativeTable {
  typedef NormalizeOption TableType;
  int32_t acrossSpatial;
  int32_t channelShared;
  float eps;
  std::vector<float> scale;
  NormalizeOptionT()
      : acrossSpatial(0),
        channelShared(0),
        eps(0.0f) {
  }
};

struct NormalizeOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizeOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NormalizeOptionTypeTable();
  }
  int32_t acrossSpatial() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t channelShared() const {
    return GetField<int32_t>(6, 0);
  }
  float eps() const {
    return GetField<float>(8, 0.0f);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
  NormalizeOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormalizeOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizeOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acrossSpatial(int32_t acrossSpatial) {
    fbb_.AddElement<int32_t>(4, acrossSpatial, 0);
  }
  void add_channelShared(int32_t channelShared) {
    fbb_.AddElement<int32_t>(6, channelShared, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(8, eps, 0.0f);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(10, scale);
  }
  explicit NormalizeOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalizeOptionBuilder &operator=(const NormalizeOptionBuilder &);
  flatbuffers::Offset<NormalizeOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormalizeOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<NormalizeOption> CreateNormalizeOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  NormalizeOptionBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_eps(eps);
  builder_.add_channelShared(channelShared);
  builder_.add_acrossSpatial(acrossSpatial);
  return builder_.Finish();
}

flatbuffers::Offset<NormalizeOption> CreateNormalizeOption(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxOptionT : public flatbuffers::NativeTable {
  typedef PriorBoxOption TableType;
  std::vector<float> minSizes;
  std::vector<float> maxSizes;
  std::vector<float> aspectRatios;
  std::vector<float> variances;
  bool flip;
  bool clip;
  int32_t imageWidth;
  int32_t imageHeight;
  int32_t stepWidth;
  int32_t stepHeight;
  float offset;
  PriorBoxOptionT()
      : flip(false),
        clip(false),
        imageWidth(0),
        imageHeight(0),
        stepWidth(0),
        stepHeight(0),
        offset(0.0f) {
  }
};

struct PriorBoxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxOptionTypeTable();
  }
  const flatbuffers::Vector<float> *minSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(4);
  }
  const flatbuffers::Vector<float> *maxSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *aspectRatios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(10);
  }
  bool flip() const {
    return GetField<uint8_t>(12, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(14, 0) != 0;
  }
  int32_t imageWidth() const {
    return GetField<int32_t>(16, 0);
  }
  int32_t imageHeight() const {
    return GetField<int32_t>(18, 0);
  }
  int32_t stepWidth() const {
    return GetField<int32_t>(20, 0);
  }
  int32_t stepHeight() const {
    return GetField<int32_t>(22, 0);
  }
  float offset() const {
    return GetField<float>(24, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(minSizes()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(maxSizes()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(aspectRatios()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint8_t>(verifier, 12) &&
           VerifyField<uint8_t>(verifier, 14) &&
           VerifyField<int32_t>(verifier, 16) &&
           VerifyField<int32_t>(verifier, 18) &&
           VerifyField<int32_t>(verifier, 20) &&
           VerifyField<int32_t>(verifier, 22) &&
           VerifyField<float>(verifier, 24) &&
           verifier.EndTable();
  }
  PriorBoxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBoxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minSizes(flatbuffers::Offset<flatbuffers::Vector<float>> minSizes) {
    fbb_.AddOffset(4, minSizes);
  }
  void add_maxSizes(flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes) {
    fbb_.AddOffset(6, maxSizes);
  }
  void add_aspectRatios(flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios) {
    fbb_.AddOffset(8, aspectRatios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(10, variances);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(12, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(14, static_cast<uint8_t>(clip), 0);
  }
  void add_imageWidth(int32_t imageWidth) {
    fbb_.AddElement<int32_t>(16, imageWidth, 0);
  }
  void add_imageHeight(int32_t imageHeight) {
    fbb_.AddElement<int32_t>(18, imageHeight, 0);
  }
  void add_stepWidth(int32_t stepWidth) {
    fbb_.AddElement<int32_t>(20, stepWidth, 0);
  }
  void add_stepHeight(int32_t stepHeight) {
    fbb_.AddElement<int32_t>(22, stepHeight, 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(24, offset, 0.0f);
  }
  explicit PriorBoxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PriorBoxOptionBuilder &operator=(const PriorBoxOptionBuilder &);
  flatbuffers::Offset<PriorBoxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBoxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> minSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  PriorBoxOptionBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_stepHeight(stepHeight);
  builder_.add_stepWidth(stepWidth);
  builder_.add_imageHeight(imageHeight);
  builder_.add_imageWidth(imageWidth);
  builder_.add_variances(variances);
  builder_.add_aspectRatios(aspectRatios);
  builder_.add_maxSizes(maxSizes);
  builder_.add_minSizes(minSizes);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOption(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalOptionT : public flatbuffers::NativeTable {
  typedef ProposalOption TableType;
  int32_t featStride;
  int32_t baseSize;
  int32_t preNmsTopN;
  int32_t afterNmsTopN;
  float nmsThreshold;
  int32_t minSize;
  ProposalOptionT()
      : featStride(0),
        baseSize(0),
        preNmsTopN(0),
        afterNmsTopN(0),
        nmsThreshold(0.0f),
        minSize(0) {
  }
};

struct ProposalOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProposalOptionTypeTable();
  }
  int32_t featStride() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t baseSize() const {
    return GetField<int32_t>(6, 0);
  }
  int32_t preNmsTopN() const {
    return GetField<int32_t>(8, 0);
  }
  int32_t afterNmsTopN() const {
    return GetField<int32_t>(10, 0);
  }
  float nmsThreshold() const {
    return GetField<float>(12, 0.0f);
  }
  int32_t minSize() const {
    return GetField<int32_t>(14, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<int32_t>(verifier, 8) &&
           VerifyField<int32_t>(verifier, 10) &&
           VerifyField<float>(verifier, 12) &&
           VerifyField<int32_t>(verifier, 14) &&
           verifier.EndTable();
  }
  ProposalOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProposalOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_featStride(int32_t featStride) {
    fbb_.AddElement<int32_t>(4, featStride, 0);
  }
  void add_baseSize(int32_t baseSize) {
    fbb_.AddElement<int32_t>(6, baseSize, 0);
  }
  void add_preNmsTopN(int32_t preNmsTopN) {
    fbb_.AddElement<int32_t>(8, preNmsTopN, 0);
  }
  void add_afterNmsTopN(int32_t afterNmsTopN) {
    fbb_.AddElement<int32_t>(10, afterNmsTopN, 0);
  }
  void add_nmsThreshold(float nmsThreshold) {
    fbb_.AddElement<float>(12, nmsThreshold, 0.0f);
  }
  void add_minSize(int32_t minSize) {
    fbb_.AddElement<int32_t>(14, minSize, 0);
  }
  explicit ProposalOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalOptionBuilder &operator=(const ProposalOptionBuilder &);
  flatbuffers::Offset<ProposalOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProposalOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalOption> CreateProposalOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featStride = 0,
    int32_t baseSize = 0,
    int32_t preNmsTopN = 0,
    int32_t afterNmsTopN = 0,
    float nmsThreshold = 0.0f,
    int32_t minSize = 0) {
  ProposalOptionBuilder builder_(_fbb);
  builder_.add_minSize(minSize);
  builder_.add_nmsThreshold(nmsThreshold);
  builder_.add_afterNmsTopN(afterNmsTopN);
  builder_.add_preNmsTopN(preNmsTopN);
  builder_.add_baseSize(baseSize);
  builder_.add_featStride(featStride);
  return builder_.Finish();
}

flatbuffers::Offset<ProposalOption> CreateProposalOption(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeOptionT : public flatbuffers::NativeTable {
  typedef ResizeOption TableType;
  float xScale;
  float yScale;
  ResizeOptionT()
      : xScale(0.0f),
        yScale(0.0f) {
  }
};

struct ResizeOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeOptionTypeTable();
  }
  float xScale() const {
    return GetField<float>(4, 0.0f);
  }
  float yScale() const {
    return GetField<float>(6, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4) &&
           VerifyField<float>(verifier, 6) &&
           verifier.EndTable();
  }
  ResizeOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(4, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(6, yScale, 0.0f);
  }
  explicit ResizeOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeOptionBuilder &operator=(const ResizeOptionBuilder &);
  flatbuffers::Offset<ResizeOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeOption> CreateResizeOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float xScale = 0.0f,
    float yScale = 0.0f) {
  ResizeOptionBuilder builder_(_fbb);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeOption> CreateResizeOption(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoiPoolingOptionT : public flatbuffers::NativeTable {
  typedef RoiPoolingOption TableType;
  int32_t pooledWidth;
  int32_t pooledHeight;
  float spatialScale;
  RoiPoolingOptionT()
      : pooledWidth(0),
        pooledHeight(0),
        spatialScale(0.0f) {
  }
};

struct RoiPoolingOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoiPoolingOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoiPoolingOptionTypeTable();
  }
  int32_t pooledWidth() const {
    return GetField<int32_t>(4, 0);
  }
  int32_t pooledHeight() const {
    return GetField<int32_t>(6, 0);
  }
  float spatialScale() const {
    return GetField<float>(8, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyField<int32_t>(verifier, 6) &&
           VerifyField<float>(verifier, 8) &&
           verifier.EndTable();
  }
  RoiPoolingOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoiPoolingOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoiPoolingOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoiPoolingOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledWidth(int32_t pooledWidth) {
    fbb_.AddElement<int32_t>(4, pooledWidth, 0);
  }
  void add_pooledHeight(int32_t pooledHeight) {
    fbb_.AddElement<int32_t>(6, pooledHeight, 0);
  }
  void add_spatialScale(float spatialScale) {
    fbb_.AddElement<float>(8, spatialScale, 0.0f);
  }
  explicit RoiPoolingOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoiPoolingOptionBuilder &operator=(const RoiPoolingOptionBuilder &);
  flatbuffers::Offset<RoiPoolingOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoiPoolingOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoiPoolingOption> CreateRoiPoolingOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledWidth = 0,
    int32_t pooledHeight = 0,
    float spatialScale = 0.0f) {
  RoiPoolingOptionBuilder builder_(_fbb);
  builder_.add_spatialScale(spatialScale);
  builder_.add_pooledHeight(pooledHeight);
  builder_.add_pooledWidth(pooledWidth);
  return builder_.Finish();
}

flatbuffers::Offset<RoiPoolingOption> CreateRoiPoolingOption(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleOptionT : public flatbuffers::NativeTable {
  typedef ScaleOption TableType;
  int32_t channels;
  std::vector<float> scaleData;
  std::vector<float> biasData;
  ScaleOptionT()
      : channels(0) {
  }
};

struct ScaleOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleOptionTypeTable();
  }
  int32_t channels() const {
    return GetField<int32_t>(4, 0);
  }
  const flatbuffers::Vector<float> *scaleData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(6);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(8);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyVector(scaleData()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(biasData()) &&
           verifier.EndTable();
  }
  ScaleOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScaleOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(4, channels, 0);
  }
  void add_scaleData(flatbuffers::Offset<flatbuffers::Vector<float>> scaleData) {
    fbb_.AddOffset(6, scaleData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(8, biasData);
  }
  explicit ScaleOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScaleOptionBuilder &operator=(const ScaleOptionBuilder &);
  flatbuffers::Offset<ScaleOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScaleOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScaleOption> CreateScaleOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scaleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0) {
  ScaleOptionBuilder builder_(_fbb);
  builder_.add_biasData(biasData);
  builder_.add_scaleData(scaleData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

flatbuffers::Offset<ScaleOption> CreateScaleOption(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionT : public flatbuffers::NativeTable {
  typedef SoftmaxOption TableType;
  int32_t axis;
  SoftmaxOptionT()
      : axis(0) {
  }
};

struct SoftmaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxOptionTypeTable();
  }
  int32_t axis() const {
    return GetField<int32_t>(4, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4) &&
           verifier.EndTable();
  }
  SoftmaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(4, axis, 0);
  }
  explicit SoftmaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionBuilder &operator=(const SoftmaxOptionBuilder &);
  flatbuffers::Offset<SoftmaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOption> CreateSoftmaxOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  SoftmaxOptionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOption> CreateSoftmaxOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputOptionT : public flatbuffers::NativeTable {
  typedef InputOption TableType;
  std::vector<int32_t> dims;
  DataType dtype;
  DataFormat dformat;
  InputOptionT()
      : dtype(DataType_NONE),
        dformat(DataFormat_NONE) {
  }
};

struct InputOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputOptionTypeTable();
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(4);
  }
  DataType dtype() const {
    return static_cast<DataType>(GetField<int8_t>(6, 0));
  }
  DataFormat dformat() const {
    return static_cast<DataFormat>(GetField<int8_t>(8, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, 6) &&
           VerifyField<int8_t>(verifier, 8) &&
           verifier.EndTable();
  }
  InputOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(4, dims);
  }
  void add_dtype(DataType dtype) {
    fbb_.AddElement<int8_t>(6, static_cast<int8_t>(dtype), 0);
  }
  void add_dformat(DataFormat dformat) {
    fbb_.AddElement<int8_t>(8, static_cast<int8_t>(dformat), 0);
  }
  explicit InputOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputOptionBuilder &operator=(const InputOptionBuilder &);
  flatbuffers::Offset<InputOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputOption> CreateInputOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    DataType dtype = DataType_NONE,
    DataFormat dformat = DataFormat_NONE) {
  InputOptionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

flatbuffers::Offset<InputOption> CreateInputOption(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DefaultOptionT : public flatbuffers::NativeTable {
  typedef DefaultOption TableType;
  std::string type;
  std::string engine;
  std::vector<int8_t> info;
  std::vector<std::unique_ptr<AttributeT>> attr;
  DefaultOptionT() {
  }
};

struct DefaultOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DefaultOptionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DefaultOptionTypeTable();
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(4);
  }
  const flatbuffers::String *engine() const {
    return GetPointer<const flatbuffers::String *>(6);
  }
  const flatbuffers::Vector<int8_t> *info() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(8);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *>(10);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, 4) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, 6) &&
           verifier.VerifyString(engine()) &&
           VerifyOffset(verifier, 8) &&
           verifier.VerifyVector(info()) &&
           VerifyOffset(verifier, 10) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  DefaultOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DefaultOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DefaultOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DefaultOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(4, type);
  }
  void add_engine(flatbuffers::Offset<flatbuffers::String> engine) {
    fbb_.AddOffset(6, engine);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<int8_t>> info) {
    fbb_.AddOffset(8, info);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attr) {
    fbb_.AddOffset(10, attr);
  }
  explicit DefaultOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DefaultOptionBuilder &operator=(const DefaultOptionBuilder &);
  flatbuffers::Offset<DefaultOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DefaultOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<DefaultOption> CreateDefaultOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> engine = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attr = 0) {
  DefaultOptionBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_info(info);
  builder_.add_engine(engine);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<DefaultOption> CreateDefaultOption(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AbsOptionT *AbsOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AbsOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AbsOption::UnPackTo(AbsOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsOption> AbsOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOption> CreateAbsOption(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateAbsOption(
      _fbb);
}

inline BoundedReluOptionT *BoundedReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BoundedReluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BoundedReluOption::UnPackTo(BoundedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BoundedReluOption> BoundedReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoundedReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BoundedReluOption> CreateBoundedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BoundedReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateBoundedReluOption(
      _fbb);
}

inline ClipOptionT *ClipOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ClipOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ClipOption::UnPackTo(ClipOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ClipOption> ClipOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClipOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClipOption> CreateClipOption(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateClipOption(
      _fbb);
}

inline ClipV2OptionT *ClipV2Option::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ClipV2OptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ClipV2Option::UnPackTo(ClipV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ClipV2Option> ClipV2Option::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClipV2Option(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClipV2Option> CreateClipV2Option(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipV2OptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateClipV2Option(
      _fbb);
}

inline EluOptionT *EluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EluOption::UnPackTo(EluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<EluOption> EluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EluOption> CreateEluOption(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return ace::CreateEluOption(
      _fbb,
      _alpha);
}

inline ExpOptionT *ExpOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpOption::UnPackTo(ExpOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpOption> ExpOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOption> CreateExpOption(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateExpOption(
      _fbb);
}

inline GeluTanhOptionT *GeluTanhOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GeluTanhOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GeluTanhOption::UnPackTo(GeluTanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GeluTanhOption> GeluTanhOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeluTanhOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeluTanhOption> CreateGeluTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeluTanhOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateGeluTanhOption(
      _fbb);
}

inline HardSigmoidOptionT *HardSigmoidOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HardSigmoidOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HardSigmoidOption::UnPackTo(HardSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSigmoidOption> HardSigmoidOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSigmoidOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSigmoidOption> CreateHardSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSigmoidOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateHardSigmoidOption(
      _fbb);
}

inline HardSwishOptionT *HardSwishOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HardSwishOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HardSwishOption::UnPackTo(HardSwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSwishOption> HardSwishOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSwishOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSwishOption> CreateHardSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateHardSwishOption(
      _fbb);
}

inline LinearOptionT *LinearOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LinearOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LinearOption::UnPackTo(LinearOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LinearOption> LinearOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLinearOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LinearOption> CreateLinearOption(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LinearOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLinearOption(
      _fbb);
}

inline LogOptionT *LogOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogOption::UnPackTo(LogOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogOption> LogOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogOption> CreateLogOption(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLogOption(
      _fbb);
}

inline LogisticOptionT *LogisticOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogisticOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogisticOption::UnPackTo(LogisticOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogisticOption> LogisticOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogisticOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogisticOption> CreateLogisticOption(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogisticOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLogisticOption(
      _fbb);
}

inline MishOptionT *MishOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MishOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MishOption::UnPackTo(MishOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MishOption> MishOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMishOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MishOption> CreateMishOption(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MishOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMishOption(
      _fbb);
}

inline PowOptionT *PowOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PowOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PowOption::UnPackTo(PowOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PowOption> PowOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOption> CreatePowOption(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreatePowOption(
      _fbb);
}

inline PReluOptionT *PReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PReluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PReluOption::UnPackTo(PReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slopeCount(); _o->slopeCount = _e; };
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PReluOption> PReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PReluOption> CreatePReluOption(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slopeCount = _o->slopeCount;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return ace::CreatePReluOption(
      _fbb,
      _slopeCount,
      _slope);
}

inline ReluOptionT *ReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReluOption::UnPackTo(ReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; };
}

inline flatbuffers::Offset<ReluOption> ReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReluOption> CreateReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return ace::CreateReluOption(
      _fbb,
      _slope);
}

inline Relu6OptionT *Relu6Option::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Relu6OptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Relu6Option::UnPackTo(Relu6OptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minval(); _o->minval = _e; };
  { auto _e = maxval(); _o->maxval = _e; };
}

inline flatbuffers::Offset<Relu6Option> Relu6Option::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu6Option(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu6Option> CreateRelu6Option(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Relu6OptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minval = _o->minval;
  auto _maxval = _o->maxval;
  return ace::CreateRelu6Option(
      _fbb,
      _minval,
      _maxval);
}

inline ClippedReluOptionT *ClippedReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ClippedReluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ClippedReluOption::UnPackTo(ClippedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = threashod(); _o->threashod = _e; };
}

inline flatbuffers::Offset<ClippedReluOption> ClippedReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClippedReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClippedReluOption> CreateClippedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClippedReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _threashod = _o->threashod;
  return ace::CreateClippedReluOption(
      _fbb,
      _threashod);
}

inline LeakyReluOptionT *LeakyReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LeakyReluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LeakyReluOption::UnPackTo(LeakyReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = negative_slope(); _o->negative_slope = _e; };
}

inline flatbuffers::Offset<LeakyReluOption> LeakyReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOption> CreateLeakyReluOption(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _negative_slope = _o->negative_slope;
  return ace::CreateLeakyReluOption(
      _fbb,
      _negative_slope);
}

inline LogSigmoidOptionT *LogSigmoidOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LogSigmoidOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LogSigmoidOption::UnPackTo(LogSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogSigmoidOption> LogSigmoidOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSigmoidOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSigmoidOption> CreateLogSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSigmoidOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLogSigmoidOption(
      _fbb);
}

inline RoundOptionT *RoundOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RoundOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RoundOption::UnPackTo(RoundOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RoundOption> RoundOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoundOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoundOption> CreateRoundOption(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoundOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateRoundOption(
      _fbb);
}

inline SeluOptionT *SeluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SeluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SeluOption::UnPackTo(SeluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<SeluOption> SeluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSeluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SeluOption> CreateSeluOption(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SeluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _alpha = _o->alpha;
  return ace::CreateSeluOption(
      _fbb,
      _scale,
      _alpha);
}

inline SigmoidOptionT *SigmoidOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SigmoidOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SigmoidOption::UnPackTo(SigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SigmoidOption> SigmoidOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidOption> CreateSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSigmoidOption(
      _fbb);
}

inline SoftReluOptionT *SoftReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftReluOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SoftReluOption::UnPackTo(SoftReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SoftReluOption> SoftReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftReluOption> CreateSoftReluOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSoftReluOption(
      _fbb);
}

inline SoftReluV2OptionT *SoftReluV2Option::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftReluV2OptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SoftReluV2Option::UnPackTo(SoftReluV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SoftReluV2Option> SoftReluV2Option::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftReluV2Option(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftReluV2Option> CreateSoftReluV2Option(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftReluV2OptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSoftReluV2Option(
      _fbb);
}

inline SqrtOptionT *SqrtOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SqrtOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SqrtOption::UnPackTo(SqrtOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SqrtOption> SqrtOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqrtOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqrtOption> CreateSqrtOption(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSqrtOption(
      _fbb);
}

inline SwishOptionT *SwishOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SwishOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SwishOption::UnPackTo(SwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SwishOption> SwishOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwishOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SwishOption> CreateSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwishOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSwishOption(
      _fbb);
}

inline TanhOptionT *TanhOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TanhOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TanhOption::UnPackTo(TanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TanhOption> TanhOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTanhOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TanhOption> CreateTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TanhOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateTanhOption(
      _fbb);
}

inline ConstOptionT *ConstOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConstOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ConstOption::UnPackTo(ConstOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); if (_e) _o->tensor = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ConstOption> ConstOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConstOption> CreateConstOption(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor ? CreateTensor(_fbb, _o->tensor.get(), _rehasher) : 0;
  return ace::CreateConstOption(
      _fbb,
      _tensor);
}

inline NoneElementwiseOptionT *NoneElementwiseOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NoneElementwiseOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NoneElementwiseOption::UnPackTo(NoneElementwiseOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NoneElementwiseOption> NoneElementwiseOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNoneElementwiseOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NoneElementwiseOption> CreateNoneElementwiseOption(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NoneElementwiseOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateNoneElementwiseOption(
      _fbb);
}

inline AddOptionT *AddOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddOption::UnPackTo(AddOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddOption> AddOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOption> CreateAddOption(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateAddOption(
      _fbb);
}

inline MulOptionT *MulOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MulOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MulOption::UnPackTo(MulOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MulOption> MulOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOption> CreateMulOption(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMulOption(
      _fbb);
}

inline MinOptionT *MinOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MinOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MinOption::UnPackTo(MinOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MinOption> MinOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MinOption> CreateMinOption(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMinOption(
      _fbb);
}

inline MaxOptionT *MaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MaxOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MaxOption::UnPackTo(MaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaxOption> MaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaxOption> CreateMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMaxOption(
      _fbb);
}

inline MeanOptionT *MeanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MeanOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MeanOption::UnPackTo(MeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MeanOption> MeanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeanOption> CreateMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMeanOption(
      _fbb);
}

inline DivOptionT *DivOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DivOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DivOption::UnPackTo(DivOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DivOption> DivOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOption> CreateDivOption(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateDivOption(
      _fbb);
}

inline GreaterEqualOptionT *GreaterEqualOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GreaterEqualOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GreaterEqualOption::UnPackTo(GreaterEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOption> GreaterEqualOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqualOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOption> CreateGreaterEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateGreaterEqualOption(
      _fbb);
}

inline GreaterThanOptionT *GreaterThanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GreaterThanOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GreaterThanOption::UnPackTo(GreaterThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterThanOption> GreaterThanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterThanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterThanOption> CreateGreaterThanOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterThanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateGreaterThanOption(
      _fbb);
}

inline LessEqualOptionT *LessEqualOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LessEqualOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LessEqualOption::UnPackTo(LessEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOption> LessEqualOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqualOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOption> CreateLessEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLessEqualOption(
      _fbb);
}

inline LessThanOptionT *LessThanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LessThanOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LessThanOption::UnPackTo(LessThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessThanOption> LessThanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessThanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessThanOption> CreateLessThanOption(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessThanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLessThanOption(
      _fbb);
}

inline EqualToOptionT *EqualToOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EqualToOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EqualToOption::UnPackTo(EqualToOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EqualToOption> EqualToOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqualToOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualToOption> CreateEqualToOption(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualToOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateEqualToOption(
      _fbb);
}

inline NotEqualOptionT *NotEqualOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NotEqualOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NotEqualOption::UnPackTo(NotEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOption> NotEqualOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqualOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOption> CreateNotEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateNotEqualOption(
      _fbb);
}

inline ReduceMinOptionT *ReduceMinOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceMinOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceMinOption::UnPackTo(ReduceMinOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMinOption> ReduceMinOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMinOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMinOption> CreateReduceMinOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMinOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMinOption(
      _fbb);
}

inline ReduceMaxOptionT *ReduceMaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceMaxOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceMaxOption::UnPackTo(ReduceMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMaxOption> ReduceMaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMaxOption> CreateReduceMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMaxOption(
      _fbb);
}

inline ReduceMeanOptionT *ReduceMeanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceMeanOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceMeanOption::UnPackTo(ReduceMeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMeanOption> ReduceMeanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMeanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMeanOption> CreateReduceMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMeanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMeanOption(
      _fbb);
}

inline ReduceSumOptionT *ReduceSumOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceSumOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceSumOption::UnPackTo(ReduceSumOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceSumOption> ReduceSumOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceSumOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceSumOption> CreateReduceSumOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceSumOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceSumOption(
      _fbb);
}

inline ReduceMulOptionT *ReduceMulOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceMulOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceMulOption::UnPackTo(ReduceMulOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMulOption> ReduceMulOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMulOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMulOption> CreateReduceMulOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMulOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMulOption(
      _fbb);
}

inline Pool2DOptionT *Pool2DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Pool2DOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool2DOption::UnPackTo(Pool2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } };
  { auto _e = type(); _o->type = _e; };
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
  { auto _e = padding(); if (_e) { _o->padding.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->padding[_i] = _e->Get(_i); } } };
  { auto _e = padtype(); _o->padtype = _e; };
  { auto _e = global_pooling(); _o->global_pooling = _e; };
  { auto _e = ceil_mode(); _o->ceil_mode = _e; };
  { auto _e = exclusive(); _o->exclusive = _e; };
}

inline flatbuffers::Offset<Pool2DOption> Pool2DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool2DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOption> CreatePool2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _type = _o->type;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _padding = _o->padding.size() ? _fbb.CreateVector(_o->padding) : 0;
  auto _padtype = _o->padtype;
  auto _global_pooling = _o->global_pooling;
  auto _ceil_mode = _o->ceil_mode;
  auto _exclusive = _o->exclusive;
  return ace::CreatePool2DOption(
      _fbb,
      _size,
      _type,
      _strides,
      _padding,
      _padtype,
      _global_pooling,
      _ceil_mode,
      _exclusive);
}

inline Pool3DOptionT *Pool3DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Pool3DOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pool3DOption::UnPackTo(Pool3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Pool3DOption> Pool3DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool3DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool3DOption> CreatePool3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool3DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreatePool3DOption(
      _fbb);
}

inline ReshapeOptionT *ReshapeOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReshapeOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReshapeOption::UnPackTo(ReshapeOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
  { auto _e = dimType(); _o->dimType = _e; };
}

inline flatbuffers::Offset<ReshapeOption> ReshapeOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOption> CreateReshapeOption(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dimType = _o->dimType;
  return ace::CreateReshapeOption(
      _fbb,
      _dims,
      _dimType);
}

inline SliceOptionT *SliceOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SliceOption::UnPackTo(SliceOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = slicePoints(); if (_e) { _o->slicePoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slicePoints[_i] = _e->Get(_i); } } };
  { auto _e = sourceType(); _o->sourceType = _e; };
}

inline flatbuffers::Offset<SliceOption> SliceOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOption> CreateSliceOption(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _slicePoints = _o->slicePoints.size() ? _fbb.CreateVector(_o->slicePoints) : 0;
  auto _sourceType = _o->sourceType;
  return ace::CreateSliceOption(
      _fbb,
      _axis,
      _slicePoints,
      _sourceType);
}

inline FlattenOptionT *FlattenOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FlattenOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FlattenOption::UnPackTo(FlattenOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = endAxis(); _o->endAxis = _e; };
}

inline flatbuffers::Offset<FlattenOption> FlattenOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlattenOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlattenOption> CreateFlattenOption(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _endAxis = _o->endAxis;
  return ace::CreateFlattenOption(
      _fbb,
      _axis,
      _endAxis);
}

inline PermuteOptionT *PermuteOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PermuteOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PermuteOption::UnPackTo(PermuteOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PermuteOption> PermuteOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermuteOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PermuteOption> CreatePermuteOption(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return ace::CreatePermuteOption(
      _fbb,
      _dims);
}

inline ArgMaxOptionT *ArgMaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMaxOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMaxOption::UnPackTo(ArgMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outMaxVal(); _o->outMaxVal = _e; };
  { auto _e = topK(); _o->topK = _e; };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = softmaxThreshold(); _o->softmaxThreshold = _e; };
}

inline flatbuffers::Offset<ArgMaxOption> ArgMaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOption> CreateArgMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outMaxVal = _o->outMaxVal;
  auto _topK = _o->topK;
  auto _axis = _o->axis;
  auto _softmaxThreshold = _o->softmaxThreshold;
  return ace::CreateArgMaxOption(
      _fbb,
      _outMaxVal,
      _topK,
      _axis,
      _softmaxThreshold);
}

inline BatchNormOptionT *BatchNormOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchNormOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchNormOption::UnPackTo(BatchNormOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; };
  { auto _e = slopeData(); if (_e) { _o->slopeData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slopeData[_i] = _e->Get(_i); } } };
  { auto _e = meanData(); if (_e) { _o->meanData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meanData[_i] = _e->Get(_i); } } };
  { auto _e = varData(); if (_e) { _o->varData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->varData[_i] = _e->Get(_i); } } };
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } };
  { auto _e = Adata(); if (_e) { _o->Adata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Adata[_i] = _e->Get(_i); } } };
  { auto _e = Bdata(); if (_e) { _o->Bdata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Bdata[_i] = _e->Get(_i); } } };
  { auto _e = epsilon(); _o->epsilon = _e; };
}

inline flatbuffers::Offset<BatchNormOption> BatchNormOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNormOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNormOption> CreateBatchNormOption(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _slopeData = _o->slopeData.size() ? _fbb.CreateVector(_o->slopeData) : 0;
  auto _meanData = _o->meanData.size() ? _fbb.CreateVector(_o->meanData) : 0;
  auto _varData = _o->varData.size() ? _fbb.CreateVector(_o->varData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _Adata = _o->Adata.size() ? _fbb.CreateVector(_o->Adata) : 0;
  auto _Bdata = _o->Bdata.size() ? _fbb.CreateVector(_o->Bdata) : 0;
  auto _epsilon = _o->epsilon;
  return ace::CreateBatchNormOption(
      _fbb,
      _channels,
      _slopeData,
      _meanData,
      _varData,
      _biasData,
      _Adata,
      _Bdata,
      _epsilon);
}

inline Conv2DOptionT *Conv2DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv2DOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv2DOption::UnPackTo(Conv2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = dilateX(); _o->dilateX = _e; };
  { auto _e = dilateY(); _o->dilateY = _e; };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = group(); _o->group = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = outPads(); if (_e) { _o->outPads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outPads[_i] = _e->Get(_i); } } };
  { auto _e = hasOutputShape(); _o->hasOutputShape = _e; };
}

inline flatbuffers::Offset<Conv2DOption> Conv2DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOption> CreateConv2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _dilateX = _o->dilateX;
  auto _dilateY = _o->dilateY;
  auto _padMode = _o->padMode;
  auto _group = _o->group;
  auto _outputCount = _o->outputCount;
  auto _inputCount = _o->inputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _outPads = _o->outPads.size() ? _fbb.CreateVector(_o->outPads) : 0;
  auto _hasOutputShape = _o->hasOutputShape;
  return ace::CreateConv2DOption(
      _fbb,
      _padX,
      _padY,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _dilateX,
      _dilateY,
      _padMode,
      _group,
      _outputCount,
      _inputCount,
      _relu,
      _relu6,
      _pads,
      _outPads,
      _hasOutputShape);
}

inline Conv3DOptionT *Conv3DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv3DOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv3DOption::UnPackTo(Conv3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dilates(); if (_e) { _o->dilates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilates[_i] = _e->Get(_i); } } };
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } };
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
}

inline flatbuffers::Offset<Conv3DOption> Conv3DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv3DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv3DOption> CreateConv3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dilates = _o->dilates.size() ? _fbb.CreateVector(_o->dilates) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _padMode = _o->padMode;
  auto _inputCount = _o->inputCount;
  auto _outputCount = _o->outputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  return ace::CreateConv3DOption(
      _fbb,
      _dilates,
      _strides,
      _kernels,
      _pads,
      _padMode,
      _inputCount,
      _outputCount,
      _relu,
      _relu6);
}

inline InnerProductOptionT *InnerProductOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InnerProductOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InnerProductOption::UnPackTo(InnerProductOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = biasTerm(); _o->biasTerm = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = transpose(); _o->transpose = _e; };
}

inline flatbuffers::Offset<InnerProductOption> InnerProductOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInnerProductOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InnerProductOption> CreateInnerProductOption(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InnerProductOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _biasTerm = _o->biasTerm;
  auto _weightSize = _o->weightSize;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  auto _transpose = _o->transpose;
  return ace::CreateInnerProductOption(
      _fbb,
      _outputCount,
      _biasTerm,
      _weightSize,
      _weight,
      _bias,
      _axis,
      _transpose);
}

inline LRNOptionT *LRNOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LRNOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LRNOption::UnPackTo(LRNOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regionType(); _o->regionType = _e; };
  { auto _e = localSize(); _o->localSize = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
  { auto _e = beta(); _o->beta = _e; };
}

inline flatbuffers::Offset<LRNOption> LRNOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRNOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRNOption> CreateLRNOption(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regionType = _o->regionType;
  auto _localSize = _o->localSize;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return ace::CreateLRNOption(
      _fbb,
      _regionType,
      _localSize,
      _alpha,
      _beta);
}

inline NormalizeOptionT *NormalizeOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NormalizeOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NormalizeOption::UnPackTo(NormalizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acrossSpatial(); _o->acrossSpatial = _e; };
  { auto _e = channelShared(); _o->channelShared = _e; };
  { auto _e = eps(); _o->eps = _e; };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<NormalizeOption> NormalizeOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalizeOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormalizeOption> CreateNormalizeOption(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizeOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _acrossSpatial = _o->acrossSpatial;
  auto _channelShared = _o->channelShared;
  auto _eps = _o->eps;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  return ace::CreateNormalizeOption(
      _fbb,
      _acrossSpatial,
      _channelShared,
      _eps,
      _scale);
}

inline PriorBoxOptionT *PriorBoxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PriorBoxOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PriorBoxOption::UnPackTo(PriorBoxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minSizes(); if (_e) { _o->minSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->minSizes[_i] = _e->Get(_i); } } };
  { auto _e = maxSizes(); if (_e) { _o->maxSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->maxSizes[_i] = _e->Get(_i); } } };
  { auto _e = aspectRatios(); if (_e) { _o->aspectRatios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspectRatios[_i] = _e->Get(_i); } } };
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } };
  { auto _e = flip(); _o->flip = _e; };
  { auto _e = clip(); _o->clip = _e; };
  { auto _e = imageWidth(); _o->imageWidth = _e; };
  { auto _e = imageHeight(); _o->imageHeight = _e; };
  { auto _e = stepWidth(); _o->stepWidth = _e; };
  { auto _e = stepHeight(); _o->stepHeight = _e; };
  { auto _e = offset(); _o->offset = _e; };
}

inline flatbuffers::Offset<PriorBoxOption> PriorBoxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBoxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOption(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minSizes = _o->minSizes.size() ? _fbb.CreateVector(_o->minSizes) : 0;
  auto _maxSizes = _o->maxSizes.size() ? _fbb.CreateVector(_o->maxSizes) : 0;
  auto _aspectRatios = _o->aspectRatios.size() ? _fbb.CreateVector(_o->aspectRatios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _flip = _o->flip;
  auto _clip = _o->clip;
  auto _imageWidth = _o->imageWidth;
  auto _imageHeight = _o->imageHeight;
  auto _stepWidth = _o->stepWidth;
  auto _stepHeight = _o->stepHeight;
  auto _offset = _o->offset;
  return ace::CreatePriorBoxOption(
      _fbb,
      _minSizes,
      _maxSizes,
      _aspectRatios,
      _variances,
      _flip,
      _clip,
      _imageWidth,
      _imageHeight,
      _stepWidth,
      _stepHeight,
      _offset);
}

inline ProposalOptionT *ProposalOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProposalOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProposalOption::UnPackTo(ProposalOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = featStride(); _o->featStride = _e; };
  { auto _e = baseSize(); _o->baseSize = _e; };
  { auto _e = preNmsTopN(); _o->preNmsTopN = _e; };
  { auto _e = afterNmsTopN(); _o->afterNmsTopN = _e; };
  { auto _e = nmsThreshold(); _o->nmsThreshold = _e; };
  { auto _e = minSize(); _o->minSize = _e; };
}

inline flatbuffers::Offset<ProposalOption> ProposalOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposalOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProposalOption> CreateProposalOption(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _featStride = _o->featStride;
  auto _baseSize = _o->baseSize;
  auto _preNmsTopN = _o->preNmsTopN;
  auto _afterNmsTopN = _o->afterNmsTopN;
  auto _nmsThreshold = _o->nmsThreshold;
  auto _minSize = _o->minSize;
  return ace::CreateProposalOption(
      _fbb,
      _featStride,
      _baseSize,
      _preNmsTopN,
      _afterNmsTopN,
      _nmsThreshold,
      _minSize);
}

inline ResizeOptionT *ResizeOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResizeOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResizeOption::UnPackTo(ResizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = xScale(); _o->xScale = _e; };
  { auto _e = yScale(); _o->yScale = _e; };
}

inline flatbuffers::Offset<ResizeOption> ResizeOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeOption> CreateResizeOption(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _xScale = _o->xScale;
  auto _yScale = _o->yScale;
  return ace::CreateResizeOption(
      _fbb,
      _xScale,
      _yScale);
}

inline RoiPoolingOptionT *RoiPoolingOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RoiPoolingOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RoiPoolingOption::UnPackTo(RoiPoolingOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooledWidth(); _o->pooledWidth = _e; };
  { auto _e = pooledHeight(); _o->pooledHeight = _e; };
  { auto _e = spatialScale(); _o->spatialScale = _e; };
}

inline flatbuffers::Offset<RoiPoolingOption> RoiPoolingOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoiPoolingOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoiPoolingOption> CreateRoiPoolingOption(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoiPoolingOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooledWidth = _o->pooledWidth;
  auto _pooledHeight = _o->pooledHeight;
  auto _spatialScale = _o->spatialScale;
  return ace::CreateRoiPoolingOption(
      _fbb,
      _pooledWidth,
      _pooledHeight,
      _spatialScale);
}

inline ScaleOptionT *ScaleOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ScaleOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ScaleOption::UnPackTo(ScaleOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; };
  { auto _e = scaleData(); if (_e) { _o->scaleData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scaleData[_i] = _e->Get(_i); } } };
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<ScaleOption> ScaleOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScaleOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScaleOption> CreateScaleOption(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _scaleData = _o->scaleData.size() ? _fbb.CreateVector(_o->scaleData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  return ace::CreateScaleOption(
      _fbb,
      _channels,
      _scaleData,
      _biasData);
}

inline SoftmaxOptionT *SoftmaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftmaxOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SoftmaxOption::UnPackTo(SoftmaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<SoftmaxOption> SoftmaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOption> CreateSoftmaxOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return ace::CreateSoftmaxOption(
      _fbb,
      _axis);
}

inline InputOptionT *InputOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InputOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InputOption::UnPackTo(InputOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
  { auto _e = dtype(); _o->dtype = _e; };
  { auto _e = dformat(); _o->dformat = _e; };
}

inline flatbuffers::Offset<InputOption> InputOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputOption> CreateInputOption(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dtype = _o->dtype;
  auto _dformat = _o->dformat;
  return ace::CreateInputOption(
      _fbb,
      _dims,
      _dtype,
      _dformat);
}

inline DefaultOptionT *DefaultOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DefaultOptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DefaultOption::UnPackTo(DefaultOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = engine(); if (_e) _o->engine = _e->str(); };
  { auto _e = info(); if (_e) { _o->info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->info[_i] = _e->Get(_i); } } };
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<DefaultOption> DefaultOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDefaultOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DefaultOption> CreateDefaultOption(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DefaultOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _engine = _o->engine.empty() ? 0 : _fbb.CreateString(_o->engine);
  auto _info = _o->info.size() ? _fbb.CreateVector(_o->info) : 0;
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateDefaultOption(
      _fbb,
      _type,
      _engine,
      _info,
      _attr);
}

inline bool VerifyElementwiseOption(flatbuffers::Verifier &verifier, const void *obj, ElementwiseOption type) {
  switch (type) {
    case ElementwiseOption_NONE: {
      return true;
    }
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<const AbsOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const BoundedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<const ClipOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ClipV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ClippedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<const EluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<const ExpOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const GeluTanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const HardSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const HardSwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const LeakyReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<const LinearOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<const LogOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<const LogisticOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const LogSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<const MishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<const PowOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<const PReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<const ReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<const Relu6Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<const RoundOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<const SeluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const SigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const SoftReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const SoftReluV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<const SqrtOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<const SwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<const TanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<const NoneElementwiseOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyElementwiseOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyElementwiseOption(
        verifier,  values->Get(i), types->GetEnum<ElementwiseOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ElementwiseOptionUnion::UnPack(const void *obj, ElementwiseOption type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<const AbsOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const BoundedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<const ClipOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ClipV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ClippedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<const EluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<const ExpOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const GeluTanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const HardSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const HardSwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const LeakyReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<const LinearOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<const LogOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<const LogisticOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const LogSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<const MishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<const PowOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<const PReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<const ReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<const Relu6Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<const RoundOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<const SeluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const SigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const SoftReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const SoftReluV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<const SqrtOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<const SwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<const TanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<const NoneElementwiseOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ElementwiseOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<const AbsOptionT *>(value);
      return CreateAbsOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const BoundedReluOptionT *>(value);
      return CreateBoundedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<const ClipOptionT *>(value);
      return CreateClipOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ClipV2OptionT *>(value);
      return CreateClipV2Option(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ClippedReluOptionT *>(value);
      return CreateClippedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<const EluOptionT *>(value);
      return CreateEluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<const ExpOptionT *>(value);
      return CreateExpOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const GeluTanhOptionT *>(value);
      return CreateGeluTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const HardSigmoidOptionT *>(value);
      return CreateHardSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const HardSwishOptionT *>(value);
      return CreateHardSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const LeakyReluOptionT *>(value);
      return CreateLeakyReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<const LinearOptionT *>(value);
      return CreateLinearOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<const LogOptionT *>(value);
      return CreateLogOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<const LogisticOptionT *>(value);
      return CreateLogisticOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const LogSigmoidOptionT *>(value);
      return CreateLogSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<const MishOptionT *>(value);
      return CreateMishOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<const PowOptionT *>(value);
      return CreatePowOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<const PReluOptionT *>(value);
      return CreatePReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<const ReluOptionT *>(value);
      return CreateReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<const Relu6OptionT *>(value);
      return CreateRelu6Option(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<const RoundOptionT *>(value);
      return CreateRoundOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<const SeluOptionT *>(value);
      return CreateSeluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const SigmoidOptionT *>(value);
      return CreateSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const SoftReluOptionT *>(value);
      return CreateSoftReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const SoftReluV2OptionT *>(value);
      return CreateSoftReluV2Option(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<const SqrtOptionT *>(value);
      return CreateSqrtOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<const SwishOptionT *>(value);
      return CreateSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<const TanhOptionT *>(value);
      return CreateTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<const NoneElementwiseOptionT *>(value);
      return CreateNoneElementwiseOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ElementwiseOptionUnion::ElementwiseOptionUnion(const ElementwiseOptionUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ElementwiseOption_AbsOption: {
      value = new AbsOptionT(*reinterpret_cast<AbsOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_BoundedReluOption: {
      value = new BoundedReluOptionT(*reinterpret_cast<BoundedReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ClipOption: {
      value = new ClipOptionT(*reinterpret_cast<ClipOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ClipV2Option: {
      value = new ClipV2OptionT(*reinterpret_cast<ClipV2OptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ClippedReluOption: {
      value = new ClippedReluOptionT(*reinterpret_cast<ClippedReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_EluOption: {
      value = new EluOptionT(*reinterpret_cast<EluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ExpOption: {
      value = new ExpOptionT(*reinterpret_cast<ExpOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_GeluTanhOption: {
      value = new GeluTanhOptionT(*reinterpret_cast<GeluTanhOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_HardSigmoidOption: {
      value = new HardSigmoidOptionT(*reinterpret_cast<HardSigmoidOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_HardSwishOption: {
      value = new HardSwishOptionT(*reinterpret_cast<HardSwishOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LeakyReluOption: {
      value = new LeakyReluOptionT(*reinterpret_cast<LeakyReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LinearOption: {
      value = new LinearOptionT(*reinterpret_cast<LinearOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LogOption: {
      value = new LogOptionT(*reinterpret_cast<LogOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LogisticOption: {
      value = new LogisticOptionT(*reinterpret_cast<LogisticOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LogSigmoidOption: {
      value = new LogSigmoidOptionT(*reinterpret_cast<LogSigmoidOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_MishOption: {
      value = new MishOptionT(*reinterpret_cast<MishOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_PowOption: {
      value = new PowOptionT(*reinterpret_cast<PowOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_PReluOption: {
      value = new PReluOptionT(*reinterpret_cast<PReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ReluOption: {
      value = new ReluOptionT(*reinterpret_cast<ReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_Relu6Option: {
      value = new Relu6OptionT(*reinterpret_cast<Relu6OptionT *>(u.value));
      break;
    }
    case ElementwiseOption_RoundOption: {
      value = new RoundOptionT(*reinterpret_cast<RoundOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SeluOption: {
      value = new SeluOptionT(*reinterpret_cast<SeluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SigmoidOption: {
      value = new SigmoidOptionT(*reinterpret_cast<SigmoidOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SoftReluOption: {
      value = new SoftReluOptionT(*reinterpret_cast<SoftReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SoftReluV2Option: {
      value = new SoftReluV2OptionT(*reinterpret_cast<SoftReluV2OptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SqrtOption: {
      value = new SqrtOptionT(*reinterpret_cast<SqrtOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SwishOption: {
      value = new SwishOptionT(*reinterpret_cast<SwishOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_TanhOption: {
      value = new TanhOptionT(*reinterpret_cast<TanhOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_NoneElementwiseOption: {
      value = new NoneElementwiseOptionT(*reinterpret_cast<NoneElementwiseOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ElementwiseOptionUnion::Reset() {
  switch (type) {
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<AbsOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<BoundedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<ClipOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<ClipV2OptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<ClippedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<EluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<ExpOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<GeluTanhOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<HardSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<HardSwishOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<LeakyReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<LinearOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<LogOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<LogisticOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<LogSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<MishOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<PowOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<PReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<ReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<Relu6OptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<RoundOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<SeluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<SigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<SoftReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<SoftReluV2OptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<SqrtOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<SwishOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<TanhOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<NoneElementwiseOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ElementwiseOption_NONE;
}

inline bool VerifyBinaryOption(flatbuffers::Verifier &verifier, const void *obj, BinaryOption type) {
  switch (type) {
    case BinaryOption_NONE: {
      return true;
    }
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<const AddOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<const MulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<const MinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<const MaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<const MeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<const DivOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const GreaterEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const GreaterThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const LessEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<const LessThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<const EqualToOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const NotEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyBinaryOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBinaryOption(
        verifier,  values->Get(i), types->GetEnum<BinaryOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BinaryOptionUnion::UnPack(const void *obj, BinaryOption type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<const AddOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<const MulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<const MinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<const MaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<const MeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<const DivOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const GreaterEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const GreaterThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const LessEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<const LessThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<const EqualToOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const NotEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BinaryOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<const AddOptionT *>(value);
      return CreateAddOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<const MulOptionT *>(value);
      return CreateMulOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<const MinOptionT *>(value);
      return CreateMinOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<const MaxOptionT *>(value);
      return CreateMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<const MeanOptionT *>(value);
      return CreateMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<const DivOptionT *>(value);
      return CreateDivOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const GreaterEqualOptionT *>(value);
      return CreateGreaterEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const GreaterThanOptionT *>(value);
      return CreateGreaterThanOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const LessEqualOptionT *>(value);
      return CreateLessEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<const LessThanOptionT *>(value);
      return CreateLessThanOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<const EqualToOptionT *>(value);
      return CreateEqualToOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const NotEqualOptionT *>(value);
      return CreateNotEqualOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BinaryOptionUnion::BinaryOptionUnion(const BinaryOptionUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case BinaryOption_AddOption: {
      value = new AddOptionT(*reinterpret_cast<AddOptionT *>(u.value));
      break;
    }
    case BinaryOption_MulOption: {
      value = new MulOptionT(*reinterpret_cast<MulOptionT *>(u.value));
      break;
    }
    case BinaryOption_MinOption: {
      value = new MinOptionT(*reinterpret_cast<MinOptionT *>(u.value));
      break;
    }
    case BinaryOption_MaxOption: {
      value = new MaxOptionT(*reinterpret_cast<MaxOptionT *>(u.value));
      break;
    }
    case BinaryOption_MeanOption: {
      value = new MeanOptionT(*reinterpret_cast<MeanOptionT *>(u.value));
      break;
    }
    case BinaryOption_DivOption: {
      value = new DivOptionT(*reinterpret_cast<DivOptionT *>(u.value));
      break;
    }
    case BinaryOption_GreaterEqualOption: {
      value = new GreaterEqualOptionT(*reinterpret_cast<GreaterEqualOptionT *>(u.value));
      break;
    }
    case BinaryOption_GreaterThanOption: {
      value = new GreaterThanOptionT(*reinterpret_cast<GreaterThanOptionT *>(u.value));
      break;
    }
    case BinaryOption_LessEqualOption: {
      value = new LessEqualOptionT(*reinterpret_cast<LessEqualOptionT *>(u.value));
      break;
    }
    case BinaryOption_LessThanOption: {
      value = new LessThanOptionT(*reinterpret_cast<LessThanOptionT *>(u.value));
      break;
    }
    case BinaryOption_EqualToOption: {
      value = new EqualToOptionT(*reinterpret_cast<EqualToOptionT *>(u.value));
      break;
    }
    case BinaryOption_NotEqualOption: {
      value = new NotEqualOptionT(*reinterpret_cast<NotEqualOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BinaryOptionUnion::Reset() {
  switch (type) {
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<AddOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<MulOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<MinOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<MaxOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<MeanOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<DivOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<GreaterEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<GreaterThanOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<LessEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<LessThanOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<EqualToOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<NotEqualOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BinaryOption_NONE;
}

inline bool VerifyReduceOption(flatbuffers::Verifier &verifier, const void *obj, ReduceOption type) {
  switch (type) {
    case ReduceOption_NONE: {
      return true;
    }
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ReduceMinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ReduceMaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ReduceMeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ReduceSumOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ReduceMulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyReduceOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReduceOption(
        verifier,  values->Get(i), types->GetEnum<ReduceOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ReduceOptionUnion::UnPack(const void *obj, ReduceOption type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ReduceMinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ReduceMaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ReduceMeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ReduceSumOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ReduceMulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ReduceOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ReduceMinOptionT *>(value);
      return CreateReduceMinOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ReduceMaxOptionT *>(value);
      return CreateReduceMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ReduceMeanOptionT *>(value);
      return CreateReduceMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ReduceSumOptionT *>(value);
      return CreateReduceSumOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ReduceMulOptionT *>(value);
      return CreateReduceMulOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ReduceOptionUnion::ReduceOptionUnion(const ReduceOptionUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      value = new ReduceMinOptionT(*reinterpret_cast<ReduceMinOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceMaxOption: {
      value = new ReduceMaxOptionT(*reinterpret_cast<ReduceMaxOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceMeanOption: {
      value = new ReduceMeanOptionT(*reinterpret_cast<ReduceMeanOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceSumOption: {
      value = new ReduceSumOptionT(*reinterpret_cast<ReduceSumOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceMulOption: {
      value = new ReduceMulOptionT(*reinterpret_cast<ReduceMulOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ReduceOptionUnion::Reset() {
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<ReduceMinOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<ReduceMaxOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<ReduceMeanOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<ReduceSumOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<ReduceMulOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ReduceOption_NONE;
}

inline bool VerifyOpOption(flatbuffers::Verifier &verifier, const void *obj, OpOption type) {
  switch (type) {
    case OpOption_NONE: {
      return true;
    }
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<const DefaultOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<const ConstOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<const AbsOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const BoundedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<const ClipOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ClipV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ClippedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<const EluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<const ExpOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const GeluTanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const HardSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const HardSwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const LeakyReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<const LinearOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<const LogOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<const LogisticOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const LogSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<const MishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<const PowOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<const PReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<const ReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<const Relu6Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<const RoundOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<const SeluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const SigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const SoftReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const SoftReluV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<const SqrtOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<const SwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<const TanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<const AddOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<const MulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<const MinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<const MaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<const MeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<const DivOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const GreaterEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const GreaterThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const LessEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<const LessThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<const EqualToOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const NotEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ReduceMinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ReduceMaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ReduceMeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ReduceSumOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ReduceMulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<const Pool2DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<const Pool3DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<const ReshapeOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<const SliceOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<const FlattenOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<const PermuteOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<const ArgMaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<const BatchNormOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<const Conv2DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<const Conv3DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<const InnerProductOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<const LRNOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<const NormalizeOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<const PriorBoxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<const ProposalOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<const ResizeOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<const RoiPoolingOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<const ScaleOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<const SoftmaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<const InputOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOpOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpOption(
        verifier,  values->Get(i), types->GetEnum<OpOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpOptionUnion::UnPack(const void *obj, OpOption type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<const DefaultOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<const ConstOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<const AbsOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const BoundedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<const ClipOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ClipV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ClippedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<const EluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<const ExpOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const GeluTanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const HardSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const HardSwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const LeakyReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<const LinearOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<const LogOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<const LogisticOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const LogSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<const MishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<const PowOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<const PReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<const ReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<const Relu6Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<const RoundOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<const SeluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const SigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const SoftReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const SoftReluV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<const SqrtOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<const SwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<const TanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<const AddOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<const MulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<const MinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<const MaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<const MeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<const DivOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const GreaterEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const GreaterThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const LessEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<const LessThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<const EqualToOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const NotEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ReduceMinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ReduceMaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ReduceMeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ReduceSumOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ReduceMulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<const Pool2DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<const Pool3DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<const ReshapeOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<const SliceOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<const FlattenOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<const PermuteOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<const ArgMaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<const BatchNormOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<const Conv2DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<const Conv3DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<const InnerProductOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<const LRNOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<const NormalizeOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<const PriorBoxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<const ProposalOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<const ResizeOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<const RoiPoolingOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<const ScaleOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<const SoftmaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<const InputOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OpOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<const DefaultOptionT *>(value);
      return CreateDefaultOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<const ConstOptionT *>(value);
      return CreateConstOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<const AbsOptionT *>(value);
      return CreateAbsOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const BoundedReluOptionT *>(value);
      return CreateBoundedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<const ClipOptionT *>(value);
      return CreateClipOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ClipV2OptionT *>(value);
      return CreateClipV2Option(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ClippedReluOptionT *>(value);
      return CreateClippedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<const EluOptionT *>(value);
      return CreateEluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<const ExpOptionT *>(value);
      return CreateExpOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const GeluTanhOptionT *>(value);
      return CreateGeluTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const HardSigmoidOptionT *>(value);
      return CreateHardSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const HardSwishOptionT *>(value);
      return CreateHardSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const LeakyReluOptionT *>(value);
      return CreateLeakyReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<const LinearOptionT *>(value);
      return CreateLinearOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<const LogOptionT *>(value);
      return CreateLogOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<const LogisticOptionT *>(value);
      return CreateLogisticOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const LogSigmoidOptionT *>(value);
      return CreateLogSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<const MishOptionT *>(value);
      return CreateMishOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<const PowOptionT *>(value);
      return CreatePowOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<const PReluOptionT *>(value);
      return CreatePReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<const ReluOptionT *>(value);
      return CreateReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<const Relu6OptionT *>(value);
      return CreateRelu6Option(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<const RoundOptionT *>(value);
      return CreateRoundOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<const SeluOptionT *>(value);
      return CreateSeluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const SigmoidOptionT *>(value);
      return CreateSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const SoftReluOptionT *>(value);
      return CreateSoftReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const SoftReluV2OptionT *>(value);
      return CreateSoftReluV2Option(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<const SqrtOptionT *>(value);
      return CreateSqrtOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<const SwishOptionT *>(value);
      return CreateSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<const TanhOptionT *>(value);
      return CreateTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<const AddOptionT *>(value);
      return CreateAddOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<const MulOptionT *>(value);
      return CreateMulOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<const MinOptionT *>(value);
      return CreateMinOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<const MaxOptionT *>(value);
      return CreateMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<const MeanOptionT *>(value);
      return CreateMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<const DivOptionT *>(value);
      return CreateDivOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const GreaterEqualOptionT *>(value);
      return CreateGreaterEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const GreaterThanOptionT *>(value);
      return CreateGreaterThanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const LessEqualOptionT *>(value);
      return CreateLessEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<const LessThanOptionT *>(value);
      return CreateLessThanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<const EqualToOptionT *>(value);
      return CreateEqualToOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const NotEqualOptionT *>(value);
      return CreateNotEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ReduceMinOptionT *>(value);
      return CreateReduceMinOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ReduceMaxOptionT *>(value);
      return CreateReduceMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ReduceMeanOptionT *>(value);
      return CreateReduceMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ReduceSumOptionT *>(value);
      return CreateReduceSumOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ReduceMulOptionT *>(value);
      return CreateReduceMulOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<const Pool2DOptionT *>(value);
      return CreatePool2DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<const Pool3DOptionT *>(value);
      return CreatePool3DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<const ReshapeOptionT *>(value);
      return CreateReshapeOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<const SliceOptionT *>(value);
      return CreateSliceOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<const FlattenOptionT *>(value);
      return CreateFlattenOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<const PermuteOptionT *>(value);
      return CreatePermuteOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<const ArgMaxOptionT *>(value);
      return CreateArgMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<const BatchNormOptionT *>(value);
      return CreateBatchNormOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<const Conv2DOptionT *>(value);
      return CreateConv2DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<const Conv3DOptionT *>(value);
      return CreateConv3DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<const InnerProductOptionT *>(value);
      return CreateInnerProductOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<const LRNOptionT *>(value);
      return CreateLRNOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<const NormalizeOptionT *>(value);
      return CreateNormalizeOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<const PriorBoxOptionT *>(value);
      return CreatePriorBoxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<const ProposalOptionT *>(value);
      return CreateProposalOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<const ResizeOptionT *>(value);
      return CreateResizeOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<const RoiPoolingOptionT *>(value);
      return CreateRoiPoolingOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<const ScaleOptionT *>(value);
      return CreateScaleOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<const SoftmaxOptionT *>(value);
      return CreateSoftmaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<const InputOptionT *>(value);
      return CreateInputOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpOptionUnion::OpOptionUnion(const OpOptionUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case OpOption_DefaultOption: {
      FLATBUFFERS_ASSERT(false);  // DefaultOptionT not copyable.
      break;
    }
    case OpOption_ConstOption: {
      FLATBUFFERS_ASSERT(false);  // ConstOptionT not copyable.
      break;
    }
    case OpOption_AbsOption: {
      value = new AbsOptionT(*reinterpret_cast<AbsOptionT *>(u.value));
      break;
    }
    case OpOption_BoundedReluOption: {
      value = new BoundedReluOptionT(*reinterpret_cast<BoundedReluOptionT *>(u.value));
      break;
    }
    case OpOption_ClipOption: {
      value = new ClipOptionT(*reinterpret_cast<ClipOptionT *>(u.value));
      break;
    }
    case OpOption_ClipV2Option: {
      value = new ClipV2OptionT(*reinterpret_cast<ClipV2OptionT *>(u.value));
      break;
    }
    case OpOption_ClippedReluOption: {
      value = new ClippedReluOptionT(*reinterpret_cast<ClippedReluOptionT *>(u.value));
      break;
    }
    case OpOption_EluOption: {
      value = new EluOptionT(*reinterpret_cast<EluOptionT *>(u.value));
      break;
    }
    case OpOption_ExpOption: {
      value = new ExpOptionT(*reinterpret_cast<ExpOptionT *>(u.value));
      break;
    }
    case OpOption_GeluTanhOption: {
      value = new GeluTanhOptionT(*reinterpret_cast<GeluTanhOptionT *>(u.value));
      break;
    }
    case OpOption_HardSigmoidOption: {
      value = new HardSigmoidOptionT(*reinterpret_cast<HardSigmoidOptionT *>(u.value));
      break;
    }
    case OpOption_HardSwishOption: {
      value = new HardSwishOptionT(*reinterpret_cast<HardSwishOptionT *>(u.value));
      break;
    }
    case OpOption_LeakyReluOption: {
      value = new LeakyReluOptionT(*reinterpret_cast<LeakyReluOptionT *>(u.value));
      break;
    }
    case OpOption_LinearOption: {
      value = new LinearOptionT(*reinterpret_cast<LinearOptionT *>(u.value));
      break;
    }
    case OpOption_LogOption: {
      value = new LogOptionT(*reinterpret_cast<LogOptionT *>(u.value));
      break;
    }
    case OpOption_LogisticOption: {
      value = new LogisticOptionT(*reinterpret_cast<LogisticOptionT *>(u.value));
      break;
    }
    case OpOption_LogSigmoidOption: {
      value = new LogSigmoidOptionT(*reinterpret_cast<LogSigmoidOptionT *>(u.value));
      break;
    }
    case OpOption_MishOption: {
      value = new MishOptionT(*reinterpret_cast<MishOptionT *>(u.value));
      break;
    }
    case OpOption_PowOption: {
      value = new PowOptionT(*reinterpret_cast<PowOptionT *>(u.value));
      break;
    }
    case OpOption_PReluOption: {
      value = new PReluOptionT(*reinterpret_cast<PReluOptionT *>(u.value));
      break;
    }
    case OpOption_ReluOption: {
      value = new ReluOptionT(*reinterpret_cast<ReluOptionT *>(u.value));
      break;
    }
    case OpOption_Relu6Option: {
      value = new Relu6OptionT(*reinterpret_cast<Relu6OptionT *>(u.value));
      break;
    }
    case OpOption_RoundOption: {
      value = new RoundOptionT(*reinterpret_cast<RoundOptionT *>(u.value));
      break;
    }
    case OpOption_SeluOption: {
      value = new SeluOptionT(*reinterpret_cast<SeluOptionT *>(u.value));
      break;
    }
    case OpOption_SigmoidOption: {
      value = new SigmoidOptionT(*reinterpret_cast<SigmoidOptionT *>(u.value));
      break;
    }
    case OpOption_SoftReluOption: {
      value = new SoftReluOptionT(*reinterpret_cast<SoftReluOptionT *>(u.value));
      break;
    }
    case OpOption_SoftReluV2Option: {
      value = new SoftReluV2OptionT(*reinterpret_cast<SoftReluV2OptionT *>(u.value));
      break;
    }
    case OpOption_SqrtOption: {
      value = new SqrtOptionT(*reinterpret_cast<SqrtOptionT *>(u.value));
      break;
    }
    case OpOption_SwishOption: {
      value = new SwishOptionT(*reinterpret_cast<SwishOptionT *>(u.value));
      break;
    }
    case OpOption_TanhOption: {
      value = new TanhOptionT(*reinterpret_cast<TanhOptionT *>(u.value));
      break;
    }
    case OpOption_AddOption: {
      value = new AddOptionT(*reinterpret_cast<AddOptionT *>(u.value));
      break;
    }
    case OpOption_MulOption: {
      value = new MulOptionT(*reinterpret_cast<MulOptionT *>(u.value));
      break;
    }
    case OpOption_MinOption: {
      value = new MinOptionT(*reinterpret_cast<MinOptionT *>(u.value));
      break;
    }
    case OpOption_MaxOption: {
      value = new MaxOptionT(*reinterpret_cast<MaxOptionT *>(u.value));
      break;
    }
    case OpOption_MeanOption: {
      value = new MeanOptionT(*reinterpret_cast<MeanOptionT *>(u.value));
      break;
    }
    case OpOption_DivOption: {
      value = new DivOptionT(*reinterpret_cast<DivOptionT *>(u.value));
      break;
    }
    case OpOption_GreaterEqualOption: {
      value = new GreaterEqualOptionT(*reinterpret_cast<GreaterEqualOptionT *>(u.value));
      break;
    }
    case OpOption_GreaterThanOption: {
      value = new GreaterThanOptionT(*reinterpret_cast<GreaterThanOptionT *>(u.value));
      break;
    }
    case OpOption_LessEqualOption: {
      value = new LessEqualOptionT(*reinterpret_cast<LessEqualOptionT *>(u.value));
      break;
    }
    case OpOption_LessThanOption: {
      value = new LessThanOptionT(*reinterpret_cast<LessThanOptionT *>(u.value));
      break;
    }
    case OpOption_EqualToOption: {
      value = new EqualToOptionT(*reinterpret_cast<EqualToOptionT *>(u.value));
      break;
    }
    case OpOption_NotEqualOption: {
      value = new NotEqualOptionT(*reinterpret_cast<NotEqualOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMinOption: {
      value = new ReduceMinOptionT(*reinterpret_cast<ReduceMinOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMaxOption: {
      value = new ReduceMaxOptionT(*reinterpret_cast<ReduceMaxOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMeanOption: {
      value = new ReduceMeanOptionT(*reinterpret_cast<ReduceMeanOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceSumOption: {
      value = new ReduceSumOptionT(*reinterpret_cast<ReduceSumOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMulOption: {
      value = new ReduceMulOptionT(*reinterpret_cast<ReduceMulOptionT *>(u.value));
      break;
    }
    case OpOption_Pool2DOption: {
      value = new Pool2DOptionT(*reinterpret_cast<Pool2DOptionT *>(u.value));
      break;
    }
    case OpOption_Pool3DOption: {
      value = new Pool3DOptionT(*reinterpret_cast<Pool3DOptionT *>(u.value));
      break;
    }
    case OpOption_ReshapeOption: {
      value = new ReshapeOptionT(*reinterpret_cast<ReshapeOptionT *>(u.value));
      break;
    }
    case OpOption_SliceOption: {
      value = new SliceOptionT(*reinterpret_cast<SliceOptionT *>(u.value));
      break;
    }
    case OpOption_FlattenOption: {
      value = new FlattenOptionT(*reinterpret_cast<FlattenOptionT *>(u.value));
      break;
    }
    case OpOption_PermuteOption: {
      value = new PermuteOptionT(*reinterpret_cast<PermuteOptionT *>(u.value));
      break;
    }
    case OpOption_ArgMaxOption: {
      value = new ArgMaxOptionT(*reinterpret_cast<ArgMaxOptionT *>(u.value));
      break;
    }
    case OpOption_BatchNormOption: {
      value = new BatchNormOptionT(*reinterpret_cast<BatchNormOptionT *>(u.value));
      break;
    }
    case OpOption_Conv2DOption: {
      value = new Conv2DOptionT(*reinterpret_cast<Conv2DOptionT *>(u.value));
      break;
    }
    case OpOption_Conv3DOption: {
      value = new Conv3DOptionT(*reinterpret_cast<Conv3DOptionT *>(u.value));
      break;
    }
    case OpOption_InnerProductOption: {
      value = new InnerProductOptionT(*reinterpret_cast<InnerProductOptionT *>(u.value));
      break;
    }
    case OpOption_LRNOption: {
      value = new LRNOptionT(*reinterpret_cast<LRNOptionT *>(u.value));
      break;
    }
    case OpOption_NormalizeOption: {
      value = new NormalizeOptionT(*reinterpret_cast<NormalizeOptionT *>(u.value));
      break;
    }
    case OpOption_PriorBoxOption: {
      value = new PriorBoxOptionT(*reinterpret_cast<PriorBoxOptionT *>(u.value));
      break;
    }
    case OpOption_ProposalOption: {
      value = new ProposalOptionT(*reinterpret_cast<ProposalOptionT *>(u.value));
      break;
    }
    case OpOption_ResizeOption: {
      value = new ResizeOptionT(*reinterpret_cast<ResizeOptionT *>(u.value));
      break;
    }
    case OpOption_RoiPoolingOption: {
      value = new RoiPoolingOptionT(*reinterpret_cast<RoiPoolingOptionT *>(u.value));
      break;
    }
    case OpOption_ScaleOption: {
      value = new ScaleOptionT(*reinterpret_cast<ScaleOptionT *>(u.value));
      break;
    }
    case OpOption_SoftmaxOption: {
      value = new SoftmaxOptionT(*reinterpret_cast<SoftmaxOptionT *>(u.value));
      break;
    }
    case OpOption_InputOption: {
      value = new InputOptionT(*reinterpret_cast<InputOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpOptionUnion::Reset() {
  switch (type) {
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<DefaultOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<ConstOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<AbsOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<BoundedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<ClipOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<ClipV2OptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<ClippedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<EluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<ExpOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<GeluTanhOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<HardSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<HardSwishOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<LeakyReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<LinearOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<LogOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<LogisticOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<LogSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<MishOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<PowOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<PReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<ReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<Relu6OptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<RoundOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<SeluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<SigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<SoftReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<SoftReluV2OptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<SqrtOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<SwishOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<TanhOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<AddOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<MulOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<MinOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<MaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<MeanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<DivOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<GreaterEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<GreaterThanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<LessEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<LessThanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<EqualToOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<NotEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<ReduceMinOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<ReduceMaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<ReduceMeanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<ReduceSumOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<ReduceMulOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<Pool2DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<Pool3DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<ReshapeOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<SliceOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<FlattenOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<PermuteOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<ArgMaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<BatchNormOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<Conv2DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<Conv3DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<InnerProductOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<LRNOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<NormalizeOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<PriorBoxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<ProposalOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<ResizeOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<RoiPoolingOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<ScaleOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<SoftmaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<InputOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpOption_NONE;
}

inline const flatbuffers::TypeTable *ElementwiseOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AbsOptionTypeTable,
    BoundedReluOptionTypeTable,
    ClipOptionTypeTable,
    ClipV2OptionTypeTable,
    ClippedReluOptionTypeTable,
    EluOptionTypeTable,
    ExpOptionTypeTable,
    GeluTanhOptionTypeTable,
    HardSigmoidOptionTypeTable,
    HardSwishOptionTypeTable,
    LeakyReluOptionTypeTable,
    LinearOptionTypeTable,
    LogOptionTypeTable,
    LogisticOptionTypeTable,
    LogSigmoidOptionTypeTable,
    MishOptionTypeTable,
    PowOptionTypeTable,
    PReluOptionTypeTable,
    ReluOptionTypeTable,
    Relu6OptionTypeTable,
    RoundOptionTypeTable,
    SeluOptionTypeTable,
    SigmoidOptionTypeTable,
    SoftReluOptionTypeTable,
    SoftReluV2OptionTypeTable,
    SqrtOptionTypeTable,
    SwishOptionTypeTable,
    TanhOptionTypeTable,
    NoneElementwiseOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "NoneElementwiseOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 30, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AddOptionTypeTable,
    MulOptionTypeTable,
    MinOptionTypeTable,
    MaxOptionTypeTable,
    MeanOptionTypeTable,
    DivOptionTypeTable,
    GreaterEqualOptionTypeTable,
    GreaterThanOptionTypeTable,
    LessEqualOptionTypeTable,
    LessThanOptionTypeTable,
    EqualToOptionTypeTable,
    NotEqualOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 13, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReduceMinOptionTypeTable,
    ReduceMaxOptionTypeTable,
    ReduceMeanOptionTypeTable,
    ReduceSumOptionTypeTable,
    ReduceMulOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAX_POOL",
    "AVG_POOL",
    "GLOBAL_MAX_POOL",
    "GLOBAL_AVG_POOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PaddingTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PaddingTypeTypeTable
  };
  static const char * const names[] = {
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DefaultOptionTypeTable,
    ConstOptionTypeTable,
    AbsOptionTypeTable,
    BoundedReluOptionTypeTable,
    ClipOptionTypeTable,
    ClipV2OptionTypeTable,
    ClippedReluOptionTypeTable,
    EluOptionTypeTable,
    ExpOptionTypeTable,
    GeluTanhOptionTypeTable,
    HardSigmoidOptionTypeTable,
    HardSwishOptionTypeTable,
    LeakyReluOptionTypeTable,
    LinearOptionTypeTable,
    LogOptionTypeTable,
    LogisticOptionTypeTable,
    LogSigmoidOptionTypeTable,
    MishOptionTypeTable,
    PowOptionTypeTable,
    PReluOptionTypeTable,
    ReluOptionTypeTable,
    Relu6OptionTypeTable,
    RoundOptionTypeTable,
    SeluOptionTypeTable,
    SigmoidOptionTypeTable,
    SoftReluOptionTypeTable,
    SoftReluV2OptionTypeTable,
    SqrtOptionTypeTable,
    SwishOptionTypeTable,
    TanhOptionTypeTable,
    AddOptionTypeTable,
    MulOptionTypeTable,
    MinOptionTypeTable,
    MaxOptionTypeTable,
    MeanOptionTypeTable,
    DivOptionTypeTable,
    GreaterEqualOptionTypeTable,
    GreaterThanOptionTypeTable,
    LessEqualOptionTypeTable,
    LessThanOptionTypeTable,
    EqualToOptionTypeTable,
    NotEqualOptionTypeTable,
    ReduceMinOptionTypeTable,
    ReduceMaxOptionTypeTable,
    ReduceMeanOptionTypeTable,
    ReduceSumOptionTypeTable,
    ReduceMulOptionTypeTable,
    Pool2DOptionTypeTable,
    Pool3DOptionTypeTable,
    ReshapeOptionTypeTable,
    SliceOptionTypeTable,
    FlattenOptionTypeTable,
    PermuteOptionTypeTable,
    ArgMaxOptionTypeTable,
    BatchNormOptionTypeTable,
    Conv2DOptionTypeTable,
    Conv3DOptionTypeTable,
    InnerProductOptionTypeTable,
    LRNOptionTypeTable,
    NormalizeOptionTypeTable,
    PriorBoxOptionTypeTable,
    ProposalOptionTypeTable,
    ResizeOptionTypeTable,
    RoiPoolingOptionTypeTable,
    ScaleOptionTypeTable,
    SoftmaxOptionTypeTable,
    InputOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "DefaultOption",
    "ConstOption",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption",
    "Pool2DOption",
    "Pool3DOption",
    "ReshapeOption",
    "SliceOption",
    "FlattenOption",
    "PermuteOption",
    "ArgMaxOption",
    "BatchNormOption",
    "Conv2DOption",
    "Conv3DOption",
    "InnerProductOption",
    "LRNOption",
    "NormalizeOption",
    "PriorBoxOption",
    "ProposalOption",
    "ResizeOption",
    "RoiPoolingOption",
    "ScaleOption",
    "SoftmaxOption",
    "InputOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 68, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AbsOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BoundedReluOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClipOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClipV2OptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeluTanhOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HardSigmoidOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HardSwishOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LinearOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogisticOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MishOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "slopeCount",
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Relu6OptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minval",
    "maxval"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClippedReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "threashod"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LeakyReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "negative_slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogSigmoidOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoundOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SeluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "scale",
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SigmoidOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftReluOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftReluV2OptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqrtOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SwishOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TanhOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConstOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TensorTypeTable
  };
  static const char * const names[] = {
    "tensor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NoneElementwiseOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaxOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MeanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterThanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessEqualOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessThanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EqualToOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NotEqualOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMinOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMaxOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMeanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceSumOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMulOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool2DOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable,
    PaddingTypeTypeTable
  };
  static const char * const names[] = {
    "size",
    "type",
    "strides",
    "padding",
    "padtype",
    "global_pooling",
    "ceil_mode",
    "exclusive"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool3DOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataFormatTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dimType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FrontendFrameworkTypeTable
  };
  static const char * const names[] = {
    "axis",
    "slicePoints",
    "sourceType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "endAxis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PermuteOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outMaxVal",
    "topK",
    "axis",
    "softmaxThreshold"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "channels",
    "slopeData",
    "meanData",
    "varData",
    "biasData",
    "Adata",
    "Bdata",
    "epsilon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "dilateX",
    "dilateY",
    "padMode",
    "group",
    "outputCount",
    "inputCount",
    "relu",
    "relu6",
    "pads",
    "outPads",
    "hasOutputShape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv3DOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "dilates",
    "strides",
    "kernels",
    "pads",
    "padMode",
    "inputCount",
    "outputCount",
    "relu",
    "relu6"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InnerProductOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "outputCount",
    "biasTerm",
    "weightSize",
    "weight",
    "bias",
    "axis",
    "transpose"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "regionType",
    "localSize",
    "alpha",
    "beta"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NormalizeOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "acrossSpatial",
    "channelShared",
    "eps",
    "scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minSizes",
    "maxSizes",
    "aspectRatios",
    "variances",
    "flip",
    "clip",
    "imageWidth",
    "imageHeight",
    "stepWidth",
    "stepHeight",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProposalOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "featStride",
    "baseSize",
    "preNmsTopN",
    "afterNmsTopN",
    "nmsThreshold",
    "minSize"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "xScale",
    "yScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoiPoolingOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "pooledWidth",
    "pooledHeight",
    "spatialScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "channels",
    "scaleData",
    "biasData"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable,
    DataFormatTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dtype",
    "dformat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DefaultOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "engine",
    "info",
    "attr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace ace

#endif  // FLATBUFFERS_GENERATED_OPOPTION_ACE_H_
