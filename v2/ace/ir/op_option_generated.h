// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPOPTION_ACE_H_
#define FLATBUFFERS_GENERATED_OPOPTION_ACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "tensor_generated.h"
#include "types_generated.h"

namespace ace {

struct AbsOption;
struct AbsOptionBuilder;
struct AbsOptionT;

struct BoundedReluOption;
struct BoundedReluOptionBuilder;
struct BoundedReluOptionT;

struct ClipOption;
struct ClipOptionBuilder;
struct ClipOptionT;

struct ClipV2Option;
struct ClipV2OptionBuilder;
struct ClipV2OptionT;

struct EluOption;
struct EluOptionBuilder;
struct EluOptionT;

struct ExpOption;
struct ExpOptionBuilder;
struct ExpOptionT;

struct GeluTanhOption;
struct GeluTanhOptionBuilder;
struct GeluTanhOptionT;

struct HardSigmoidOption;
struct HardSigmoidOptionBuilder;
struct HardSigmoidOptionT;

struct HardSwishOption;
struct HardSwishOptionBuilder;
struct HardSwishOptionT;

struct LinearOption;
struct LinearOptionBuilder;
struct LinearOptionT;

struct LogOption;
struct LogOptionBuilder;
struct LogOptionT;

struct LogisticOption;
struct LogisticOptionBuilder;
struct LogisticOptionT;

struct MishOption;
struct MishOptionBuilder;
struct MishOptionT;

struct PowOption;
struct PowOptionBuilder;
struct PowOptionT;

struct PReluOption;
struct PReluOptionBuilder;
struct PReluOptionT;

struct ReluOption;
struct ReluOptionBuilder;
struct ReluOptionT;

struct Relu6Option;
struct Relu6OptionBuilder;
struct Relu6OptionT;

struct ClippedReluOption;
struct ClippedReluOptionBuilder;
struct ClippedReluOptionT;

struct LeakyReluOption;
struct LeakyReluOptionBuilder;
struct LeakyReluOptionT;

struct LogSigmoidOption;
struct LogSigmoidOptionBuilder;
struct LogSigmoidOptionT;

struct RoundOption;
struct RoundOptionBuilder;
struct RoundOptionT;

struct SeluOption;
struct SeluOptionBuilder;
struct SeluOptionT;

struct SigmoidOption;
struct SigmoidOptionBuilder;
struct SigmoidOptionT;

struct SoftReluOption;
struct SoftReluOptionBuilder;
struct SoftReluOptionT;

struct SoftReluV2Option;
struct SoftReluV2OptionBuilder;
struct SoftReluV2OptionT;

struct SqrtOption;
struct SqrtOptionBuilder;
struct SqrtOptionT;

struct SwishOption;
struct SwishOptionBuilder;
struct SwishOptionT;

struct TanhOption;
struct TanhOptionBuilder;
struct TanhOptionT;

struct ConstOption;
struct ConstOptionBuilder;
struct ConstOptionT;

struct NoneElementwiseOption;
struct NoneElementwiseOptionBuilder;
struct NoneElementwiseOptionT;

struct AddOption;
struct AddOptionBuilder;
struct AddOptionT;

struct MulOption;
struct MulOptionBuilder;
struct MulOptionT;

struct MinOption;
struct MinOptionBuilder;
struct MinOptionT;

struct MaxOption;
struct MaxOptionBuilder;
struct MaxOptionT;

struct MeanOption;
struct MeanOptionBuilder;
struct MeanOptionT;

struct DivOption;
struct DivOptionBuilder;
struct DivOptionT;

struct GreaterEqualOption;
struct GreaterEqualOptionBuilder;
struct GreaterEqualOptionT;

struct GreaterThanOption;
struct GreaterThanOptionBuilder;
struct GreaterThanOptionT;

struct LessEqualOption;
struct LessEqualOptionBuilder;
struct LessEqualOptionT;

struct LessThanOption;
struct LessThanOptionBuilder;
struct LessThanOptionT;

struct EqualToOption;
struct EqualToOptionBuilder;
struct EqualToOptionT;

struct NotEqualOption;
struct NotEqualOptionBuilder;
struct NotEqualOptionT;

struct ReduceMinOption;
struct ReduceMinOptionBuilder;
struct ReduceMinOptionT;

struct ReduceMaxOption;
struct ReduceMaxOptionBuilder;
struct ReduceMaxOptionT;

struct ReduceMeanOption;
struct ReduceMeanOptionBuilder;
struct ReduceMeanOptionT;

struct ReduceSumOption;
struct ReduceSumOptionBuilder;
struct ReduceSumOptionT;

struct ReduceMulOption;
struct ReduceMulOptionBuilder;
struct ReduceMulOptionT;

struct Pool2DOption;
struct Pool2DOptionBuilder;
struct Pool2DOptionT;

struct Pool3DOption;
struct Pool3DOptionBuilder;
struct Pool3DOptionT;

struct ReshapeOption;
struct ReshapeOptionBuilder;
struct ReshapeOptionT;

struct SliceOption;
struct SliceOptionBuilder;
struct SliceOptionT;

struct FlattenOption;
struct FlattenOptionBuilder;
struct FlattenOptionT;

struct PermuteOption;
struct PermuteOptionBuilder;
struct PermuteOptionT;

struct ArgMaxOption;
struct ArgMaxOptionBuilder;
struct ArgMaxOptionT;

struct BatchNormOption;
struct BatchNormOptionBuilder;
struct BatchNormOptionT;

struct Conv2DOption;
struct Conv2DOptionBuilder;
struct Conv2DOptionT;

struct Conv3DOption;
struct Conv3DOptionBuilder;
struct Conv3DOptionT;

struct InnerProductOption;
struct InnerProductOptionBuilder;
struct InnerProductOptionT;

struct LRNOption;
struct LRNOptionBuilder;
struct LRNOptionT;

struct NormalizeOption;
struct NormalizeOptionBuilder;
struct NormalizeOptionT;

struct PriorBoxOption;
struct PriorBoxOptionBuilder;
struct PriorBoxOptionT;

struct ProposalOption;
struct ProposalOptionBuilder;
struct ProposalOptionT;

struct ResizeOption;
struct ResizeOptionBuilder;
struct ResizeOptionT;

struct RoiPoolingOption;
struct RoiPoolingOptionBuilder;
struct RoiPoolingOptionT;

struct ScaleOption;
struct ScaleOptionBuilder;
struct ScaleOptionT;

struct SoftmaxOption;
struct SoftmaxOptionBuilder;
struct SoftmaxOptionT;

struct InputOption;
struct InputOptionBuilder;
struct InputOptionT;

struct DefaultOption;
struct DefaultOptionBuilder;
struct DefaultOptionT;

inline const flatbuffers::TypeTable *AbsOptionTypeTable();

inline const flatbuffers::TypeTable *BoundedReluOptionTypeTable();

inline const flatbuffers::TypeTable *ClipOptionTypeTable();

inline const flatbuffers::TypeTable *ClipV2OptionTypeTable();

inline const flatbuffers::TypeTable *EluOptionTypeTable();

inline const flatbuffers::TypeTable *ExpOptionTypeTable();

inline const flatbuffers::TypeTable *GeluTanhOptionTypeTable();

inline const flatbuffers::TypeTable *HardSigmoidOptionTypeTable();

inline const flatbuffers::TypeTable *HardSwishOptionTypeTable();

inline const flatbuffers::TypeTable *LinearOptionTypeTable();

inline const flatbuffers::TypeTable *LogOptionTypeTable();

inline const flatbuffers::TypeTable *LogisticOptionTypeTable();

inline const flatbuffers::TypeTable *MishOptionTypeTable();

inline const flatbuffers::TypeTable *PowOptionTypeTable();

inline const flatbuffers::TypeTable *PReluOptionTypeTable();

inline const flatbuffers::TypeTable *ReluOptionTypeTable();

inline const flatbuffers::TypeTable *Relu6OptionTypeTable();

inline const flatbuffers::TypeTable *ClippedReluOptionTypeTable();

inline const flatbuffers::TypeTable *LeakyReluOptionTypeTable();

inline const flatbuffers::TypeTable *LogSigmoidOptionTypeTable();

inline const flatbuffers::TypeTable *RoundOptionTypeTable();

inline const flatbuffers::TypeTable *SeluOptionTypeTable();

inline const flatbuffers::TypeTable *SigmoidOptionTypeTable();

inline const flatbuffers::TypeTable *SoftReluOptionTypeTable();

inline const flatbuffers::TypeTable *SoftReluV2OptionTypeTable();

inline const flatbuffers::TypeTable *SqrtOptionTypeTable();

inline const flatbuffers::TypeTable *SwishOptionTypeTable();

inline const flatbuffers::TypeTable *TanhOptionTypeTable();

inline const flatbuffers::TypeTable *ConstOptionTypeTable();

inline const flatbuffers::TypeTable *NoneElementwiseOptionTypeTable();

inline const flatbuffers::TypeTable *AddOptionTypeTable();

inline const flatbuffers::TypeTable *MulOptionTypeTable();

inline const flatbuffers::TypeTable *MinOptionTypeTable();

inline const flatbuffers::TypeTable *MaxOptionTypeTable();

inline const flatbuffers::TypeTable *MeanOptionTypeTable();

inline const flatbuffers::TypeTable *DivOptionTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualOptionTypeTable();

inline const flatbuffers::TypeTable *GreaterThanOptionTypeTable();

inline const flatbuffers::TypeTable *LessEqualOptionTypeTable();

inline const flatbuffers::TypeTable *LessThanOptionTypeTable();

inline const flatbuffers::TypeTable *EqualToOptionTypeTable();

inline const flatbuffers::TypeTable *NotEqualOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMinOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMaxOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMeanOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceSumOptionTypeTable();

inline const flatbuffers::TypeTable *ReduceMulOptionTypeTable();

inline const flatbuffers::TypeTable *Pool2DOptionTypeTable();

inline const flatbuffers::TypeTable *Pool3DOptionTypeTable();

inline const flatbuffers::TypeTable *ReshapeOptionTypeTable();

inline const flatbuffers::TypeTable *SliceOptionTypeTable();

inline const flatbuffers::TypeTable *FlattenOptionTypeTable();

inline const flatbuffers::TypeTable *PermuteOptionTypeTable();

inline const flatbuffers::TypeTable *ArgMaxOptionTypeTable();

inline const flatbuffers::TypeTable *BatchNormOptionTypeTable();

inline const flatbuffers::TypeTable *Conv2DOptionTypeTable();

inline const flatbuffers::TypeTable *Conv3DOptionTypeTable();

inline const flatbuffers::TypeTable *InnerProductOptionTypeTable();

inline const flatbuffers::TypeTable *LRNOptionTypeTable();

inline const flatbuffers::TypeTable *NormalizeOptionTypeTable();

inline const flatbuffers::TypeTable *PriorBoxOptionTypeTable();

inline const flatbuffers::TypeTable *ProposalOptionTypeTable();

inline const flatbuffers::TypeTable *ResizeOptionTypeTable();

inline const flatbuffers::TypeTable *RoiPoolingOptionTypeTable();

inline const flatbuffers::TypeTable *ScaleOptionTypeTable();

inline const flatbuffers::TypeTable *SoftmaxOptionTypeTable();

inline const flatbuffers::TypeTable *InputOptionTypeTable();

inline const flatbuffers::TypeTable *DefaultOptionTypeTable();

enum ElementwiseOption : uint8_t {
  ElementwiseOption_NONE = 0,
  ElementwiseOption_AbsOption = 1,
  ElementwiseOption_BoundedReluOption = 2,
  ElementwiseOption_ClipOption = 3,
  ElementwiseOption_ClipV2Option = 4,
  ElementwiseOption_ClippedReluOption = 5,
  ElementwiseOption_EluOption = 6,
  ElementwiseOption_ExpOption = 7,
  ElementwiseOption_GeluTanhOption = 8,
  ElementwiseOption_HardSigmoidOption = 9,
  ElementwiseOption_HardSwishOption = 10,
  ElementwiseOption_LeakyReluOption = 11,
  ElementwiseOption_LinearOption = 12,
  ElementwiseOption_LogOption = 13,
  ElementwiseOption_LogisticOption = 14,
  ElementwiseOption_LogSigmoidOption = 15,
  ElementwiseOption_MishOption = 16,
  ElementwiseOption_PowOption = 17,
  ElementwiseOption_PReluOption = 18,
  ElementwiseOption_ReluOption = 19,
  ElementwiseOption_Relu6Option = 20,
  ElementwiseOption_RoundOption = 21,
  ElementwiseOption_SeluOption = 22,
  ElementwiseOption_SigmoidOption = 23,
  ElementwiseOption_SoftReluOption = 24,
  ElementwiseOption_SoftReluV2Option = 25,
  ElementwiseOption_SqrtOption = 26,
  ElementwiseOption_SwishOption = 27,
  ElementwiseOption_TanhOption = 28,
  ElementwiseOption_NoneElementwiseOption = 29,
  ElementwiseOption_MIN = ElementwiseOption_NONE,
  ElementwiseOption_MAX = ElementwiseOption_NoneElementwiseOption
};

inline const ElementwiseOption (&EnumValuesElementwiseOption())[30] {
  static const ElementwiseOption values[] = {
    ElementwiseOption_NONE,
    ElementwiseOption_AbsOption,
    ElementwiseOption_BoundedReluOption,
    ElementwiseOption_ClipOption,
    ElementwiseOption_ClipV2Option,
    ElementwiseOption_ClippedReluOption,
    ElementwiseOption_EluOption,
    ElementwiseOption_ExpOption,
    ElementwiseOption_GeluTanhOption,
    ElementwiseOption_HardSigmoidOption,
    ElementwiseOption_HardSwishOption,
    ElementwiseOption_LeakyReluOption,
    ElementwiseOption_LinearOption,
    ElementwiseOption_LogOption,
    ElementwiseOption_LogisticOption,
    ElementwiseOption_LogSigmoidOption,
    ElementwiseOption_MishOption,
    ElementwiseOption_PowOption,
    ElementwiseOption_PReluOption,
    ElementwiseOption_ReluOption,
    ElementwiseOption_Relu6Option,
    ElementwiseOption_RoundOption,
    ElementwiseOption_SeluOption,
    ElementwiseOption_SigmoidOption,
    ElementwiseOption_SoftReluOption,
    ElementwiseOption_SoftReluV2Option,
    ElementwiseOption_SqrtOption,
    ElementwiseOption_SwishOption,
    ElementwiseOption_TanhOption,
    ElementwiseOption_NoneElementwiseOption
  };
  return values;
}

inline const char * const *EnumNamesElementwiseOption() {
  static const char * const names[31] = {
    "NONE",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "NoneElementwiseOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameElementwiseOption(ElementwiseOption e) {
  if (flatbuffers::IsOutRange(e, ElementwiseOption_NONE, ElementwiseOption_NoneElementwiseOption)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesElementwiseOption()[index];
}

template<typename T> struct ElementwiseOptionTraits {
  static const ElementwiseOption enum_value = ElementwiseOption_NONE;
};

template<> struct ElementwiseOptionTraits<ace::AbsOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_AbsOption;
};

template<> struct ElementwiseOptionTraits<ace::BoundedReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_BoundedReluOption;
};

template<> struct ElementwiseOptionTraits<ace::ClipOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClipOption;
};

template<> struct ElementwiseOptionTraits<ace::ClipV2Option> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClipV2Option;
};

template<> struct ElementwiseOptionTraits<ace::ClippedReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClippedReluOption;
};

template<> struct ElementwiseOptionTraits<ace::EluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_EluOption;
};

template<> struct ElementwiseOptionTraits<ace::ExpOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ExpOption;
};

template<> struct ElementwiseOptionTraits<ace::GeluTanhOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_GeluTanhOption;
};

template<> struct ElementwiseOptionTraits<ace::HardSigmoidOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_HardSigmoidOption;
};

template<> struct ElementwiseOptionTraits<ace::HardSwishOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_HardSwishOption;
};

template<> struct ElementwiseOptionTraits<ace::LeakyReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LeakyReluOption;
};

template<> struct ElementwiseOptionTraits<ace::LinearOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LinearOption;
};

template<> struct ElementwiseOptionTraits<ace::LogOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogOption;
};

template<> struct ElementwiseOptionTraits<ace::LogisticOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogisticOption;
};

template<> struct ElementwiseOptionTraits<ace::LogSigmoidOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogSigmoidOption;
};

template<> struct ElementwiseOptionTraits<ace::MishOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_MishOption;
};

template<> struct ElementwiseOptionTraits<ace::PowOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_PowOption;
};

template<> struct ElementwiseOptionTraits<ace::PReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_PReluOption;
};

template<> struct ElementwiseOptionTraits<ace::ReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_ReluOption;
};

template<> struct ElementwiseOptionTraits<ace::Relu6Option> {
  static const ElementwiseOption enum_value = ElementwiseOption_Relu6Option;
};

template<> struct ElementwiseOptionTraits<ace::RoundOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_RoundOption;
};

template<> struct ElementwiseOptionTraits<ace::SeluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SeluOption;
};

template<> struct ElementwiseOptionTraits<ace::SigmoidOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SigmoidOption;
};

template<> struct ElementwiseOptionTraits<ace::SoftReluOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SoftReluOption;
};

template<> struct ElementwiseOptionTraits<ace::SoftReluV2Option> {
  static const ElementwiseOption enum_value = ElementwiseOption_SoftReluV2Option;
};

template<> struct ElementwiseOptionTraits<ace::SqrtOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SqrtOption;
};

template<> struct ElementwiseOptionTraits<ace::SwishOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_SwishOption;
};

template<> struct ElementwiseOptionTraits<ace::TanhOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_TanhOption;
};

template<> struct ElementwiseOptionTraits<ace::NoneElementwiseOption> {
  static const ElementwiseOption enum_value = ElementwiseOption_NoneElementwiseOption;
};

template<typename T> struct ElementwiseOptionUnionTraits {
  static const ElementwiseOption enum_value = ElementwiseOption_NONE;
};

template<> struct ElementwiseOptionUnionTraits<ace::AbsOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_AbsOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::BoundedReluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_BoundedReluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::ClipOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClipOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::ClipV2OptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClipV2Option;
};

template<> struct ElementwiseOptionUnionTraits<ace::ClippedReluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_ClippedReluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::EluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_EluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::ExpOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_ExpOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::GeluTanhOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_GeluTanhOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::HardSigmoidOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_HardSigmoidOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::HardSwishOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_HardSwishOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::LeakyReluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_LeakyReluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::LinearOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_LinearOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::LogOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::LogisticOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogisticOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::LogSigmoidOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_LogSigmoidOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::MishOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_MishOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::PowOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_PowOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::PReluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_PReluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::ReluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_ReluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::Relu6OptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_Relu6Option;
};

template<> struct ElementwiseOptionUnionTraits<ace::RoundOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_RoundOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::SeluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_SeluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::SigmoidOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_SigmoidOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::SoftReluOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_SoftReluOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::SoftReluV2OptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_SoftReluV2Option;
};

template<> struct ElementwiseOptionUnionTraits<ace::SqrtOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_SqrtOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::SwishOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_SwishOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::TanhOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_TanhOption;
};

template<> struct ElementwiseOptionUnionTraits<ace::NoneElementwiseOptionT> {
  static const ElementwiseOption enum_value = ElementwiseOption_NoneElementwiseOption;
};

struct ElementwiseOptionUnion {
  ElementwiseOption type;
  void *value;

  ElementwiseOptionUnion() : type(ElementwiseOption_NONE), value(nullptr) {}
  ElementwiseOptionUnion(ElementwiseOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ElementwiseOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ElementwiseOptionUnion(const ElementwiseOptionUnion &);
  ElementwiseOptionUnion &operator=(const ElementwiseOptionUnion &u)
    { ElementwiseOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ElementwiseOptionUnion &operator=(ElementwiseOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ElementwiseOptionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ElementwiseOptionUnionTraits<RT>::enum_value;
    if (type != ElementwiseOption_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ElementwiseOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ace::AbsOptionT *AsAbsOption() {
    return type == ElementwiseOption_AbsOption ?
      reinterpret_cast<ace::AbsOptionT *>(value) : nullptr;
  }
  const ace::AbsOptionT *AsAbsOption() const {
    return type == ElementwiseOption_AbsOption ?
      reinterpret_cast<const ace::AbsOptionT *>(value) : nullptr;
  }
  ace::BoundedReluOptionT *AsBoundedReluOption() {
    return type == ElementwiseOption_BoundedReluOption ?
      reinterpret_cast<ace::BoundedReluOptionT *>(value) : nullptr;
  }
  const ace::BoundedReluOptionT *AsBoundedReluOption() const {
    return type == ElementwiseOption_BoundedReluOption ?
      reinterpret_cast<const ace::BoundedReluOptionT *>(value) : nullptr;
  }
  ace::ClipOptionT *AsClipOption() {
    return type == ElementwiseOption_ClipOption ?
      reinterpret_cast<ace::ClipOptionT *>(value) : nullptr;
  }
  const ace::ClipOptionT *AsClipOption() const {
    return type == ElementwiseOption_ClipOption ?
      reinterpret_cast<const ace::ClipOptionT *>(value) : nullptr;
  }
  ace::ClipV2OptionT *AsClipV2Option() {
    return type == ElementwiseOption_ClipV2Option ?
      reinterpret_cast<ace::ClipV2OptionT *>(value) : nullptr;
  }
  const ace::ClipV2OptionT *AsClipV2Option() const {
    return type == ElementwiseOption_ClipV2Option ?
      reinterpret_cast<const ace::ClipV2OptionT *>(value) : nullptr;
  }
  ace::ClippedReluOptionT *AsClippedReluOption() {
    return type == ElementwiseOption_ClippedReluOption ?
      reinterpret_cast<ace::ClippedReluOptionT *>(value) : nullptr;
  }
  const ace::ClippedReluOptionT *AsClippedReluOption() const {
    return type == ElementwiseOption_ClippedReluOption ?
      reinterpret_cast<const ace::ClippedReluOptionT *>(value) : nullptr;
  }
  ace::EluOptionT *AsEluOption() {
    return type == ElementwiseOption_EluOption ?
      reinterpret_cast<ace::EluOptionT *>(value) : nullptr;
  }
  const ace::EluOptionT *AsEluOption() const {
    return type == ElementwiseOption_EluOption ?
      reinterpret_cast<const ace::EluOptionT *>(value) : nullptr;
  }
  ace::ExpOptionT *AsExpOption() {
    return type == ElementwiseOption_ExpOption ?
      reinterpret_cast<ace::ExpOptionT *>(value) : nullptr;
  }
  const ace::ExpOptionT *AsExpOption() const {
    return type == ElementwiseOption_ExpOption ?
      reinterpret_cast<const ace::ExpOptionT *>(value) : nullptr;
  }
  ace::GeluTanhOptionT *AsGeluTanhOption() {
    return type == ElementwiseOption_GeluTanhOption ?
      reinterpret_cast<ace::GeluTanhOptionT *>(value) : nullptr;
  }
  const ace::GeluTanhOptionT *AsGeluTanhOption() const {
    return type == ElementwiseOption_GeluTanhOption ?
      reinterpret_cast<const ace::GeluTanhOptionT *>(value) : nullptr;
  }
  ace::HardSigmoidOptionT *AsHardSigmoidOption() {
    return type == ElementwiseOption_HardSigmoidOption ?
      reinterpret_cast<ace::HardSigmoidOptionT *>(value) : nullptr;
  }
  const ace::HardSigmoidOptionT *AsHardSigmoidOption() const {
    return type == ElementwiseOption_HardSigmoidOption ?
      reinterpret_cast<const ace::HardSigmoidOptionT *>(value) : nullptr;
  }
  ace::HardSwishOptionT *AsHardSwishOption() {
    return type == ElementwiseOption_HardSwishOption ?
      reinterpret_cast<ace::HardSwishOptionT *>(value) : nullptr;
  }
  const ace::HardSwishOptionT *AsHardSwishOption() const {
    return type == ElementwiseOption_HardSwishOption ?
      reinterpret_cast<const ace::HardSwishOptionT *>(value) : nullptr;
  }
  ace::LeakyReluOptionT *AsLeakyReluOption() {
    return type == ElementwiseOption_LeakyReluOption ?
      reinterpret_cast<ace::LeakyReluOptionT *>(value) : nullptr;
  }
  const ace::LeakyReluOptionT *AsLeakyReluOption() const {
    return type == ElementwiseOption_LeakyReluOption ?
      reinterpret_cast<const ace::LeakyReluOptionT *>(value) : nullptr;
  }
  ace::LinearOptionT *AsLinearOption() {
    return type == ElementwiseOption_LinearOption ?
      reinterpret_cast<ace::LinearOptionT *>(value) : nullptr;
  }
  const ace::LinearOptionT *AsLinearOption() const {
    return type == ElementwiseOption_LinearOption ?
      reinterpret_cast<const ace::LinearOptionT *>(value) : nullptr;
  }
  ace::LogOptionT *AsLogOption() {
    return type == ElementwiseOption_LogOption ?
      reinterpret_cast<ace::LogOptionT *>(value) : nullptr;
  }
  const ace::LogOptionT *AsLogOption() const {
    return type == ElementwiseOption_LogOption ?
      reinterpret_cast<const ace::LogOptionT *>(value) : nullptr;
  }
  ace::LogisticOptionT *AsLogisticOption() {
    return type == ElementwiseOption_LogisticOption ?
      reinterpret_cast<ace::LogisticOptionT *>(value) : nullptr;
  }
  const ace::LogisticOptionT *AsLogisticOption() const {
    return type == ElementwiseOption_LogisticOption ?
      reinterpret_cast<const ace::LogisticOptionT *>(value) : nullptr;
  }
  ace::LogSigmoidOptionT *AsLogSigmoidOption() {
    return type == ElementwiseOption_LogSigmoidOption ?
      reinterpret_cast<ace::LogSigmoidOptionT *>(value) : nullptr;
  }
  const ace::LogSigmoidOptionT *AsLogSigmoidOption() const {
    return type == ElementwiseOption_LogSigmoidOption ?
      reinterpret_cast<const ace::LogSigmoidOptionT *>(value) : nullptr;
  }
  ace::MishOptionT *AsMishOption() {
    return type == ElementwiseOption_MishOption ?
      reinterpret_cast<ace::MishOptionT *>(value) : nullptr;
  }
  const ace::MishOptionT *AsMishOption() const {
    return type == ElementwiseOption_MishOption ?
      reinterpret_cast<const ace::MishOptionT *>(value) : nullptr;
  }
  ace::PowOptionT *AsPowOption() {
    return type == ElementwiseOption_PowOption ?
      reinterpret_cast<ace::PowOptionT *>(value) : nullptr;
  }
  const ace::PowOptionT *AsPowOption() const {
    return type == ElementwiseOption_PowOption ?
      reinterpret_cast<const ace::PowOptionT *>(value) : nullptr;
  }
  ace::PReluOptionT *AsPReluOption() {
    return type == ElementwiseOption_PReluOption ?
      reinterpret_cast<ace::PReluOptionT *>(value) : nullptr;
  }
  const ace::PReluOptionT *AsPReluOption() const {
    return type == ElementwiseOption_PReluOption ?
      reinterpret_cast<const ace::PReluOptionT *>(value) : nullptr;
  }
  ace::ReluOptionT *AsReluOption() {
    return type == ElementwiseOption_ReluOption ?
      reinterpret_cast<ace::ReluOptionT *>(value) : nullptr;
  }
  const ace::ReluOptionT *AsReluOption() const {
    return type == ElementwiseOption_ReluOption ?
      reinterpret_cast<const ace::ReluOptionT *>(value) : nullptr;
  }
  ace::Relu6OptionT *AsRelu6Option() {
    return type == ElementwiseOption_Relu6Option ?
      reinterpret_cast<ace::Relu6OptionT *>(value) : nullptr;
  }
  const ace::Relu6OptionT *AsRelu6Option() const {
    return type == ElementwiseOption_Relu6Option ?
      reinterpret_cast<const ace::Relu6OptionT *>(value) : nullptr;
  }
  ace::RoundOptionT *AsRoundOption() {
    return type == ElementwiseOption_RoundOption ?
      reinterpret_cast<ace::RoundOptionT *>(value) : nullptr;
  }
  const ace::RoundOptionT *AsRoundOption() const {
    return type == ElementwiseOption_RoundOption ?
      reinterpret_cast<const ace::RoundOptionT *>(value) : nullptr;
  }
  ace::SeluOptionT *AsSeluOption() {
    return type == ElementwiseOption_SeluOption ?
      reinterpret_cast<ace::SeluOptionT *>(value) : nullptr;
  }
  const ace::SeluOptionT *AsSeluOption() const {
    return type == ElementwiseOption_SeluOption ?
      reinterpret_cast<const ace::SeluOptionT *>(value) : nullptr;
  }
  ace::SigmoidOptionT *AsSigmoidOption() {
    return type == ElementwiseOption_SigmoidOption ?
      reinterpret_cast<ace::SigmoidOptionT *>(value) : nullptr;
  }
  const ace::SigmoidOptionT *AsSigmoidOption() const {
    return type == ElementwiseOption_SigmoidOption ?
      reinterpret_cast<const ace::SigmoidOptionT *>(value) : nullptr;
  }
  ace::SoftReluOptionT *AsSoftReluOption() {
    return type == ElementwiseOption_SoftReluOption ?
      reinterpret_cast<ace::SoftReluOptionT *>(value) : nullptr;
  }
  const ace::SoftReluOptionT *AsSoftReluOption() const {
    return type == ElementwiseOption_SoftReluOption ?
      reinterpret_cast<const ace::SoftReluOptionT *>(value) : nullptr;
  }
  ace::SoftReluV2OptionT *AsSoftReluV2Option() {
    return type == ElementwiseOption_SoftReluV2Option ?
      reinterpret_cast<ace::SoftReluV2OptionT *>(value) : nullptr;
  }
  const ace::SoftReluV2OptionT *AsSoftReluV2Option() const {
    return type == ElementwiseOption_SoftReluV2Option ?
      reinterpret_cast<const ace::SoftReluV2OptionT *>(value) : nullptr;
  }
  ace::SqrtOptionT *AsSqrtOption() {
    return type == ElementwiseOption_SqrtOption ?
      reinterpret_cast<ace::SqrtOptionT *>(value) : nullptr;
  }
  const ace::SqrtOptionT *AsSqrtOption() const {
    return type == ElementwiseOption_SqrtOption ?
      reinterpret_cast<const ace::SqrtOptionT *>(value) : nullptr;
  }
  ace::SwishOptionT *AsSwishOption() {
    return type == ElementwiseOption_SwishOption ?
      reinterpret_cast<ace::SwishOptionT *>(value) : nullptr;
  }
  const ace::SwishOptionT *AsSwishOption() const {
    return type == ElementwiseOption_SwishOption ?
      reinterpret_cast<const ace::SwishOptionT *>(value) : nullptr;
  }
  ace::TanhOptionT *AsTanhOption() {
    return type == ElementwiseOption_TanhOption ?
      reinterpret_cast<ace::TanhOptionT *>(value) : nullptr;
  }
  const ace::TanhOptionT *AsTanhOption() const {
    return type == ElementwiseOption_TanhOption ?
      reinterpret_cast<const ace::TanhOptionT *>(value) : nullptr;
  }
  ace::NoneElementwiseOptionT *AsNoneElementwiseOption() {
    return type == ElementwiseOption_NoneElementwiseOption ?
      reinterpret_cast<ace::NoneElementwiseOptionT *>(value) : nullptr;
  }
  const ace::NoneElementwiseOptionT *AsNoneElementwiseOption() const {
    return type == ElementwiseOption_NoneElementwiseOption ?
      reinterpret_cast<const ace::NoneElementwiseOptionT *>(value) : nullptr;
  }
};

bool VerifyElementwiseOption(flatbuffers::Verifier &verifier, const void *obj, ElementwiseOption type);
bool VerifyElementwiseOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BinaryOption : uint8_t {
  BinaryOption_NONE = 0,
  BinaryOption_AddOption = 1,
  BinaryOption_MulOption = 2,
  BinaryOption_MinOption = 3,
  BinaryOption_MaxOption = 4,
  BinaryOption_MeanOption = 5,
  BinaryOption_DivOption = 6,
  BinaryOption_GreaterEqualOption = 7,
  BinaryOption_GreaterThanOption = 8,
  BinaryOption_LessEqualOption = 9,
  BinaryOption_LessThanOption = 10,
  BinaryOption_EqualToOption = 11,
  BinaryOption_NotEqualOption = 12,
  BinaryOption_MIN = BinaryOption_NONE,
  BinaryOption_MAX = BinaryOption_NotEqualOption
};

inline const BinaryOption (&EnumValuesBinaryOption())[13] {
  static const BinaryOption values[] = {
    BinaryOption_NONE,
    BinaryOption_AddOption,
    BinaryOption_MulOption,
    BinaryOption_MinOption,
    BinaryOption_MaxOption,
    BinaryOption_MeanOption,
    BinaryOption_DivOption,
    BinaryOption_GreaterEqualOption,
    BinaryOption_GreaterThanOption,
    BinaryOption_LessEqualOption,
    BinaryOption_LessThanOption,
    BinaryOption_EqualToOption,
    BinaryOption_NotEqualOption
  };
  return values;
}

inline const char * const *EnumNamesBinaryOption() {
  static const char * const names[14] = {
    "NONE",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameBinaryOption(BinaryOption e) {
  if (flatbuffers::IsOutRange(e, BinaryOption_NONE, BinaryOption_NotEqualOption)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBinaryOption()[index];
}

template<typename T> struct BinaryOptionTraits {
  static const BinaryOption enum_value = BinaryOption_NONE;
};

template<> struct BinaryOptionTraits<ace::AddOption> {
  static const BinaryOption enum_value = BinaryOption_AddOption;
};

template<> struct BinaryOptionTraits<ace::MulOption> {
  static const BinaryOption enum_value = BinaryOption_MulOption;
};

template<> struct BinaryOptionTraits<ace::MinOption> {
  static const BinaryOption enum_value = BinaryOption_MinOption;
};

template<> struct BinaryOptionTraits<ace::MaxOption> {
  static const BinaryOption enum_value = BinaryOption_MaxOption;
};

template<> struct BinaryOptionTraits<ace::MeanOption> {
  static const BinaryOption enum_value = BinaryOption_MeanOption;
};

template<> struct BinaryOptionTraits<ace::DivOption> {
  static const BinaryOption enum_value = BinaryOption_DivOption;
};

template<> struct BinaryOptionTraits<ace::GreaterEqualOption> {
  static const BinaryOption enum_value = BinaryOption_GreaterEqualOption;
};

template<> struct BinaryOptionTraits<ace::GreaterThanOption> {
  static const BinaryOption enum_value = BinaryOption_GreaterThanOption;
};

template<> struct BinaryOptionTraits<ace::LessEqualOption> {
  static const BinaryOption enum_value = BinaryOption_LessEqualOption;
};

template<> struct BinaryOptionTraits<ace::LessThanOption> {
  static const BinaryOption enum_value = BinaryOption_LessThanOption;
};

template<> struct BinaryOptionTraits<ace::EqualToOption> {
  static const BinaryOption enum_value = BinaryOption_EqualToOption;
};

template<> struct BinaryOptionTraits<ace::NotEqualOption> {
  static const BinaryOption enum_value = BinaryOption_NotEqualOption;
};

template<typename T> struct BinaryOptionUnionTraits {
  static const BinaryOption enum_value = BinaryOption_NONE;
};

template<> struct BinaryOptionUnionTraits<ace::AddOptionT> {
  static const BinaryOption enum_value = BinaryOption_AddOption;
};

template<> struct BinaryOptionUnionTraits<ace::MulOptionT> {
  static const BinaryOption enum_value = BinaryOption_MulOption;
};

template<> struct BinaryOptionUnionTraits<ace::MinOptionT> {
  static const BinaryOption enum_value = BinaryOption_MinOption;
};

template<> struct BinaryOptionUnionTraits<ace::MaxOptionT> {
  static const BinaryOption enum_value = BinaryOption_MaxOption;
};

template<> struct BinaryOptionUnionTraits<ace::MeanOptionT> {
  static const BinaryOption enum_value = BinaryOption_MeanOption;
};

template<> struct BinaryOptionUnionTraits<ace::DivOptionT> {
  static const BinaryOption enum_value = BinaryOption_DivOption;
};

template<> struct BinaryOptionUnionTraits<ace::GreaterEqualOptionT> {
  static const BinaryOption enum_value = BinaryOption_GreaterEqualOption;
};

template<> struct BinaryOptionUnionTraits<ace::GreaterThanOptionT> {
  static const BinaryOption enum_value = BinaryOption_GreaterThanOption;
};

template<> struct BinaryOptionUnionTraits<ace::LessEqualOptionT> {
  static const BinaryOption enum_value = BinaryOption_LessEqualOption;
};

template<> struct BinaryOptionUnionTraits<ace::LessThanOptionT> {
  static const BinaryOption enum_value = BinaryOption_LessThanOption;
};

template<> struct BinaryOptionUnionTraits<ace::EqualToOptionT> {
  static const BinaryOption enum_value = BinaryOption_EqualToOption;
};

template<> struct BinaryOptionUnionTraits<ace::NotEqualOptionT> {
  static const BinaryOption enum_value = BinaryOption_NotEqualOption;
};

struct BinaryOptionUnion {
  BinaryOption type;
  void *value;

  BinaryOptionUnion() : type(BinaryOption_NONE), value(nullptr) {}
  BinaryOptionUnion(BinaryOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BinaryOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BinaryOptionUnion(const BinaryOptionUnion &);
  BinaryOptionUnion &operator=(const BinaryOptionUnion &u)
    { BinaryOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BinaryOptionUnion &operator=(BinaryOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BinaryOptionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BinaryOptionUnionTraits<RT>::enum_value;
    if (type != BinaryOption_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BinaryOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ace::AddOptionT *AsAddOption() {
    return type == BinaryOption_AddOption ?
      reinterpret_cast<ace::AddOptionT *>(value) : nullptr;
  }
  const ace::AddOptionT *AsAddOption() const {
    return type == BinaryOption_AddOption ?
      reinterpret_cast<const ace::AddOptionT *>(value) : nullptr;
  }
  ace::MulOptionT *AsMulOption() {
    return type == BinaryOption_MulOption ?
      reinterpret_cast<ace::MulOptionT *>(value) : nullptr;
  }
  const ace::MulOptionT *AsMulOption() const {
    return type == BinaryOption_MulOption ?
      reinterpret_cast<const ace::MulOptionT *>(value) : nullptr;
  }
  ace::MinOptionT *AsMinOption() {
    return type == BinaryOption_MinOption ?
      reinterpret_cast<ace::MinOptionT *>(value) : nullptr;
  }
  const ace::MinOptionT *AsMinOption() const {
    return type == BinaryOption_MinOption ?
      reinterpret_cast<const ace::MinOptionT *>(value) : nullptr;
  }
  ace::MaxOptionT *AsMaxOption() {
    return type == BinaryOption_MaxOption ?
      reinterpret_cast<ace::MaxOptionT *>(value) : nullptr;
  }
  const ace::MaxOptionT *AsMaxOption() const {
    return type == BinaryOption_MaxOption ?
      reinterpret_cast<const ace::MaxOptionT *>(value) : nullptr;
  }
  ace::MeanOptionT *AsMeanOption() {
    return type == BinaryOption_MeanOption ?
      reinterpret_cast<ace::MeanOptionT *>(value) : nullptr;
  }
  const ace::MeanOptionT *AsMeanOption() const {
    return type == BinaryOption_MeanOption ?
      reinterpret_cast<const ace::MeanOptionT *>(value) : nullptr;
  }
  ace::DivOptionT *AsDivOption() {
    return type == BinaryOption_DivOption ?
      reinterpret_cast<ace::DivOptionT *>(value) : nullptr;
  }
  const ace::DivOptionT *AsDivOption() const {
    return type == BinaryOption_DivOption ?
      reinterpret_cast<const ace::DivOptionT *>(value) : nullptr;
  }
  ace::GreaterEqualOptionT *AsGreaterEqualOption() {
    return type == BinaryOption_GreaterEqualOption ?
      reinterpret_cast<ace::GreaterEqualOptionT *>(value) : nullptr;
  }
  const ace::GreaterEqualOptionT *AsGreaterEqualOption() const {
    return type == BinaryOption_GreaterEqualOption ?
      reinterpret_cast<const ace::GreaterEqualOptionT *>(value) : nullptr;
  }
  ace::GreaterThanOptionT *AsGreaterThanOption() {
    return type == BinaryOption_GreaterThanOption ?
      reinterpret_cast<ace::GreaterThanOptionT *>(value) : nullptr;
  }
  const ace::GreaterThanOptionT *AsGreaterThanOption() const {
    return type == BinaryOption_GreaterThanOption ?
      reinterpret_cast<const ace::GreaterThanOptionT *>(value) : nullptr;
  }
  ace::LessEqualOptionT *AsLessEqualOption() {
    return type == BinaryOption_LessEqualOption ?
      reinterpret_cast<ace::LessEqualOptionT *>(value) : nullptr;
  }
  const ace::LessEqualOptionT *AsLessEqualOption() const {
    return type == BinaryOption_LessEqualOption ?
      reinterpret_cast<const ace::LessEqualOptionT *>(value) : nullptr;
  }
  ace::LessThanOptionT *AsLessThanOption() {
    return type == BinaryOption_LessThanOption ?
      reinterpret_cast<ace::LessThanOptionT *>(value) : nullptr;
  }
  const ace::LessThanOptionT *AsLessThanOption() const {
    return type == BinaryOption_LessThanOption ?
      reinterpret_cast<const ace::LessThanOptionT *>(value) : nullptr;
  }
  ace::EqualToOptionT *AsEqualToOption() {
    return type == BinaryOption_EqualToOption ?
      reinterpret_cast<ace::EqualToOptionT *>(value) : nullptr;
  }
  const ace::EqualToOptionT *AsEqualToOption() const {
    return type == BinaryOption_EqualToOption ?
      reinterpret_cast<const ace::EqualToOptionT *>(value) : nullptr;
  }
  ace::NotEqualOptionT *AsNotEqualOption() {
    return type == BinaryOption_NotEqualOption ?
      reinterpret_cast<ace::NotEqualOptionT *>(value) : nullptr;
  }
  const ace::NotEqualOptionT *AsNotEqualOption() const {
    return type == BinaryOption_NotEqualOption ?
      reinterpret_cast<const ace::NotEqualOptionT *>(value) : nullptr;
  }
};

bool VerifyBinaryOption(flatbuffers::Verifier &verifier, const void *obj, BinaryOption type);
bool VerifyBinaryOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ReduceOption : uint8_t {
  ReduceOption_NONE = 0,
  ReduceOption_ReduceMinOption = 1,
  ReduceOption_ReduceMaxOption = 2,
  ReduceOption_ReduceMeanOption = 3,
  ReduceOption_ReduceSumOption = 4,
  ReduceOption_ReduceMulOption = 5,
  ReduceOption_MIN = ReduceOption_NONE,
  ReduceOption_MAX = ReduceOption_ReduceMulOption
};

inline const ReduceOption (&EnumValuesReduceOption())[6] {
  static const ReduceOption values[] = {
    ReduceOption_NONE,
    ReduceOption_ReduceMinOption,
    ReduceOption_ReduceMaxOption,
    ReduceOption_ReduceMeanOption,
    ReduceOption_ReduceSumOption,
    ReduceOption_ReduceMulOption
  };
  return values;
}

inline const char * const *EnumNamesReduceOption() {
  static const char * const names[7] = {
    "NONE",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceOption(ReduceOption e) {
  if (flatbuffers::IsOutRange(e, ReduceOption_NONE, ReduceOption_ReduceMulOption)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceOption()[index];
}

template<typename T> struct ReduceOptionTraits {
  static const ReduceOption enum_value = ReduceOption_NONE;
};

template<> struct ReduceOptionTraits<ace::ReduceMinOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMinOption;
};

template<> struct ReduceOptionTraits<ace::ReduceMaxOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMaxOption;
};

template<> struct ReduceOptionTraits<ace::ReduceMeanOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMeanOption;
};

template<> struct ReduceOptionTraits<ace::ReduceSumOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceSumOption;
};

template<> struct ReduceOptionTraits<ace::ReduceMulOption> {
  static const ReduceOption enum_value = ReduceOption_ReduceMulOption;
};

template<typename T> struct ReduceOptionUnionTraits {
  static const ReduceOption enum_value = ReduceOption_NONE;
};

template<> struct ReduceOptionUnionTraits<ace::ReduceMinOptionT> {
  static const ReduceOption enum_value = ReduceOption_ReduceMinOption;
};

template<> struct ReduceOptionUnionTraits<ace::ReduceMaxOptionT> {
  static const ReduceOption enum_value = ReduceOption_ReduceMaxOption;
};

template<> struct ReduceOptionUnionTraits<ace::ReduceMeanOptionT> {
  static const ReduceOption enum_value = ReduceOption_ReduceMeanOption;
};

template<> struct ReduceOptionUnionTraits<ace::ReduceSumOptionT> {
  static const ReduceOption enum_value = ReduceOption_ReduceSumOption;
};

template<> struct ReduceOptionUnionTraits<ace::ReduceMulOptionT> {
  static const ReduceOption enum_value = ReduceOption_ReduceMulOption;
};

struct ReduceOptionUnion {
  ReduceOption type;
  void *value;

  ReduceOptionUnion() : type(ReduceOption_NONE), value(nullptr) {}
  ReduceOptionUnion(ReduceOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ReduceOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ReduceOptionUnion(const ReduceOptionUnion &);
  ReduceOptionUnion &operator=(const ReduceOptionUnion &u)
    { ReduceOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ReduceOptionUnion &operator=(ReduceOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ReduceOptionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ReduceOptionUnionTraits<RT>::enum_value;
    if (type != ReduceOption_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ReduceOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ace::ReduceMinOptionT *AsReduceMinOption() {
    return type == ReduceOption_ReduceMinOption ?
      reinterpret_cast<ace::ReduceMinOptionT *>(value) : nullptr;
  }
  const ace::ReduceMinOptionT *AsReduceMinOption() const {
    return type == ReduceOption_ReduceMinOption ?
      reinterpret_cast<const ace::ReduceMinOptionT *>(value) : nullptr;
  }
  ace::ReduceMaxOptionT *AsReduceMaxOption() {
    return type == ReduceOption_ReduceMaxOption ?
      reinterpret_cast<ace::ReduceMaxOptionT *>(value) : nullptr;
  }
  const ace::ReduceMaxOptionT *AsReduceMaxOption() const {
    return type == ReduceOption_ReduceMaxOption ?
      reinterpret_cast<const ace::ReduceMaxOptionT *>(value) : nullptr;
  }
  ace::ReduceMeanOptionT *AsReduceMeanOption() {
    return type == ReduceOption_ReduceMeanOption ?
      reinterpret_cast<ace::ReduceMeanOptionT *>(value) : nullptr;
  }
  const ace::ReduceMeanOptionT *AsReduceMeanOption() const {
    return type == ReduceOption_ReduceMeanOption ?
      reinterpret_cast<const ace::ReduceMeanOptionT *>(value) : nullptr;
  }
  ace::ReduceSumOptionT *AsReduceSumOption() {
    return type == ReduceOption_ReduceSumOption ?
      reinterpret_cast<ace::ReduceSumOptionT *>(value) : nullptr;
  }
  const ace::ReduceSumOptionT *AsReduceSumOption() const {
    return type == ReduceOption_ReduceSumOption ?
      reinterpret_cast<const ace::ReduceSumOptionT *>(value) : nullptr;
  }
  ace::ReduceMulOptionT *AsReduceMulOption() {
    return type == ReduceOption_ReduceMulOption ?
      reinterpret_cast<ace::ReduceMulOptionT *>(value) : nullptr;
  }
  const ace::ReduceMulOptionT *AsReduceMulOption() const {
    return type == ReduceOption_ReduceMulOption ?
      reinterpret_cast<const ace::ReduceMulOptionT *>(value) : nullptr;
  }
};

bool VerifyReduceOption(flatbuffers::Verifier &verifier, const void *obj, ReduceOption type);
bool VerifyReduceOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum PoolType : int8_t {
  PoolType_MAX_POOL = 0,
  PoolType_AVG_POOL = 1,
  PoolType_GLOBAL_MAX_POOL = 2,
  PoolType_GLOBAL_AVG_POOL = 3,
  PoolType_MIN = PoolType_MAX_POOL,
  PoolType_MAX = PoolType_GLOBAL_AVG_POOL
};

inline const PoolType (&EnumValuesPoolType())[4] {
  static const PoolType values[] = {
    PoolType_MAX_POOL,
    PoolType_AVG_POOL,
    PoolType_GLOBAL_MAX_POOL,
    PoolType_GLOBAL_AVG_POOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[5] = {
    "MAX_POOL",
    "AVG_POOL",
    "GLOBAL_MAX_POOL",
    "GLOBAL_AVG_POOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (flatbuffers::IsOutRange(e, PoolType_MAX_POOL, PoolType_GLOBAL_AVG_POOL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolType()[index];
}

enum PaddingType : int8_t {
  PaddingType_VALID = 0,
  PaddingType_SAME = 1,
  PaddingType_MIN = PaddingType_VALID,
  PaddingType_MAX = PaddingType_SAME
};

inline const PaddingType (&EnumValuesPaddingType())[2] {
  static const PaddingType values[] = {
    PaddingType_VALID,
    PaddingType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPaddingType() {
  static const char * const names[3] = {
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingType(PaddingType e) {
  if (flatbuffers::IsOutRange(e, PaddingType_VALID, PaddingType_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPaddingType()[index];
}

enum PadMode : int8_t {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_CAFFE, PadMode_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum OpOption : uint8_t {
  OpOption_NONE = 0,
  OpOption_DefaultOption = 1,
  OpOption_ConstOption = 2,
  OpOption_AbsOption = 3,
  OpOption_BoundedReluOption = 4,
  OpOption_ClipOption = 5,
  OpOption_ClipV2Option = 6,
  OpOption_ClippedReluOption = 7,
  OpOption_EluOption = 8,
  OpOption_ExpOption = 9,
  OpOption_GeluTanhOption = 10,
  OpOption_HardSigmoidOption = 11,
  OpOption_HardSwishOption = 12,
  OpOption_LeakyReluOption = 13,
  OpOption_LinearOption = 14,
  OpOption_LogOption = 15,
  OpOption_LogisticOption = 16,
  OpOption_LogSigmoidOption = 17,
  OpOption_MishOption = 18,
  OpOption_PowOption = 19,
  OpOption_PReluOption = 20,
  OpOption_ReluOption = 21,
  OpOption_Relu6Option = 22,
  OpOption_RoundOption = 23,
  OpOption_SeluOption = 24,
  OpOption_SigmoidOption = 25,
  OpOption_SoftReluOption = 26,
  OpOption_SoftReluV2Option = 27,
  OpOption_SqrtOption = 28,
  OpOption_SwishOption = 29,
  OpOption_TanhOption = 30,
  OpOption_AddOption = 31,
  OpOption_MulOption = 32,
  OpOption_MinOption = 33,
  OpOption_MaxOption = 34,
  OpOption_MeanOption = 35,
  OpOption_DivOption = 36,
  OpOption_GreaterEqualOption = 37,
  OpOption_GreaterThanOption = 38,
  OpOption_LessEqualOption = 39,
  OpOption_LessThanOption = 40,
  OpOption_EqualToOption = 41,
  OpOption_NotEqualOption = 42,
  OpOption_ReduceMinOption = 43,
  OpOption_ReduceMaxOption = 44,
  OpOption_ReduceMeanOption = 45,
  OpOption_ReduceSumOption = 46,
  OpOption_ReduceMulOption = 47,
  OpOption_Pool2DOption = 48,
  OpOption_Pool3DOption = 49,
  OpOption_ReshapeOption = 50,
  OpOption_SliceOption = 51,
  OpOption_FlattenOption = 52,
  OpOption_PermuteOption = 53,
  OpOption_ArgMaxOption = 54,
  OpOption_BatchNormOption = 55,
  OpOption_Conv2DOption = 56,
  OpOption_Conv3DOption = 57,
  OpOption_InnerProductOption = 58,
  OpOption_LRNOption = 59,
  OpOption_NormalizeOption = 60,
  OpOption_PriorBoxOption = 61,
  OpOption_ProposalOption = 62,
  OpOption_ResizeOption = 63,
  OpOption_RoiPoolingOption = 64,
  OpOption_ScaleOption = 65,
  OpOption_SoftmaxOption = 66,
  OpOption_InputOption = 67,
  OpOption_MIN = OpOption_NONE,
  OpOption_MAX = OpOption_InputOption
};

inline const OpOption (&EnumValuesOpOption())[68] {
  static const OpOption values[] = {
    OpOption_NONE,
    OpOption_DefaultOption,
    OpOption_ConstOption,
    OpOption_AbsOption,
    OpOption_BoundedReluOption,
    OpOption_ClipOption,
    OpOption_ClipV2Option,
    OpOption_ClippedReluOption,
    OpOption_EluOption,
    OpOption_ExpOption,
    OpOption_GeluTanhOption,
    OpOption_HardSigmoidOption,
    OpOption_HardSwishOption,
    OpOption_LeakyReluOption,
    OpOption_LinearOption,
    OpOption_LogOption,
    OpOption_LogisticOption,
    OpOption_LogSigmoidOption,
    OpOption_MishOption,
    OpOption_PowOption,
    OpOption_PReluOption,
    OpOption_ReluOption,
    OpOption_Relu6Option,
    OpOption_RoundOption,
    OpOption_SeluOption,
    OpOption_SigmoidOption,
    OpOption_SoftReluOption,
    OpOption_SoftReluV2Option,
    OpOption_SqrtOption,
    OpOption_SwishOption,
    OpOption_TanhOption,
    OpOption_AddOption,
    OpOption_MulOption,
    OpOption_MinOption,
    OpOption_MaxOption,
    OpOption_MeanOption,
    OpOption_DivOption,
    OpOption_GreaterEqualOption,
    OpOption_GreaterThanOption,
    OpOption_LessEqualOption,
    OpOption_LessThanOption,
    OpOption_EqualToOption,
    OpOption_NotEqualOption,
    OpOption_ReduceMinOption,
    OpOption_ReduceMaxOption,
    OpOption_ReduceMeanOption,
    OpOption_ReduceSumOption,
    OpOption_ReduceMulOption,
    OpOption_Pool2DOption,
    OpOption_Pool3DOption,
    OpOption_ReshapeOption,
    OpOption_SliceOption,
    OpOption_FlattenOption,
    OpOption_PermuteOption,
    OpOption_ArgMaxOption,
    OpOption_BatchNormOption,
    OpOption_Conv2DOption,
    OpOption_Conv3DOption,
    OpOption_InnerProductOption,
    OpOption_LRNOption,
    OpOption_NormalizeOption,
    OpOption_PriorBoxOption,
    OpOption_ProposalOption,
    OpOption_ResizeOption,
    OpOption_RoiPoolingOption,
    OpOption_ScaleOption,
    OpOption_SoftmaxOption,
    OpOption_InputOption
  };
  return values;
}

inline const char * const *EnumNamesOpOption() {
  static const char * const names[69] = {
    "NONE",
    "DefaultOption",
    "ConstOption",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption",
    "Pool2DOption",
    "Pool3DOption",
    "ReshapeOption",
    "SliceOption",
    "FlattenOption",
    "PermuteOption",
    "ArgMaxOption",
    "BatchNormOption",
    "Conv2DOption",
    "Conv3DOption",
    "InnerProductOption",
    "LRNOption",
    "NormalizeOption",
    "PriorBoxOption",
    "ProposalOption",
    "ResizeOption",
    "RoiPoolingOption",
    "ScaleOption",
    "SoftmaxOption",
    "InputOption",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpOption(OpOption e) {
  if (flatbuffers::IsOutRange(e, OpOption_NONE, OpOption_InputOption)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpOption()[index];
}

template<typename T> struct OpOptionTraits {
  static const OpOption enum_value = OpOption_NONE;
};

template<> struct OpOptionTraits<ace::DefaultOption> {
  static const OpOption enum_value = OpOption_DefaultOption;
};

template<> struct OpOptionTraits<ace::ConstOption> {
  static const OpOption enum_value = OpOption_ConstOption;
};

template<> struct OpOptionTraits<ace::AbsOption> {
  static const OpOption enum_value = OpOption_AbsOption;
};

template<> struct OpOptionTraits<ace::BoundedReluOption> {
  static const OpOption enum_value = OpOption_BoundedReluOption;
};

template<> struct OpOptionTraits<ace::ClipOption> {
  static const OpOption enum_value = OpOption_ClipOption;
};

template<> struct OpOptionTraits<ace::ClipV2Option> {
  static const OpOption enum_value = OpOption_ClipV2Option;
};

template<> struct OpOptionTraits<ace::ClippedReluOption> {
  static const OpOption enum_value = OpOption_ClippedReluOption;
};

template<> struct OpOptionTraits<ace::EluOption> {
  static const OpOption enum_value = OpOption_EluOption;
};

template<> struct OpOptionTraits<ace::ExpOption> {
  static const OpOption enum_value = OpOption_ExpOption;
};

template<> struct OpOptionTraits<ace::GeluTanhOption> {
  static const OpOption enum_value = OpOption_GeluTanhOption;
};

template<> struct OpOptionTraits<ace::HardSigmoidOption> {
  static const OpOption enum_value = OpOption_HardSigmoidOption;
};

template<> struct OpOptionTraits<ace::HardSwishOption> {
  static const OpOption enum_value = OpOption_HardSwishOption;
};

template<> struct OpOptionTraits<ace::LeakyReluOption> {
  static const OpOption enum_value = OpOption_LeakyReluOption;
};

template<> struct OpOptionTraits<ace::LinearOption> {
  static const OpOption enum_value = OpOption_LinearOption;
};

template<> struct OpOptionTraits<ace::LogOption> {
  static const OpOption enum_value = OpOption_LogOption;
};

template<> struct OpOptionTraits<ace::LogisticOption> {
  static const OpOption enum_value = OpOption_LogisticOption;
};

template<> struct OpOptionTraits<ace::LogSigmoidOption> {
  static const OpOption enum_value = OpOption_LogSigmoidOption;
};

template<> struct OpOptionTraits<ace::MishOption> {
  static const OpOption enum_value = OpOption_MishOption;
};

template<> struct OpOptionTraits<ace::PowOption> {
  static const OpOption enum_value = OpOption_PowOption;
};

template<> struct OpOptionTraits<ace::PReluOption> {
  static const OpOption enum_value = OpOption_PReluOption;
};

template<> struct OpOptionTraits<ace::ReluOption> {
  static const OpOption enum_value = OpOption_ReluOption;
};

template<> struct OpOptionTraits<ace::Relu6Option> {
  static const OpOption enum_value = OpOption_Relu6Option;
};

template<> struct OpOptionTraits<ace::RoundOption> {
  static const OpOption enum_value = OpOption_RoundOption;
};

template<> struct OpOptionTraits<ace::SeluOption> {
  static const OpOption enum_value = OpOption_SeluOption;
};

template<> struct OpOptionTraits<ace::SigmoidOption> {
  static const OpOption enum_value = OpOption_SigmoidOption;
};

template<> struct OpOptionTraits<ace::SoftReluOption> {
  static const OpOption enum_value = OpOption_SoftReluOption;
};

template<> struct OpOptionTraits<ace::SoftReluV2Option> {
  static const OpOption enum_value = OpOption_SoftReluV2Option;
};

template<> struct OpOptionTraits<ace::SqrtOption> {
  static const OpOption enum_value = OpOption_SqrtOption;
};

template<> struct OpOptionTraits<ace::SwishOption> {
  static const OpOption enum_value = OpOption_SwishOption;
};

template<> struct OpOptionTraits<ace::TanhOption> {
  static const OpOption enum_value = OpOption_TanhOption;
};

template<> struct OpOptionTraits<ace::AddOption> {
  static const OpOption enum_value = OpOption_AddOption;
};

template<> struct OpOptionTraits<ace::MulOption> {
  static const OpOption enum_value = OpOption_MulOption;
};

template<> struct OpOptionTraits<ace::MinOption> {
  static const OpOption enum_value = OpOption_MinOption;
};

template<> struct OpOptionTraits<ace::MaxOption> {
  static const OpOption enum_value = OpOption_MaxOption;
};

template<> struct OpOptionTraits<ace::MeanOption> {
  static const OpOption enum_value = OpOption_MeanOption;
};

template<> struct OpOptionTraits<ace::DivOption> {
  static const OpOption enum_value = OpOption_DivOption;
};

template<> struct OpOptionTraits<ace::GreaterEqualOption> {
  static const OpOption enum_value = OpOption_GreaterEqualOption;
};

template<> struct OpOptionTraits<ace::GreaterThanOption> {
  static const OpOption enum_value = OpOption_GreaterThanOption;
};

template<> struct OpOptionTraits<ace::LessEqualOption> {
  static const OpOption enum_value = OpOption_LessEqualOption;
};

template<> struct OpOptionTraits<ace::LessThanOption> {
  static const OpOption enum_value = OpOption_LessThanOption;
};

template<> struct OpOptionTraits<ace::EqualToOption> {
  static const OpOption enum_value = OpOption_EqualToOption;
};

template<> struct OpOptionTraits<ace::NotEqualOption> {
  static const OpOption enum_value = OpOption_NotEqualOption;
};

template<> struct OpOptionTraits<ace::ReduceMinOption> {
  static const OpOption enum_value = OpOption_ReduceMinOption;
};

template<> struct OpOptionTraits<ace::ReduceMaxOption> {
  static const OpOption enum_value = OpOption_ReduceMaxOption;
};

template<> struct OpOptionTraits<ace::ReduceMeanOption> {
  static const OpOption enum_value = OpOption_ReduceMeanOption;
};

template<> struct OpOptionTraits<ace::ReduceSumOption> {
  static const OpOption enum_value = OpOption_ReduceSumOption;
};

template<> struct OpOptionTraits<ace::ReduceMulOption> {
  static const OpOption enum_value = OpOption_ReduceMulOption;
};

template<> struct OpOptionTraits<ace::Pool2DOption> {
  static const OpOption enum_value = OpOption_Pool2DOption;
};

template<> struct OpOptionTraits<ace::Pool3DOption> {
  static const OpOption enum_value = OpOption_Pool3DOption;
};

template<> struct OpOptionTraits<ace::ReshapeOption> {
  static const OpOption enum_value = OpOption_ReshapeOption;
};

template<> struct OpOptionTraits<ace::SliceOption> {
  static const OpOption enum_value = OpOption_SliceOption;
};

template<> struct OpOptionTraits<ace::FlattenOption> {
  static const OpOption enum_value = OpOption_FlattenOption;
};

template<> struct OpOptionTraits<ace::PermuteOption> {
  static const OpOption enum_value = OpOption_PermuteOption;
};

template<> struct OpOptionTraits<ace::ArgMaxOption> {
  static const OpOption enum_value = OpOption_ArgMaxOption;
};

template<> struct OpOptionTraits<ace::BatchNormOption> {
  static const OpOption enum_value = OpOption_BatchNormOption;
};

template<> struct OpOptionTraits<ace::Conv2DOption> {
  static const OpOption enum_value = OpOption_Conv2DOption;
};

template<> struct OpOptionTraits<ace::Conv3DOption> {
  static const OpOption enum_value = OpOption_Conv3DOption;
};

template<> struct OpOptionTraits<ace::InnerProductOption> {
  static const OpOption enum_value = OpOption_InnerProductOption;
};

template<> struct OpOptionTraits<ace::LRNOption> {
  static const OpOption enum_value = OpOption_LRNOption;
};

template<> struct OpOptionTraits<ace::NormalizeOption> {
  static const OpOption enum_value = OpOption_NormalizeOption;
};

template<> struct OpOptionTraits<ace::PriorBoxOption> {
  static const OpOption enum_value = OpOption_PriorBoxOption;
};

template<> struct OpOptionTraits<ace::ProposalOption> {
  static const OpOption enum_value = OpOption_ProposalOption;
};

template<> struct OpOptionTraits<ace::ResizeOption> {
  static const OpOption enum_value = OpOption_ResizeOption;
};

template<> struct OpOptionTraits<ace::RoiPoolingOption> {
  static const OpOption enum_value = OpOption_RoiPoolingOption;
};

template<> struct OpOptionTraits<ace::ScaleOption> {
  static const OpOption enum_value = OpOption_ScaleOption;
};

template<> struct OpOptionTraits<ace::SoftmaxOption> {
  static const OpOption enum_value = OpOption_SoftmaxOption;
};

template<> struct OpOptionTraits<ace::InputOption> {
  static const OpOption enum_value = OpOption_InputOption;
};

template<typename T> struct OpOptionUnionTraits {
  static const OpOption enum_value = OpOption_NONE;
};

template<> struct OpOptionUnionTraits<ace::DefaultOptionT> {
  static const OpOption enum_value = OpOption_DefaultOption;
};

template<> struct OpOptionUnionTraits<ace::ConstOptionT> {
  static const OpOption enum_value = OpOption_ConstOption;
};

template<> struct OpOptionUnionTraits<ace::AbsOptionT> {
  static const OpOption enum_value = OpOption_AbsOption;
};

template<> struct OpOptionUnionTraits<ace::BoundedReluOptionT> {
  static const OpOption enum_value = OpOption_BoundedReluOption;
};

template<> struct OpOptionUnionTraits<ace::ClipOptionT> {
  static const OpOption enum_value = OpOption_ClipOption;
};

template<> struct OpOptionUnionTraits<ace::ClipV2OptionT> {
  static const OpOption enum_value = OpOption_ClipV2Option;
};

template<> struct OpOptionUnionTraits<ace::ClippedReluOptionT> {
  static const OpOption enum_value = OpOption_ClippedReluOption;
};

template<> struct OpOptionUnionTraits<ace::EluOptionT> {
  static const OpOption enum_value = OpOption_EluOption;
};

template<> struct OpOptionUnionTraits<ace::ExpOptionT> {
  static const OpOption enum_value = OpOption_ExpOption;
};

template<> struct OpOptionUnionTraits<ace::GeluTanhOptionT> {
  static const OpOption enum_value = OpOption_GeluTanhOption;
};

template<> struct OpOptionUnionTraits<ace::HardSigmoidOptionT> {
  static const OpOption enum_value = OpOption_HardSigmoidOption;
};

template<> struct OpOptionUnionTraits<ace::HardSwishOptionT> {
  static const OpOption enum_value = OpOption_HardSwishOption;
};

template<> struct OpOptionUnionTraits<ace::LeakyReluOptionT> {
  static const OpOption enum_value = OpOption_LeakyReluOption;
};

template<> struct OpOptionUnionTraits<ace::LinearOptionT> {
  static const OpOption enum_value = OpOption_LinearOption;
};

template<> struct OpOptionUnionTraits<ace::LogOptionT> {
  static const OpOption enum_value = OpOption_LogOption;
};

template<> struct OpOptionUnionTraits<ace::LogisticOptionT> {
  static const OpOption enum_value = OpOption_LogisticOption;
};

template<> struct OpOptionUnionTraits<ace::LogSigmoidOptionT> {
  static const OpOption enum_value = OpOption_LogSigmoidOption;
};

template<> struct OpOptionUnionTraits<ace::MishOptionT> {
  static const OpOption enum_value = OpOption_MishOption;
};

template<> struct OpOptionUnionTraits<ace::PowOptionT> {
  static const OpOption enum_value = OpOption_PowOption;
};

template<> struct OpOptionUnionTraits<ace::PReluOptionT> {
  static const OpOption enum_value = OpOption_PReluOption;
};

template<> struct OpOptionUnionTraits<ace::ReluOptionT> {
  static const OpOption enum_value = OpOption_ReluOption;
};

template<> struct OpOptionUnionTraits<ace::Relu6OptionT> {
  static const OpOption enum_value = OpOption_Relu6Option;
};

template<> struct OpOptionUnionTraits<ace::RoundOptionT> {
  static const OpOption enum_value = OpOption_RoundOption;
};

template<> struct OpOptionUnionTraits<ace::SeluOptionT> {
  static const OpOption enum_value = OpOption_SeluOption;
};

template<> struct OpOptionUnionTraits<ace::SigmoidOptionT> {
  static const OpOption enum_value = OpOption_SigmoidOption;
};

template<> struct OpOptionUnionTraits<ace::SoftReluOptionT> {
  static const OpOption enum_value = OpOption_SoftReluOption;
};

template<> struct OpOptionUnionTraits<ace::SoftReluV2OptionT> {
  static const OpOption enum_value = OpOption_SoftReluV2Option;
};

template<> struct OpOptionUnionTraits<ace::SqrtOptionT> {
  static const OpOption enum_value = OpOption_SqrtOption;
};

template<> struct OpOptionUnionTraits<ace::SwishOptionT> {
  static const OpOption enum_value = OpOption_SwishOption;
};

template<> struct OpOptionUnionTraits<ace::TanhOptionT> {
  static const OpOption enum_value = OpOption_TanhOption;
};

template<> struct OpOptionUnionTraits<ace::AddOptionT> {
  static const OpOption enum_value = OpOption_AddOption;
};

template<> struct OpOptionUnionTraits<ace::MulOptionT> {
  static const OpOption enum_value = OpOption_MulOption;
};

template<> struct OpOptionUnionTraits<ace::MinOptionT> {
  static const OpOption enum_value = OpOption_MinOption;
};

template<> struct OpOptionUnionTraits<ace::MaxOptionT> {
  static const OpOption enum_value = OpOption_MaxOption;
};

template<> struct OpOptionUnionTraits<ace::MeanOptionT> {
  static const OpOption enum_value = OpOption_MeanOption;
};

template<> struct OpOptionUnionTraits<ace::DivOptionT> {
  static const OpOption enum_value = OpOption_DivOption;
};

template<> struct OpOptionUnionTraits<ace::GreaterEqualOptionT> {
  static const OpOption enum_value = OpOption_GreaterEqualOption;
};

template<> struct OpOptionUnionTraits<ace::GreaterThanOptionT> {
  static const OpOption enum_value = OpOption_GreaterThanOption;
};

template<> struct OpOptionUnionTraits<ace::LessEqualOptionT> {
  static const OpOption enum_value = OpOption_LessEqualOption;
};

template<> struct OpOptionUnionTraits<ace::LessThanOptionT> {
  static const OpOption enum_value = OpOption_LessThanOption;
};

template<> struct OpOptionUnionTraits<ace::EqualToOptionT> {
  static const OpOption enum_value = OpOption_EqualToOption;
};

template<> struct OpOptionUnionTraits<ace::NotEqualOptionT> {
  static const OpOption enum_value = OpOption_NotEqualOption;
};

template<> struct OpOptionUnionTraits<ace::ReduceMinOptionT> {
  static const OpOption enum_value = OpOption_ReduceMinOption;
};

template<> struct OpOptionUnionTraits<ace::ReduceMaxOptionT> {
  static const OpOption enum_value = OpOption_ReduceMaxOption;
};

template<> struct OpOptionUnionTraits<ace::ReduceMeanOptionT> {
  static const OpOption enum_value = OpOption_ReduceMeanOption;
};

template<> struct OpOptionUnionTraits<ace::ReduceSumOptionT> {
  static const OpOption enum_value = OpOption_ReduceSumOption;
};

template<> struct OpOptionUnionTraits<ace::ReduceMulOptionT> {
  static const OpOption enum_value = OpOption_ReduceMulOption;
};

template<> struct OpOptionUnionTraits<ace::Pool2DOptionT> {
  static const OpOption enum_value = OpOption_Pool2DOption;
};

template<> struct OpOptionUnionTraits<ace::Pool3DOptionT> {
  static const OpOption enum_value = OpOption_Pool3DOption;
};

template<> struct OpOptionUnionTraits<ace::ReshapeOptionT> {
  static const OpOption enum_value = OpOption_ReshapeOption;
};

template<> struct OpOptionUnionTraits<ace::SliceOptionT> {
  static const OpOption enum_value = OpOption_SliceOption;
};

template<> struct OpOptionUnionTraits<ace::FlattenOptionT> {
  static const OpOption enum_value = OpOption_FlattenOption;
};

template<> struct OpOptionUnionTraits<ace::PermuteOptionT> {
  static const OpOption enum_value = OpOption_PermuteOption;
};

template<> struct OpOptionUnionTraits<ace::ArgMaxOptionT> {
  static const OpOption enum_value = OpOption_ArgMaxOption;
};

template<> struct OpOptionUnionTraits<ace::BatchNormOptionT> {
  static const OpOption enum_value = OpOption_BatchNormOption;
};

template<> struct OpOptionUnionTraits<ace::Conv2DOptionT> {
  static const OpOption enum_value = OpOption_Conv2DOption;
};

template<> struct OpOptionUnionTraits<ace::Conv3DOptionT> {
  static const OpOption enum_value = OpOption_Conv3DOption;
};

template<> struct OpOptionUnionTraits<ace::InnerProductOptionT> {
  static const OpOption enum_value = OpOption_InnerProductOption;
};

template<> struct OpOptionUnionTraits<ace::LRNOptionT> {
  static const OpOption enum_value = OpOption_LRNOption;
};

template<> struct OpOptionUnionTraits<ace::NormalizeOptionT> {
  static const OpOption enum_value = OpOption_NormalizeOption;
};

template<> struct OpOptionUnionTraits<ace::PriorBoxOptionT> {
  static const OpOption enum_value = OpOption_PriorBoxOption;
};

template<> struct OpOptionUnionTraits<ace::ProposalOptionT> {
  static const OpOption enum_value = OpOption_ProposalOption;
};

template<> struct OpOptionUnionTraits<ace::ResizeOptionT> {
  static const OpOption enum_value = OpOption_ResizeOption;
};

template<> struct OpOptionUnionTraits<ace::RoiPoolingOptionT> {
  static const OpOption enum_value = OpOption_RoiPoolingOption;
};

template<> struct OpOptionUnionTraits<ace::ScaleOptionT> {
  static const OpOption enum_value = OpOption_ScaleOption;
};

template<> struct OpOptionUnionTraits<ace::SoftmaxOptionT> {
  static const OpOption enum_value = OpOption_SoftmaxOption;
};

template<> struct OpOptionUnionTraits<ace::InputOptionT> {
  static const OpOption enum_value = OpOption_InputOption;
};

struct OpOptionUnion {
  OpOption type;
  void *value;

  OpOptionUnion() : type(OpOption_NONE), value(nullptr) {}
  OpOptionUnion(OpOptionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpOption_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpOptionUnion(const OpOptionUnion &);
  OpOptionUnion &operator=(const OpOptionUnion &u)
    { OpOptionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpOptionUnion &operator=(OpOptionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpOptionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpOptionUnionTraits<RT>::enum_value;
    if (type != OpOption_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpOption type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ace::DefaultOptionT *AsDefaultOption() {
    return type == OpOption_DefaultOption ?
      reinterpret_cast<ace::DefaultOptionT *>(value) : nullptr;
  }
  const ace::DefaultOptionT *AsDefaultOption() const {
    return type == OpOption_DefaultOption ?
      reinterpret_cast<const ace::DefaultOptionT *>(value) : nullptr;
  }
  ace::ConstOptionT *AsConstOption() {
    return type == OpOption_ConstOption ?
      reinterpret_cast<ace::ConstOptionT *>(value) : nullptr;
  }
  const ace::ConstOptionT *AsConstOption() const {
    return type == OpOption_ConstOption ?
      reinterpret_cast<const ace::ConstOptionT *>(value) : nullptr;
  }
  ace::AbsOptionT *AsAbsOption() {
    return type == OpOption_AbsOption ?
      reinterpret_cast<ace::AbsOptionT *>(value) : nullptr;
  }
  const ace::AbsOptionT *AsAbsOption() const {
    return type == OpOption_AbsOption ?
      reinterpret_cast<const ace::AbsOptionT *>(value) : nullptr;
  }
  ace::BoundedReluOptionT *AsBoundedReluOption() {
    return type == OpOption_BoundedReluOption ?
      reinterpret_cast<ace::BoundedReluOptionT *>(value) : nullptr;
  }
  const ace::BoundedReluOptionT *AsBoundedReluOption() const {
    return type == OpOption_BoundedReluOption ?
      reinterpret_cast<const ace::BoundedReluOptionT *>(value) : nullptr;
  }
  ace::ClipOptionT *AsClipOption() {
    return type == OpOption_ClipOption ?
      reinterpret_cast<ace::ClipOptionT *>(value) : nullptr;
  }
  const ace::ClipOptionT *AsClipOption() const {
    return type == OpOption_ClipOption ?
      reinterpret_cast<const ace::ClipOptionT *>(value) : nullptr;
  }
  ace::ClipV2OptionT *AsClipV2Option() {
    return type == OpOption_ClipV2Option ?
      reinterpret_cast<ace::ClipV2OptionT *>(value) : nullptr;
  }
  const ace::ClipV2OptionT *AsClipV2Option() const {
    return type == OpOption_ClipV2Option ?
      reinterpret_cast<const ace::ClipV2OptionT *>(value) : nullptr;
  }
  ace::ClippedReluOptionT *AsClippedReluOption() {
    return type == OpOption_ClippedReluOption ?
      reinterpret_cast<ace::ClippedReluOptionT *>(value) : nullptr;
  }
  const ace::ClippedReluOptionT *AsClippedReluOption() const {
    return type == OpOption_ClippedReluOption ?
      reinterpret_cast<const ace::ClippedReluOptionT *>(value) : nullptr;
  }
  ace::EluOptionT *AsEluOption() {
    return type == OpOption_EluOption ?
      reinterpret_cast<ace::EluOptionT *>(value) : nullptr;
  }
  const ace::EluOptionT *AsEluOption() const {
    return type == OpOption_EluOption ?
      reinterpret_cast<const ace::EluOptionT *>(value) : nullptr;
  }
  ace::ExpOptionT *AsExpOption() {
    return type == OpOption_ExpOption ?
      reinterpret_cast<ace::ExpOptionT *>(value) : nullptr;
  }
  const ace::ExpOptionT *AsExpOption() const {
    return type == OpOption_ExpOption ?
      reinterpret_cast<const ace::ExpOptionT *>(value) : nullptr;
  }
  ace::GeluTanhOptionT *AsGeluTanhOption() {
    return type == OpOption_GeluTanhOption ?
      reinterpret_cast<ace::GeluTanhOptionT *>(value) : nullptr;
  }
  const ace::GeluTanhOptionT *AsGeluTanhOption() const {
    return type == OpOption_GeluTanhOption ?
      reinterpret_cast<const ace::GeluTanhOptionT *>(value) : nullptr;
  }
  ace::HardSigmoidOptionT *AsHardSigmoidOption() {
    return type == OpOption_HardSigmoidOption ?
      reinterpret_cast<ace::HardSigmoidOptionT *>(value) : nullptr;
  }
  const ace::HardSigmoidOptionT *AsHardSigmoidOption() const {
    return type == OpOption_HardSigmoidOption ?
      reinterpret_cast<const ace::HardSigmoidOptionT *>(value) : nullptr;
  }
  ace::HardSwishOptionT *AsHardSwishOption() {
    return type == OpOption_HardSwishOption ?
      reinterpret_cast<ace::HardSwishOptionT *>(value) : nullptr;
  }
  const ace::HardSwishOptionT *AsHardSwishOption() const {
    return type == OpOption_HardSwishOption ?
      reinterpret_cast<const ace::HardSwishOptionT *>(value) : nullptr;
  }
  ace::LeakyReluOptionT *AsLeakyReluOption() {
    return type == OpOption_LeakyReluOption ?
      reinterpret_cast<ace::LeakyReluOptionT *>(value) : nullptr;
  }
  const ace::LeakyReluOptionT *AsLeakyReluOption() const {
    return type == OpOption_LeakyReluOption ?
      reinterpret_cast<const ace::LeakyReluOptionT *>(value) : nullptr;
  }
  ace::LinearOptionT *AsLinearOption() {
    return type == OpOption_LinearOption ?
      reinterpret_cast<ace::LinearOptionT *>(value) : nullptr;
  }
  const ace::LinearOptionT *AsLinearOption() const {
    return type == OpOption_LinearOption ?
      reinterpret_cast<const ace::LinearOptionT *>(value) : nullptr;
  }
  ace::LogOptionT *AsLogOption() {
    return type == OpOption_LogOption ?
      reinterpret_cast<ace::LogOptionT *>(value) : nullptr;
  }
  const ace::LogOptionT *AsLogOption() const {
    return type == OpOption_LogOption ?
      reinterpret_cast<const ace::LogOptionT *>(value) : nullptr;
  }
  ace::LogisticOptionT *AsLogisticOption() {
    return type == OpOption_LogisticOption ?
      reinterpret_cast<ace::LogisticOptionT *>(value) : nullptr;
  }
  const ace::LogisticOptionT *AsLogisticOption() const {
    return type == OpOption_LogisticOption ?
      reinterpret_cast<const ace::LogisticOptionT *>(value) : nullptr;
  }
  ace::LogSigmoidOptionT *AsLogSigmoidOption() {
    return type == OpOption_LogSigmoidOption ?
      reinterpret_cast<ace::LogSigmoidOptionT *>(value) : nullptr;
  }
  const ace::LogSigmoidOptionT *AsLogSigmoidOption() const {
    return type == OpOption_LogSigmoidOption ?
      reinterpret_cast<const ace::LogSigmoidOptionT *>(value) : nullptr;
  }
  ace::MishOptionT *AsMishOption() {
    return type == OpOption_MishOption ?
      reinterpret_cast<ace::MishOptionT *>(value) : nullptr;
  }
  const ace::MishOptionT *AsMishOption() const {
    return type == OpOption_MishOption ?
      reinterpret_cast<const ace::MishOptionT *>(value) : nullptr;
  }
  ace::PowOptionT *AsPowOption() {
    return type == OpOption_PowOption ?
      reinterpret_cast<ace::PowOptionT *>(value) : nullptr;
  }
  const ace::PowOptionT *AsPowOption() const {
    return type == OpOption_PowOption ?
      reinterpret_cast<const ace::PowOptionT *>(value) : nullptr;
  }
  ace::PReluOptionT *AsPReluOption() {
    return type == OpOption_PReluOption ?
      reinterpret_cast<ace::PReluOptionT *>(value) : nullptr;
  }
  const ace::PReluOptionT *AsPReluOption() const {
    return type == OpOption_PReluOption ?
      reinterpret_cast<const ace::PReluOptionT *>(value) : nullptr;
  }
  ace::ReluOptionT *AsReluOption() {
    return type == OpOption_ReluOption ?
      reinterpret_cast<ace::ReluOptionT *>(value) : nullptr;
  }
  const ace::ReluOptionT *AsReluOption() const {
    return type == OpOption_ReluOption ?
      reinterpret_cast<const ace::ReluOptionT *>(value) : nullptr;
  }
  ace::Relu6OptionT *AsRelu6Option() {
    return type == OpOption_Relu6Option ?
      reinterpret_cast<ace::Relu6OptionT *>(value) : nullptr;
  }
  const ace::Relu6OptionT *AsRelu6Option() const {
    return type == OpOption_Relu6Option ?
      reinterpret_cast<const ace::Relu6OptionT *>(value) : nullptr;
  }
  ace::RoundOptionT *AsRoundOption() {
    return type == OpOption_RoundOption ?
      reinterpret_cast<ace::RoundOptionT *>(value) : nullptr;
  }
  const ace::RoundOptionT *AsRoundOption() const {
    return type == OpOption_RoundOption ?
      reinterpret_cast<const ace::RoundOptionT *>(value) : nullptr;
  }
  ace::SeluOptionT *AsSeluOption() {
    return type == OpOption_SeluOption ?
      reinterpret_cast<ace::SeluOptionT *>(value) : nullptr;
  }
  const ace::SeluOptionT *AsSeluOption() const {
    return type == OpOption_SeluOption ?
      reinterpret_cast<const ace::SeluOptionT *>(value) : nullptr;
  }
  ace::SigmoidOptionT *AsSigmoidOption() {
    return type == OpOption_SigmoidOption ?
      reinterpret_cast<ace::SigmoidOptionT *>(value) : nullptr;
  }
  const ace::SigmoidOptionT *AsSigmoidOption() const {
    return type == OpOption_SigmoidOption ?
      reinterpret_cast<const ace::SigmoidOptionT *>(value) : nullptr;
  }
  ace::SoftReluOptionT *AsSoftReluOption() {
    return type == OpOption_SoftReluOption ?
      reinterpret_cast<ace::SoftReluOptionT *>(value) : nullptr;
  }
  const ace::SoftReluOptionT *AsSoftReluOption() const {
    return type == OpOption_SoftReluOption ?
      reinterpret_cast<const ace::SoftReluOptionT *>(value) : nullptr;
  }
  ace::SoftReluV2OptionT *AsSoftReluV2Option() {
    return type == OpOption_SoftReluV2Option ?
      reinterpret_cast<ace::SoftReluV2OptionT *>(value) : nullptr;
  }
  const ace::SoftReluV2OptionT *AsSoftReluV2Option() const {
    return type == OpOption_SoftReluV2Option ?
      reinterpret_cast<const ace::SoftReluV2OptionT *>(value) : nullptr;
  }
  ace::SqrtOptionT *AsSqrtOption() {
    return type == OpOption_SqrtOption ?
      reinterpret_cast<ace::SqrtOptionT *>(value) : nullptr;
  }
  const ace::SqrtOptionT *AsSqrtOption() const {
    return type == OpOption_SqrtOption ?
      reinterpret_cast<const ace::SqrtOptionT *>(value) : nullptr;
  }
  ace::SwishOptionT *AsSwishOption() {
    return type == OpOption_SwishOption ?
      reinterpret_cast<ace::SwishOptionT *>(value) : nullptr;
  }
  const ace::SwishOptionT *AsSwishOption() const {
    return type == OpOption_SwishOption ?
      reinterpret_cast<const ace::SwishOptionT *>(value) : nullptr;
  }
  ace::TanhOptionT *AsTanhOption() {
    return type == OpOption_TanhOption ?
      reinterpret_cast<ace::TanhOptionT *>(value) : nullptr;
  }
  const ace::TanhOptionT *AsTanhOption() const {
    return type == OpOption_TanhOption ?
      reinterpret_cast<const ace::TanhOptionT *>(value) : nullptr;
  }
  ace::AddOptionT *AsAddOption() {
    return type == OpOption_AddOption ?
      reinterpret_cast<ace::AddOptionT *>(value) : nullptr;
  }
  const ace::AddOptionT *AsAddOption() const {
    return type == OpOption_AddOption ?
      reinterpret_cast<const ace::AddOptionT *>(value) : nullptr;
  }
  ace::MulOptionT *AsMulOption() {
    return type == OpOption_MulOption ?
      reinterpret_cast<ace::MulOptionT *>(value) : nullptr;
  }
  const ace::MulOptionT *AsMulOption() const {
    return type == OpOption_MulOption ?
      reinterpret_cast<const ace::MulOptionT *>(value) : nullptr;
  }
  ace::MinOptionT *AsMinOption() {
    return type == OpOption_MinOption ?
      reinterpret_cast<ace::MinOptionT *>(value) : nullptr;
  }
  const ace::MinOptionT *AsMinOption() const {
    return type == OpOption_MinOption ?
      reinterpret_cast<const ace::MinOptionT *>(value) : nullptr;
  }
  ace::MaxOptionT *AsMaxOption() {
    return type == OpOption_MaxOption ?
      reinterpret_cast<ace::MaxOptionT *>(value) : nullptr;
  }
  const ace::MaxOptionT *AsMaxOption() const {
    return type == OpOption_MaxOption ?
      reinterpret_cast<const ace::MaxOptionT *>(value) : nullptr;
  }
  ace::MeanOptionT *AsMeanOption() {
    return type == OpOption_MeanOption ?
      reinterpret_cast<ace::MeanOptionT *>(value) : nullptr;
  }
  const ace::MeanOptionT *AsMeanOption() const {
    return type == OpOption_MeanOption ?
      reinterpret_cast<const ace::MeanOptionT *>(value) : nullptr;
  }
  ace::DivOptionT *AsDivOption() {
    return type == OpOption_DivOption ?
      reinterpret_cast<ace::DivOptionT *>(value) : nullptr;
  }
  const ace::DivOptionT *AsDivOption() const {
    return type == OpOption_DivOption ?
      reinterpret_cast<const ace::DivOptionT *>(value) : nullptr;
  }
  ace::GreaterEqualOptionT *AsGreaterEqualOption() {
    return type == OpOption_GreaterEqualOption ?
      reinterpret_cast<ace::GreaterEqualOptionT *>(value) : nullptr;
  }
  const ace::GreaterEqualOptionT *AsGreaterEqualOption() const {
    return type == OpOption_GreaterEqualOption ?
      reinterpret_cast<const ace::GreaterEqualOptionT *>(value) : nullptr;
  }
  ace::GreaterThanOptionT *AsGreaterThanOption() {
    return type == OpOption_GreaterThanOption ?
      reinterpret_cast<ace::GreaterThanOptionT *>(value) : nullptr;
  }
  const ace::GreaterThanOptionT *AsGreaterThanOption() const {
    return type == OpOption_GreaterThanOption ?
      reinterpret_cast<const ace::GreaterThanOptionT *>(value) : nullptr;
  }
  ace::LessEqualOptionT *AsLessEqualOption() {
    return type == OpOption_LessEqualOption ?
      reinterpret_cast<ace::LessEqualOptionT *>(value) : nullptr;
  }
  const ace::LessEqualOptionT *AsLessEqualOption() const {
    return type == OpOption_LessEqualOption ?
      reinterpret_cast<const ace::LessEqualOptionT *>(value) : nullptr;
  }
  ace::LessThanOptionT *AsLessThanOption() {
    return type == OpOption_LessThanOption ?
      reinterpret_cast<ace::LessThanOptionT *>(value) : nullptr;
  }
  const ace::LessThanOptionT *AsLessThanOption() const {
    return type == OpOption_LessThanOption ?
      reinterpret_cast<const ace::LessThanOptionT *>(value) : nullptr;
  }
  ace::EqualToOptionT *AsEqualToOption() {
    return type == OpOption_EqualToOption ?
      reinterpret_cast<ace::EqualToOptionT *>(value) : nullptr;
  }
  const ace::EqualToOptionT *AsEqualToOption() const {
    return type == OpOption_EqualToOption ?
      reinterpret_cast<const ace::EqualToOptionT *>(value) : nullptr;
  }
  ace::NotEqualOptionT *AsNotEqualOption() {
    return type == OpOption_NotEqualOption ?
      reinterpret_cast<ace::NotEqualOptionT *>(value) : nullptr;
  }
  const ace::NotEqualOptionT *AsNotEqualOption() const {
    return type == OpOption_NotEqualOption ?
      reinterpret_cast<const ace::NotEqualOptionT *>(value) : nullptr;
  }
  ace::ReduceMinOptionT *AsReduceMinOption() {
    return type == OpOption_ReduceMinOption ?
      reinterpret_cast<ace::ReduceMinOptionT *>(value) : nullptr;
  }
  const ace::ReduceMinOptionT *AsReduceMinOption() const {
    return type == OpOption_ReduceMinOption ?
      reinterpret_cast<const ace::ReduceMinOptionT *>(value) : nullptr;
  }
  ace::ReduceMaxOptionT *AsReduceMaxOption() {
    return type == OpOption_ReduceMaxOption ?
      reinterpret_cast<ace::ReduceMaxOptionT *>(value) : nullptr;
  }
  const ace::ReduceMaxOptionT *AsReduceMaxOption() const {
    return type == OpOption_ReduceMaxOption ?
      reinterpret_cast<const ace::ReduceMaxOptionT *>(value) : nullptr;
  }
  ace::ReduceMeanOptionT *AsReduceMeanOption() {
    return type == OpOption_ReduceMeanOption ?
      reinterpret_cast<ace::ReduceMeanOptionT *>(value) : nullptr;
  }
  const ace::ReduceMeanOptionT *AsReduceMeanOption() const {
    return type == OpOption_ReduceMeanOption ?
      reinterpret_cast<const ace::ReduceMeanOptionT *>(value) : nullptr;
  }
  ace::ReduceSumOptionT *AsReduceSumOption() {
    return type == OpOption_ReduceSumOption ?
      reinterpret_cast<ace::ReduceSumOptionT *>(value) : nullptr;
  }
  const ace::ReduceSumOptionT *AsReduceSumOption() const {
    return type == OpOption_ReduceSumOption ?
      reinterpret_cast<const ace::ReduceSumOptionT *>(value) : nullptr;
  }
  ace::ReduceMulOptionT *AsReduceMulOption() {
    return type == OpOption_ReduceMulOption ?
      reinterpret_cast<ace::ReduceMulOptionT *>(value) : nullptr;
  }
  const ace::ReduceMulOptionT *AsReduceMulOption() const {
    return type == OpOption_ReduceMulOption ?
      reinterpret_cast<const ace::ReduceMulOptionT *>(value) : nullptr;
  }
  ace::Pool2DOptionT *AsPool2DOption() {
    return type == OpOption_Pool2DOption ?
      reinterpret_cast<ace::Pool2DOptionT *>(value) : nullptr;
  }
  const ace::Pool2DOptionT *AsPool2DOption() const {
    return type == OpOption_Pool2DOption ?
      reinterpret_cast<const ace::Pool2DOptionT *>(value) : nullptr;
  }
  ace::Pool3DOptionT *AsPool3DOption() {
    return type == OpOption_Pool3DOption ?
      reinterpret_cast<ace::Pool3DOptionT *>(value) : nullptr;
  }
  const ace::Pool3DOptionT *AsPool3DOption() const {
    return type == OpOption_Pool3DOption ?
      reinterpret_cast<const ace::Pool3DOptionT *>(value) : nullptr;
  }
  ace::ReshapeOptionT *AsReshapeOption() {
    return type == OpOption_ReshapeOption ?
      reinterpret_cast<ace::ReshapeOptionT *>(value) : nullptr;
  }
  const ace::ReshapeOptionT *AsReshapeOption() const {
    return type == OpOption_ReshapeOption ?
      reinterpret_cast<const ace::ReshapeOptionT *>(value) : nullptr;
  }
  ace::SliceOptionT *AsSliceOption() {
    return type == OpOption_SliceOption ?
      reinterpret_cast<ace::SliceOptionT *>(value) : nullptr;
  }
  const ace::SliceOptionT *AsSliceOption() const {
    return type == OpOption_SliceOption ?
      reinterpret_cast<const ace::SliceOptionT *>(value) : nullptr;
  }
  ace::FlattenOptionT *AsFlattenOption() {
    return type == OpOption_FlattenOption ?
      reinterpret_cast<ace::FlattenOptionT *>(value) : nullptr;
  }
  const ace::FlattenOptionT *AsFlattenOption() const {
    return type == OpOption_FlattenOption ?
      reinterpret_cast<const ace::FlattenOptionT *>(value) : nullptr;
  }
  ace::PermuteOptionT *AsPermuteOption() {
    return type == OpOption_PermuteOption ?
      reinterpret_cast<ace::PermuteOptionT *>(value) : nullptr;
  }
  const ace::PermuteOptionT *AsPermuteOption() const {
    return type == OpOption_PermuteOption ?
      reinterpret_cast<const ace::PermuteOptionT *>(value) : nullptr;
  }
  ace::ArgMaxOptionT *AsArgMaxOption() {
    return type == OpOption_ArgMaxOption ?
      reinterpret_cast<ace::ArgMaxOptionT *>(value) : nullptr;
  }
  const ace::ArgMaxOptionT *AsArgMaxOption() const {
    return type == OpOption_ArgMaxOption ?
      reinterpret_cast<const ace::ArgMaxOptionT *>(value) : nullptr;
  }
  ace::BatchNormOptionT *AsBatchNormOption() {
    return type == OpOption_BatchNormOption ?
      reinterpret_cast<ace::BatchNormOptionT *>(value) : nullptr;
  }
  const ace::BatchNormOptionT *AsBatchNormOption() const {
    return type == OpOption_BatchNormOption ?
      reinterpret_cast<const ace::BatchNormOptionT *>(value) : nullptr;
  }
  ace::Conv2DOptionT *AsConv2DOption() {
    return type == OpOption_Conv2DOption ?
      reinterpret_cast<ace::Conv2DOptionT *>(value) : nullptr;
  }
  const ace::Conv2DOptionT *AsConv2DOption() const {
    return type == OpOption_Conv2DOption ?
      reinterpret_cast<const ace::Conv2DOptionT *>(value) : nullptr;
  }
  ace::Conv3DOptionT *AsConv3DOption() {
    return type == OpOption_Conv3DOption ?
      reinterpret_cast<ace::Conv3DOptionT *>(value) : nullptr;
  }
  const ace::Conv3DOptionT *AsConv3DOption() const {
    return type == OpOption_Conv3DOption ?
      reinterpret_cast<const ace::Conv3DOptionT *>(value) : nullptr;
  }
  ace::InnerProductOptionT *AsInnerProductOption() {
    return type == OpOption_InnerProductOption ?
      reinterpret_cast<ace::InnerProductOptionT *>(value) : nullptr;
  }
  const ace::InnerProductOptionT *AsInnerProductOption() const {
    return type == OpOption_InnerProductOption ?
      reinterpret_cast<const ace::InnerProductOptionT *>(value) : nullptr;
  }
  ace::LRNOptionT *AsLRNOption() {
    return type == OpOption_LRNOption ?
      reinterpret_cast<ace::LRNOptionT *>(value) : nullptr;
  }
  const ace::LRNOptionT *AsLRNOption() const {
    return type == OpOption_LRNOption ?
      reinterpret_cast<const ace::LRNOptionT *>(value) : nullptr;
  }
  ace::NormalizeOptionT *AsNormalizeOption() {
    return type == OpOption_NormalizeOption ?
      reinterpret_cast<ace::NormalizeOptionT *>(value) : nullptr;
  }
  const ace::NormalizeOptionT *AsNormalizeOption() const {
    return type == OpOption_NormalizeOption ?
      reinterpret_cast<const ace::NormalizeOptionT *>(value) : nullptr;
  }
  ace::PriorBoxOptionT *AsPriorBoxOption() {
    return type == OpOption_PriorBoxOption ?
      reinterpret_cast<ace::PriorBoxOptionT *>(value) : nullptr;
  }
  const ace::PriorBoxOptionT *AsPriorBoxOption() const {
    return type == OpOption_PriorBoxOption ?
      reinterpret_cast<const ace::PriorBoxOptionT *>(value) : nullptr;
  }
  ace::ProposalOptionT *AsProposalOption() {
    return type == OpOption_ProposalOption ?
      reinterpret_cast<ace::ProposalOptionT *>(value) : nullptr;
  }
  const ace::ProposalOptionT *AsProposalOption() const {
    return type == OpOption_ProposalOption ?
      reinterpret_cast<const ace::ProposalOptionT *>(value) : nullptr;
  }
  ace::ResizeOptionT *AsResizeOption() {
    return type == OpOption_ResizeOption ?
      reinterpret_cast<ace::ResizeOptionT *>(value) : nullptr;
  }
  const ace::ResizeOptionT *AsResizeOption() const {
    return type == OpOption_ResizeOption ?
      reinterpret_cast<const ace::ResizeOptionT *>(value) : nullptr;
  }
  ace::RoiPoolingOptionT *AsRoiPoolingOption() {
    return type == OpOption_RoiPoolingOption ?
      reinterpret_cast<ace::RoiPoolingOptionT *>(value) : nullptr;
  }
  const ace::RoiPoolingOptionT *AsRoiPoolingOption() const {
    return type == OpOption_RoiPoolingOption ?
      reinterpret_cast<const ace::RoiPoolingOptionT *>(value) : nullptr;
  }
  ace::ScaleOptionT *AsScaleOption() {
    return type == OpOption_ScaleOption ?
      reinterpret_cast<ace::ScaleOptionT *>(value) : nullptr;
  }
  const ace::ScaleOptionT *AsScaleOption() const {
    return type == OpOption_ScaleOption ?
      reinterpret_cast<const ace::ScaleOptionT *>(value) : nullptr;
  }
  ace::SoftmaxOptionT *AsSoftmaxOption() {
    return type == OpOption_SoftmaxOption ?
      reinterpret_cast<ace::SoftmaxOptionT *>(value) : nullptr;
  }
  const ace::SoftmaxOptionT *AsSoftmaxOption() const {
    return type == OpOption_SoftmaxOption ?
      reinterpret_cast<const ace::SoftmaxOptionT *>(value) : nullptr;
  }
  ace::InputOptionT *AsInputOption() {
    return type == OpOption_InputOption ?
      reinterpret_cast<ace::InputOptionT *>(value) : nullptr;
  }
  const ace::InputOptionT *AsInputOption() const {
    return type == OpOption_InputOption ?
      reinterpret_cast<const ace::InputOptionT *>(value) : nullptr;
  }
};

bool VerifyOpOption(flatbuffers::Verifier &verifier, const void *obj, OpOption type);
bool VerifyOpOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AbsOptionT : public flatbuffers::NativeTable {
  typedef AbsOption TableType;
};

struct AbsOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsOptionT NativeTableType;
  typedef AbsOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AbsOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsOptionBuilder {
  typedef AbsOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AbsOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOption> CreateAbsOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsOption> CreateAbsOption(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BoundedReluOptionT : public flatbuffers::NativeTable {
  typedef BoundedReluOption TableType;
};

struct BoundedReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoundedReluOptionT NativeTableType;
  typedef BoundedReluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BoundedReluOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BoundedReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoundedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BoundedReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoundedReluOptionBuilder {
  typedef BoundedReluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BoundedReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoundedReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoundedReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoundedReluOption> CreateBoundedReluOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BoundedReluOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BoundedReluOption> CreateBoundedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClipOptionT : public flatbuffers::NativeTable {
  typedef ClipOption TableType;
};

struct ClipOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipOptionT NativeTableType;
  typedef ClipOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClipOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ClipOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClipOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClipOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClipOptionBuilder {
  typedef ClipOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClipOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClipOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClipOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClipOption> CreateClipOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClipOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ClipOption> CreateClipOption(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClipV2OptionT : public flatbuffers::NativeTable {
  typedef ClipV2Option TableType;
};

struct ClipV2Option FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipV2OptionT NativeTableType;
  typedef ClipV2OptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClipV2OptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ClipV2OptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClipV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClipV2Option> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClipV2OptionBuilder {
  typedef ClipV2Option Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClipV2OptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClipV2Option> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClipV2Option>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClipV2Option> CreateClipV2Option(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClipV2OptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ClipV2Option> CreateClipV2Option(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EluOptionT : public flatbuffers::NativeTable {
  typedef EluOption TableType;
  float alpha = 1.0f;
};

struct EluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EluOptionT NativeTableType;
  typedef EluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EluOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
  EluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EluOptionBuilder {
  typedef EluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(EluOption::VT_ALPHA, alpha, 1.0f);
  }
  explicit EluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<EluOption> CreateEluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 1.0f) {
  EluOptionBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<EluOption> CreateEluOption(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpOptionT : public flatbuffers::NativeTable {
  typedef ExpOption TableType;
};

struct ExpOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpOptionT NativeTableType;
  typedef ExpOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpOptionBuilder {
  typedef ExpOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOption> CreateExpOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpOption> CreateExpOption(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeluTanhOptionT : public flatbuffers::NativeTable {
  typedef GeluTanhOption TableType;
};

struct GeluTanhOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeluTanhOptionT NativeTableType;
  typedef GeluTanhOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeluTanhOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GeluTanhOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeluTanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeluTanhOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeluTanhOptionBuilder {
  typedef GeluTanhOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GeluTanhOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeluTanhOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeluTanhOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeluTanhOption> CreateGeluTanhOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GeluTanhOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GeluTanhOption> CreateGeluTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSigmoidOptionT : public flatbuffers::NativeTable {
  typedef HardSigmoidOption TableType;
};

struct HardSigmoidOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardSigmoidOptionT NativeTableType;
  typedef HardSigmoidOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HardSigmoidOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSigmoidOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSigmoidOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSigmoidOptionBuilder {
  typedef HardSigmoidOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSigmoidOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardSigmoidOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSigmoidOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSigmoidOption> CreateHardSigmoidOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSigmoidOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSigmoidOption> CreateHardSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HardSwishOptionT : public flatbuffers::NativeTable {
  typedef HardSwishOption TableType;
};

struct HardSwishOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardSwishOptionT NativeTableType;
  typedef HardSwishOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HardSwishOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HardSwishOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HardSwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HardSwishOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HardSwishOptionBuilder {
  typedef HardSwishOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardSwishOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOption> CreateHardSwishOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSwishOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HardSwishOption> CreateHardSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LinearOptionT : public flatbuffers::NativeTable {
  typedef LinearOption TableType;
};

struct LinearOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinearOptionT NativeTableType;
  typedef LinearOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LinearOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LinearOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LinearOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LinearOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LinearOptionBuilder {
  typedef LinearOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LinearOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LinearOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinearOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LinearOption> CreateLinearOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LinearOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LinearOption> CreateLinearOption(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogOptionT : public flatbuffers::NativeTable {
  typedef LogOption TableType;
};

struct LogOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogOptionT NativeTableType;
  typedef LogOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogOptionBuilder {
  typedef LogOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogOption> CreateLogOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogOption> CreateLogOption(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogisticOptionT : public flatbuffers::NativeTable {
  typedef LogisticOption TableType;
};

struct LogisticOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogisticOptionT NativeTableType;
  typedef LogisticOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogisticOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogisticOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogisticOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogisticOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogisticOptionBuilder {
  typedef LogisticOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogisticOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogisticOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogisticOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogisticOption> CreateLogisticOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogisticOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogisticOption> CreateLogisticOption(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MishOptionT : public flatbuffers::NativeTable {
  typedef MishOption TableType;
};

struct MishOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MishOptionT NativeTableType;
  typedef MishOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MishOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MishOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MishOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MishOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MishOptionBuilder {
  typedef MishOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MishOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MishOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MishOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MishOption> CreateMishOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MishOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MishOption> CreateMishOption(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowOptionT : public flatbuffers::NativeTable {
  typedef PowOption TableType;
};

struct PowOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowOptionT NativeTableType;
  typedef PowOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PowOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowOptionBuilder {
  typedef PowOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOption> CreatePowOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<PowOption> CreatePowOption(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReluOptionT : public flatbuffers::NativeTable {
  typedef PReluOption TableType;
  int32_t slopeCount = 0;
  std::vector<float> slope{};
};

struct PReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReluOptionT NativeTableType;
  typedef PReluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReluOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPECOUNT = 4,
    VT_SLOPE = 6
  };
  int32_t slopeCount() const {
    return GetField<int32_t>(VT_SLOPECOUNT, 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOPECOUNT, 4) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReluOptionBuilder {
  typedef PReluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slopeCount(int32_t slopeCount) {
    fbb_.AddElement<int32_t>(PReluOption::VT_SLOPECOUNT, slopeCount, 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PReluOption::VT_SLOPE, slope);
  }
  explicit PReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReluOption> CreatePReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReluOptionBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slopeCount(slopeCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<PReluOption> CreatePReluOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return ace::CreatePReluOption(
      _fbb,
      slopeCount,
      slope__);
}

flatbuffers::Offset<PReluOption> CreatePReluOption(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReluOptionT : public flatbuffers::NativeTable {
  typedef ReluOption TableType;
  float slope = 0.0f;
};

struct ReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReluOptionT NativeTableType;
  typedef ReluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReluOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE, 4) &&
           verifier.EndTable();
  }
  ReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReluOptionBuilder {
  typedef ReluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(ReluOption::VT_SLOPE, slope, 0.0f);
  }
  explicit ReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReluOption> CreateReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluOptionBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<ReluOption> CreateReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Relu6OptionT : public flatbuffers::NativeTable {
  typedef Relu6Option TableType;
  float minval = 0.0f;
  float maxval = 6.0f;
};

struct Relu6Option FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Relu6OptionT NativeTableType;
  typedef Relu6OptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Relu6OptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINVAL = 4,
    VT_MAXVAL = 6
  };
  float minval() const {
    return GetField<float>(VT_MINVAL, 0.0f);
  }
  float maxval() const {
    return GetField<float>(VT_MAXVAL, 6.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MINVAL, 4) &&
           VerifyField<float>(verifier, VT_MAXVAL, 4) &&
           verifier.EndTable();
  }
  Relu6OptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Relu6OptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Relu6Option> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Relu6OptionBuilder {
  typedef Relu6Option Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minval(float minval) {
    fbb_.AddElement<float>(Relu6Option::VT_MINVAL, minval, 0.0f);
  }
  void add_maxval(float maxval) {
    fbb_.AddElement<float>(Relu6Option::VT_MAXVAL, maxval, 6.0f);
  }
  explicit Relu6OptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Relu6Option> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu6Option>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu6Option> CreateRelu6Option(
    flatbuffers::FlatBufferBuilder &_fbb,
    float minval = 0.0f,
    float maxval = 6.0f) {
  Relu6OptionBuilder builder_(_fbb);
  builder_.add_maxval(maxval);
  builder_.add_minval(minval);
  return builder_.Finish();
}

flatbuffers::Offset<Relu6Option> CreateRelu6Option(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClippedReluOptionT : public flatbuffers::NativeTable {
  typedef ClippedReluOption TableType;
  float threashod = 0.0f;
};

struct ClippedReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClippedReluOptionT NativeTableType;
  typedef ClippedReluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClippedReluOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREASHOD = 4
  };
  float threashod() const {
    return GetField<float>(VT_THREASHOD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THREASHOD, 4) &&
           verifier.EndTable();
  }
  ClippedReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClippedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ClippedReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClippedReluOptionBuilder {
  typedef ClippedReluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_threashod(float threashod) {
    fbb_.AddElement<float>(ClippedReluOption::VT_THREASHOD, threashod, 0.0f);
  }
  explicit ClippedReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClippedReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClippedReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClippedReluOption> CreateClippedReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float threashod = 0.0f) {
  ClippedReluOptionBuilder builder_(_fbb);
  builder_.add_threashod(threashod);
  return builder_.Finish();
}

flatbuffers::Offset<ClippedReluOption> CreateClippedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluOptionT : public flatbuffers::NativeTable {
  typedef LeakyReluOption TableType;
  float negative_slope = 0.01f;
};

struct LeakyReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluOptionT NativeTableType;
  typedef LeakyReluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LeakyReluOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVE_SLOPE = 4
  };
  float negative_slope() const {
    return GetField<float>(VT_NEGATIVE_SLOPE, 0.01f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE, 4) &&
           verifier.EndTable();
  }
  LeakyReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluOptionBuilder {
  typedef LeakyReluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negative_slope(float negative_slope) {
    fbb_.AddElement<float>(LeakyReluOption::VT_NEGATIVE_SLOPE, negative_slope, 0.01f);
  }
  explicit LeakyReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LeakyReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOption> CreateLeakyReluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negative_slope = 0.01f) {
  LeakyReluOptionBuilder builder_(_fbb);
  builder_.add_negative_slope(negative_slope);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluOption> CreateLeakyReluOption(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSigmoidOptionT : public flatbuffers::NativeTable {
  typedef LogSigmoidOption TableType;
};

struct LogSigmoidOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogSigmoidOptionT NativeTableType;
  typedef LogSigmoidOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogSigmoidOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogSigmoidOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSigmoidOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSigmoidOptionBuilder {
  typedef LogSigmoidOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSigmoidOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogSigmoidOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSigmoidOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSigmoidOption> CreateLogSigmoidOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSigmoidOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogSigmoidOption> CreateLogSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoundOptionT : public flatbuffers::NativeTable {
  typedef RoundOption TableType;
};

struct RoundOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoundOptionT NativeTableType;
  typedef RoundOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoundOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RoundOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoundOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoundOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoundOptionBuilder {
  typedef RoundOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoundOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoundOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoundOption> CreateRoundOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RoundOption> CreateRoundOption(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SeluOptionT : public flatbuffers::NativeTable {
  typedef SeluOption TableType;
  float scale = 1.050700f;
  float alpha = 1.673263f;
};

struct SeluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SeluOptionT NativeTableType;
  typedef SeluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SeluOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ALPHA = 6
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 1.050700f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 1.673263f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
  SeluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SeluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SeluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SeluOptionBuilder {
  typedef SeluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(SeluOption::VT_SCALE, scale, 1.050700f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(SeluOption::VT_ALPHA, alpha, 1.673263f);
  }
  explicit SeluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SeluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SeluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SeluOption> CreateSeluOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 1.050700f,
    float alpha = 1.673263f) {
  SeluOptionBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<SeluOption> CreateSeluOption(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidOptionT : public flatbuffers::NativeTable {
  typedef SigmoidOption TableType;
};

struct SigmoidOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidOptionT NativeTableType;
  typedef SigmoidOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SigmoidOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SigmoidOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidOptionBuilder {
  typedef SigmoidOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidOption> CreateSigmoidOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidOption> CreateSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftReluOptionT : public flatbuffers::NativeTable {
  typedef SoftReluOption TableType;
};

struct SoftReluOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftReluOptionT NativeTableType;
  typedef SoftReluOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftReluOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SoftReluOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftReluOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftReluOptionBuilder {
  typedef SoftReluOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftReluOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftReluOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftReluOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftReluOption> CreateSoftReluOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftReluOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SoftReluOption> CreateSoftReluOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftReluV2OptionT : public flatbuffers::NativeTable {
  typedef SoftReluV2Option TableType;
};

struct SoftReluV2Option FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftReluV2OptionT NativeTableType;
  typedef SoftReluV2OptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftReluV2OptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SoftReluV2OptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftReluV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftReluV2Option> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftReluV2OptionBuilder {
  typedef SoftReluV2Option Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftReluV2OptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftReluV2Option> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftReluV2Option>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftReluV2Option> CreateSoftReluV2Option(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftReluV2OptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SoftReluV2Option> CreateSoftReluV2Option(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqrtOptionT : public flatbuffers::NativeTable {
  typedef SqrtOption TableType;
};

struct SqrtOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtOptionT NativeTableType;
  typedef SqrtOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqrtOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SqrtOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqrtOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqrtOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqrtOptionBuilder {
  typedef SqrtOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SqrtOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqrtOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqrtOption> CreateSqrtOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SqrtOption> CreateSqrtOption(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwishOptionT : public flatbuffers::NativeTable {
  typedef SwishOption TableType;
};

struct SwishOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwishOptionT NativeTableType;
  typedef SwishOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SwishOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SwishOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SwishOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwishOptionBuilder {
  typedef SwishOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwishOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SwishOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SwishOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SwishOption> CreateSwishOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwishOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SwishOption> CreateSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TanhOptionT : public flatbuffers::NativeTable {
  typedef TanhOption TableType;
};

struct TanhOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TanhOptionT NativeTableType;
  typedef TanhOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TanhOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TanhOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TanhOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TanhOptionBuilder {
  typedef TanhOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TanhOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TanhOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TanhOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<TanhOption> CreateTanhOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TanhOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TanhOption> CreateTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstOptionT : public flatbuffers::NativeTable {
  typedef ConstOption TableType;
  std::unique_ptr<ace::TensorProtoT> tensor{};
  ConstOptionT() = default;
  ConstOptionT(const ConstOptionT &o);
  ConstOptionT(ConstOptionT&&) FLATBUFFERS_NOEXCEPT = default;
  ConstOptionT &operator=(ConstOptionT o) FLATBUFFERS_NOEXCEPT;
};

struct ConstOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstOptionT NativeTableType;
  typedef ConstOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConstOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4
  };
  const ace::TensorProto *tensor() const {
    return GetPointer<const ace::TensorProto *>(VT_TENSOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           verifier.EndTable();
  }
  ConstOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConstOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstOptionBuilder {
  typedef ConstOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<ace::TensorProto> tensor) {
    fbb_.AddOffset(ConstOption::VT_TENSOR, tensor);
  }
  explicit ConstOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstOption> CreateConstOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ace::TensorProto> tensor = 0) {
  ConstOptionBuilder builder_(_fbb);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

flatbuffers::Offset<ConstOption> CreateConstOption(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NoneElementwiseOptionT : public flatbuffers::NativeTable {
  typedef NoneElementwiseOption TableType;
};

struct NoneElementwiseOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NoneElementwiseOptionT NativeTableType;
  typedef NoneElementwiseOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NoneElementwiseOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NoneElementwiseOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NoneElementwiseOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NoneElementwiseOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NoneElementwiseOptionBuilder {
  typedef NoneElementwiseOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NoneElementwiseOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NoneElementwiseOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NoneElementwiseOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<NoneElementwiseOption> CreateNoneElementwiseOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NoneElementwiseOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NoneElementwiseOption> CreateNoneElementwiseOption(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddOptionT : public flatbuffers::NativeTable {
  typedef AddOption TableType;
};

struct AddOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddOptionT NativeTableType;
  typedef AddOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddOptionBuilder {
  typedef AddOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOption> CreateAddOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddOption> CreateAddOption(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulOptionT : public flatbuffers::NativeTable {
  typedef MulOption TableType;
};

struct MulOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulOptionT NativeTableType;
  typedef MulOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MulOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulOptionBuilder {
  typedef MulOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOption> CreateMulOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MulOption> CreateMulOption(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinOptionT : public flatbuffers::NativeTable {
  typedef MinOption TableType;
};

struct MinOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinOptionT NativeTableType;
  typedef MinOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MinOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinOptionBuilder {
  typedef MinOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MinOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MinOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MinOption> CreateMinOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MinOption> CreateMinOption(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaxOptionT : public flatbuffers::NativeTable {
  typedef MaxOption TableType;
};

struct MaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxOptionT NativeTableType;
  typedef MaxOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaxOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaxOptionBuilder {
  typedef MaxOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxOption> CreateMaxOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaxOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaxOption> CreateMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeanOptionT : public flatbuffers::NativeTable {
  typedef MeanOption TableType;
};

struct MeanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeanOptionT NativeTableType;
  typedef MeanOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MeanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MeanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeanOptionBuilder {
  typedef MeanOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MeanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MeanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeanOption> CreateMeanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MeanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MeanOption> CreateMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivOptionT : public flatbuffers::NativeTable {
  typedef DivOption TableType;
};

struct DivOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivOptionT NativeTableType;
  typedef DivOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DivOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivOptionBuilder {
  typedef DivOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOption> CreateDivOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DivOption> CreateDivOption(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualOptionT : public flatbuffers::NativeTable {
  typedef GreaterEqualOption TableType;
};

struct GreaterEqualOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualOptionT NativeTableType;
  typedef GreaterEqualOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterEqualOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqualOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualOptionBuilder {
  typedef GreaterEqualOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterEqualOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOption> CreateGreaterEqualOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqualOption> CreateGreaterEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterThanOptionT : public flatbuffers::NativeTable {
  typedef GreaterThanOption TableType;
};

struct GreaterThanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterThanOptionT NativeTableType;
  typedef GreaterThanOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterThanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterThanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterThanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterThanOptionBuilder {
  typedef GreaterThanOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterThanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterThanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterThanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterThanOption> CreateGreaterThanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterThanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterThanOption> CreateGreaterThanOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualOptionT : public flatbuffers::NativeTable {
  typedef LessEqualOption TableType;
};

struct LessEqualOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualOptionT NativeTableType;
  typedef LessEqualOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessEqualOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqualOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualOptionBuilder {
  typedef LessEqualOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessEqualOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOption> CreateLessEqualOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqualOption> CreateLessEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessThanOptionT : public flatbuffers::NativeTable {
  typedef LessThanOption TableType;
};

struct LessThanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessThanOptionT NativeTableType;
  typedef LessThanOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessThanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessThanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessThanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessThanOptionBuilder {
  typedef LessThanOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessThanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessThanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessThanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessThanOption> CreateLessThanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessThanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessThanOption> CreateLessThanOption(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualToOptionT : public flatbuffers::NativeTable {
  typedef EqualToOption TableType;
};

struct EqualToOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualToOptionT NativeTableType;
  typedef EqualToOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EqualToOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualToOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualToOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EqualToOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualToOptionBuilder {
  typedef EqualToOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualToOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EqualToOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualToOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualToOption> CreateEqualToOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualToOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EqualToOption> CreateEqualToOption(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualOptionT : public flatbuffers::NativeTable {
  typedef NotEqualOption TableType;
};

struct NotEqualOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualOptionT NativeTableType;
  typedef NotEqualOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NotEqualOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqualOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualOptionBuilder {
  typedef NotEqualOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NotEqualOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOption> CreateNotEqualOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqualOption> CreateNotEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMinOptionT : public flatbuffers::NativeTable {
  typedef ReduceMinOption TableType;
};

struct ReduceMinOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMinOptionT NativeTableType;
  typedef ReduceMinOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMinOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMinOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMinOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMinOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMinOptionBuilder {
  typedef ReduceMinOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMinOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceMinOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMinOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMinOption> CreateReduceMinOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMinOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMinOption> CreateReduceMinOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMaxOptionT : public flatbuffers::NativeTable {
  typedef ReduceMaxOption TableType;
};

struct ReduceMaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMaxOptionT NativeTableType;
  typedef ReduceMaxOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMaxOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMaxOptionBuilder {
  typedef ReduceMaxOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceMaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMaxOption> CreateReduceMaxOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMaxOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMaxOption> CreateReduceMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMeanOptionT : public flatbuffers::NativeTable {
  typedef ReduceMeanOption TableType;
};

struct ReduceMeanOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMeanOptionT NativeTableType;
  typedef ReduceMeanOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMeanOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMeanOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMeanOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMeanOptionBuilder {
  typedef ReduceMeanOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMeanOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceMeanOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMeanOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMeanOption> CreateReduceMeanOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMeanOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMeanOption> CreateReduceMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceSumOptionT : public flatbuffers::NativeTable {
  typedef ReduceSumOption TableType;
};

struct ReduceSumOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceSumOptionT NativeTableType;
  typedef ReduceSumOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceSumOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceSumOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceSumOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceSumOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceSumOptionBuilder {
  typedef ReduceSumOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceSumOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceSumOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceSumOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceSumOption> CreateReduceSumOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceSumOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceSumOption> CreateReduceSumOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceMulOptionT : public flatbuffers::NativeTable {
  typedef ReduceMulOption TableType;
};

struct ReduceMulOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceMulOptionT NativeTableType;
  typedef ReduceMulOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceMulOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReduceMulOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceMulOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceMulOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceMulOptionBuilder {
  typedef ReduceMulOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReduceMulOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceMulOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceMulOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceMulOption> CreateReduceMulOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReduceMulOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceMulOption> CreateReduceMulOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool2DOptionT : public flatbuffers::NativeTable {
  typedef Pool2DOption TableType;
  std::vector<int32_t> size{};
  ace::PoolType type = ace::PoolType_MAX_POOL;
  std::vector<int32_t> strides{};
  std::vector<int32_t> padding{};
  ace::PaddingType padtype = ace::PaddingType_VALID;
  bool global_pooling = false;
  bool ceil_mode = false;
  bool exclusive = true;
};

struct Pool2DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool2DOptionT NativeTableType;
  typedef Pool2DOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool2DOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_TYPE = 6,
    VT_STRIDES = 8,
    VT_PADDING = 10,
    VT_PADTYPE = 12,
    VT_GLOBAL_POOLING = 14,
    VT_CEIL_MODE = 16,
    VT_EXCLUSIVE = 18
  };
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  ace::PoolType type() const {
    return static_cast<ace::PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int32_t> *padding() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDING);
  }
  ace::PaddingType padtype() const {
    return static_cast<ace::PaddingType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  bool global_pooling() const {
    return GetField<uint8_t>(VT_GLOBAL_POOLING, 0) != 0;
  }
  bool ceil_mode() const {
    return GetField<uint8_t>(VT_CEIL_MODE, 0) != 0;
  }
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL_POOLING, 1) &&
           VerifyField<uint8_t>(verifier, VT_CEIL_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&
           verifier.EndTable();
  }
  Pool2DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool2DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool2DOptionBuilder {
  typedef Pool2DOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Pool2DOption::VT_SIZE, size);
  }
  void add_type(ace::PoolType type) {
    fbb_.AddElement<int8_t>(Pool2DOption::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Pool2DOption::VT_STRIDES, strides);
  }
  void add_padding(flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding) {
    fbb_.AddOffset(Pool2DOption::VT_PADDING, padding);
  }
  void add_padtype(ace::PaddingType padtype) {
    fbb_.AddElement<int8_t>(Pool2DOption::VT_PADTYPE, static_cast<int8_t>(padtype), 0);
  }
  void add_global_pooling(bool global_pooling) {
    fbb_.AddElement<uint8_t>(Pool2DOption::VT_GLOBAL_POOLING, static_cast<uint8_t>(global_pooling), 0);
  }
  void add_ceil_mode(bool ceil_mode) {
    fbb_.AddElement<uint8_t>(Pool2DOption::VT_CEIL_MODE, static_cast<uint8_t>(ceil_mode), 0);
  }
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(Pool2DOption::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 1);
  }
  explicit Pool2DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pool2DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOption> CreatePool2DOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    ace::PoolType type = ace::PoolType_MAX_POOL,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding = 0,
    ace::PaddingType padtype = ace::PaddingType_VALID,
    bool global_pooling = false,
    bool ceil_mode = false,
    bool exclusive = true) {
  Pool2DOptionBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_strides(strides);
  builder_.add_size(size);
  builder_.add_exclusive(exclusive);
  builder_.add_ceil_mode(ceil_mode);
  builder_.add_global_pooling(global_pooling);
  builder_.add_padtype(padtype);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pool2DOption> CreatePool2DOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *size = nullptr,
    ace::PoolType type = ace::PoolType_MAX_POOL,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *padding = nullptr,
    ace::PaddingType padtype = ace::PaddingType_VALID,
    bool global_pooling = false,
    bool ceil_mode = false,
    bool exclusive = true) {
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto padding__ = padding ? _fbb.CreateVector<int32_t>(*padding) : 0;
  return ace::CreatePool2DOption(
      _fbb,
      size__,
      type,
      strides__,
      padding__,
      padtype,
      global_pooling,
      ceil_mode,
      exclusive);
}

flatbuffers::Offset<Pool2DOption> CreatePool2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pool3DOptionT : public flatbuffers::NativeTable {
  typedef Pool3DOption TableType;
};

struct Pool3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pool3DOptionT NativeTableType;
  typedef Pool3DOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pool3DOptionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Pool3DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pool3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pool3DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pool3DOptionBuilder {
  typedef Pool3DOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Pool3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pool3DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool3DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool3DOption> CreatePool3DOption(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Pool3DOptionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Pool3DOption> CreatePool3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeOptionT : public flatbuffers::NativeTable {
  typedef ReshapeOption TableType;
  std::vector<int32_t> dims{};
  ace::DataFormat dimType = ace::DataFormat_NONE;
};

struct ReshapeOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeOptionT NativeTableType;
  typedef ReshapeOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DIMTYPE = 6
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  ace::DataFormat dimType() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_DIMTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, VT_DIMTYPE, 1) &&
           verifier.EndTable();
  }
  ReshapeOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeOptionBuilder {
  typedef ReshapeOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(ReshapeOption::VT_DIMS, dims);
  }
  void add_dimType(ace::DataFormat dimType) {
    fbb_.AddElement<int8_t>(ReshapeOption::VT_DIMTYPE, static_cast<int8_t>(dimType), 0);
  }
  explicit ReshapeOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReshapeOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOption> CreateReshapeOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    ace::DataFormat dimType = ace::DataFormat_NONE) {
  ReshapeOptionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimType(dimType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOption> CreateReshapeOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    ace::DataFormat dimType = ace::DataFormat_NONE) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return ace::CreateReshapeOption(
      _fbb,
      dims__,
      dimType);
}

flatbuffers::Offset<ReshapeOption> CreateReshapeOption(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceOptionT : public flatbuffers::NativeTable {
  typedef SliceOption TableType;
  int32_t axis = 0;
  std::vector<int32_t> slicePoints{};
  ace::FrontendFramework sourceType = ace::FrontendFramework_NONE;
};

struct SliceOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceOptionT NativeTableType;
  typedef SliceOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SLICEPOINTS = 6,
    VT_SOURCETYPE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *slicePoints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLICEPOINTS);
  }
  ace::FrontendFramework sourceType() const {
    return static_cast<ace::FrontendFramework>(GetField<int8_t>(VT_SOURCETYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyOffset(verifier, VT_SLICEPOINTS) &&
           verifier.VerifyVector(slicePoints()) &&
           VerifyField<int8_t>(verifier, VT_SOURCETYPE, 1) &&
           verifier.EndTable();
  }
  SliceOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceOptionBuilder {
  typedef SliceOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SliceOption::VT_AXIS, axis, 0);
  }
  void add_slicePoints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints) {
    fbb_.AddOffset(SliceOption::VT_SLICEPOINTS, slicePoints);
  }
  void add_sourceType(ace::FrontendFramework sourceType) {
    fbb_.AddElement<int8_t>(SliceOption::VT_SOURCETYPE, static_cast<int8_t>(sourceType), 0);
  }
  explicit SliceOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SliceOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOption> CreateSliceOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slicePoints = 0,
    ace::FrontendFramework sourceType = ace::FrontendFramework_NONE) {
  SliceOptionBuilder builder_(_fbb);
  builder_.add_slicePoints(slicePoints);
  builder_.add_axis(axis);
  builder_.add_sourceType(sourceType);
  return builder_.Finish();
}

inline flatbuffers::Offset<SliceOption> CreateSliceOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *slicePoints = nullptr,
    ace::FrontendFramework sourceType = ace::FrontendFramework_NONE) {
  auto slicePoints__ = slicePoints ? _fbb.CreateVector<int32_t>(*slicePoints) : 0;
  return ace::CreateSliceOption(
      _fbb,
      axis,
      slicePoints__,
      sourceType);
}

flatbuffers::Offset<SliceOption> CreateSliceOption(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenOptionT : public flatbuffers::NativeTable {
  typedef FlattenOption TableType;
  int32_t axis = 0;
  int32_t endAxis = 0;
};

struct FlattenOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenOptionT NativeTableType;
  typedef FlattenOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ENDAXIS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t endAxis() const {
    return GetField<int32_t>(VT_ENDAXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDAXIS, 4) &&
           verifier.EndTable();
  }
  FlattenOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlattenOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenOptionBuilder {
  typedef FlattenOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(FlattenOption::VT_AXIS, axis, 0);
  }
  void add_endAxis(int32_t endAxis) {
    fbb_.AddElement<int32_t>(FlattenOption::VT_ENDAXIS, endAxis, 0);
  }
  explicit FlattenOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlattenOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenOption> CreateFlattenOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t endAxis = 0) {
  FlattenOptionBuilder builder_(_fbb);
  builder_.add_endAxis(endAxis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<FlattenOption> CreateFlattenOption(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteOptionT : public flatbuffers::NativeTable {
  typedef PermuteOption TableType;
  std::vector<int32_t> dims{};
};

struct PermuteOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteOptionT NativeTableType;
  typedef PermuteOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PermuteOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  PermuteOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PermuteOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteOptionBuilder {
  typedef PermuteOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(PermuteOption::VT_DIMS, dims);
  }
  explicit PermuteOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PermuteOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PermuteOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PermuteOption> CreatePermuteOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  PermuteOptionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<PermuteOption> CreatePermuteOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return ace::CreatePermuteOption(
      _fbb,
      dims__);
}

flatbuffers::Offset<PermuteOption> CreatePermuteOption(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxOptionT : public flatbuffers::NativeTable {
  typedef ArgMaxOption TableType;
  int32_t outMaxVal = 0;
  int32_t topK = 0;
  int32_t axis = 0;
  int32_t softmaxThreshold = 0;
};

struct ArgMaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxOptionT NativeTableType;
  typedef ArgMaxOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTMAXVAL = 4,
    VT_TOPK = 6,
    VT_AXIS = 8,
    VT_SOFTMAXTHRESHOLD = 10
  };
  int32_t outMaxVal() const {
    return GetField<int32_t>(VT_OUTMAXVAL, 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t softmaxThreshold() const {
    return GetField<int32_t>(VT_SOFTMAXTHRESHOLD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTMAXVAL, 4) &&
           VerifyField<int32_t>(verifier, VT_TOPK, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_SOFTMAXTHRESHOLD, 4) &&
           verifier.EndTable();
  }
  ArgMaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxOptionBuilder {
  typedef ArgMaxOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outMaxVal(int32_t outMaxVal) {
    fbb_.AddElement<int32_t>(ArgMaxOption::VT_OUTMAXVAL, outMaxVal, 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMaxOption::VT_TOPK, topK, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMaxOption::VT_AXIS, axis, 0);
  }
  void add_softmaxThreshold(int32_t softmaxThreshold) {
    fbb_.AddElement<int32_t>(ArgMaxOption::VT_SOFTMAXTHRESHOLD, softmaxThreshold, 0);
  }
  explicit ArgMaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOption> CreateArgMaxOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outMaxVal = 0,
    int32_t topK = 0,
    int32_t axis = 0,
    int32_t softmaxThreshold = 0) {
  ArgMaxOptionBuilder builder_(_fbb);
  builder_.add_softmaxThreshold(softmaxThreshold);
  builder_.add_axis(axis);
  builder_.add_topK(topK);
  builder_.add_outMaxVal(outMaxVal);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxOption> CreateArgMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormOptionT : public flatbuffers::NativeTable {
  typedef BatchNormOption TableType;
  int32_t channels = 0;
  std::vector<float> slopeData{};
  std::vector<float> meanData{};
  std::vector<float> varData{};
  std::vector<float> biasData{};
  std::vector<float> Adata{};
  std::vector<float> Bdata{};
  float epsilon = 0.001f;
};

struct BatchNormOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormOptionT NativeTableType;
  typedef BatchNormOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SLOPEDATA = 6,
    VT_MEANDATA = 8,
    VT_VARDATA = 10,
    VT_BIASDATA = 12,
    VT_ADATA = 14,
    VT_BDATA = 16,
    VT_EPSILON = 18
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *slopeData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPEDATA);
  }
  const flatbuffers::Vector<float> *meanData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MEANDATA);
  }
  const flatbuffers::Vector<float> *varData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARDATA);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  const flatbuffers::Vector<float> *Adata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ADATA);
  }
  const flatbuffers::Vector<float> *Bdata() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BDATA);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SLOPEDATA) &&
           verifier.VerifyVector(slopeData()) &&
           VerifyOffset(verifier, VT_MEANDATA) &&
           verifier.VerifyVector(meanData()) &&
           VerifyOffset(verifier, VT_VARDATA) &&
           verifier.VerifyVector(varData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, VT_ADATA) &&
           verifier.VerifyVector(Adata()) &&
           VerifyOffset(verifier, VT_BDATA) &&
           verifier.VerifyVector(Bdata()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           verifier.EndTable();
  }
  BatchNormOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNormOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormOptionBuilder {
  typedef BatchNormOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(BatchNormOption::VT_CHANNELS, channels, 0);
  }
  void add_slopeData(flatbuffers::Offset<flatbuffers::Vector<float>> slopeData) {
    fbb_.AddOffset(BatchNormOption::VT_SLOPEDATA, slopeData);
  }
  void add_meanData(flatbuffers::Offset<flatbuffers::Vector<float>> meanData) {
    fbb_.AddOffset(BatchNormOption::VT_MEANDATA, meanData);
  }
  void add_varData(flatbuffers::Offset<flatbuffers::Vector<float>> varData) {
    fbb_.AddOffset(BatchNormOption::VT_VARDATA, varData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(BatchNormOption::VT_BIASDATA, biasData);
  }
  void add_Adata(flatbuffers::Offset<flatbuffers::Vector<float>> Adata) {
    fbb_.AddOffset(BatchNormOption::VT_ADATA, Adata);
  }
  void add_Bdata(flatbuffers::Offset<flatbuffers::Vector<float>> Bdata) {
    fbb_.AddOffset(BatchNormOption::VT_BDATA, Bdata);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNormOption::VT_EPSILON, epsilon, 0.001f);
  }
  explicit BatchNormOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNormOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormOption> CreateBatchNormOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> slopeData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> meanData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> varData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Adata = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Bdata = 0,
    float epsilon = 0.001f) {
  BatchNormOptionBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_Bdata(Bdata);
  builder_.add_Adata(Adata);
  builder_.add_biasData(biasData);
  builder_.add_varData(varData);
  builder_.add_meanData(meanData);
  builder_.add_slopeData(slopeData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchNormOption> CreateBatchNormOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *slopeData = nullptr,
    const std::vector<float> *meanData = nullptr,
    const std::vector<float> *varData = nullptr,
    const std::vector<float> *biasData = nullptr,
    const std::vector<float> *Adata = nullptr,
    const std::vector<float> *Bdata = nullptr,
    float epsilon = 0.001f) {
  auto slopeData__ = slopeData ? _fbb.CreateVector<float>(*slopeData) : 0;
  auto meanData__ = meanData ? _fbb.CreateVector<float>(*meanData) : 0;
  auto varData__ = varData ? _fbb.CreateVector<float>(*varData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  auto Adata__ = Adata ? _fbb.CreateVector<float>(*Adata) : 0;
  auto Bdata__ = Bdata ? _fbb.CreateVector<float>(*Bdata) : 0;
  return ace::CreateBatchNormOption(
      _fbb,
      channels,
      slopeData__,
      meanData__,
      varData__,
      biasData__,
      Adata__,
      Bdata__,
      epsilon);
}

flatbuffers::Offset<BatchNormOption> CreateBatchNormOption(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DOptionT : public flatbuffers::NativeTable {
  typedef Conv2DOption TableType;
  int32_t padX = 0;
  int32_t padY = 0;
  int32_t kernelX = 1;
  int32_t kernelY = 1;
  int32_t strideX = 1;
  int32_t strideY = 1;
  int32_t dilateX = 1;
  int32_t dilateY = 1;
  ace::PadMode padMode = ace::PadMode_CAFFE;
  int32_t group = 1;
  int32_t outputCount = 0;
  int32_t inputCount = 0;
  bool relu = false;
  bool relu6 = false;
  std::vector<int32_t> pads{};
  std::vector<int32_t> outPads{};
  bool hasOutputShape = false;
};

struct Conv2DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DOptionT NativeTableType;
  typedef Conv2DOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_KERNELX = 8,
    VT_KERNELY = 10,
    VT_STRIDEX = 12,
    VT_STRIDEY = 14,
    VT_DILATEX = 16,
    VT_DILATEY = 18,
    VT_PADMODE = 20,
    VT_GROUP = 22,
    VT_OUTPUTCOUNT = 24,
    VT_INPUTCOUNT = 26,
    VT_RELU = 28,
    VT_RELU6 = 30,
    VT_PADS = 32,
    VT_OUTPADS = 34,
    VT_HASOUTPUTSHAPE = 36
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(VT_DILATEX, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(VT_DILATEY, 1);
  }
  ace::PadMode padMode() const {
    return static_cast<ace::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPADS);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(VT_HASOUTPUTSHAPE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX, 4) &&
           VerifyField<int32_t>(verifier, VT_PADY, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELX, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELY, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATEX, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATEY, 4) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_OUTPADS) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, VT_HASOUTPUTSHAPE, 1) &&
           verifier.EndTable();
  }
  Conv2DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DOptionBuilder {
  typedef Conv2DOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_PADY, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_KERNELX, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_KERNELY, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_STRIDEX, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_STRIDEY, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_DILATEX, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_DILATEY, dilateY, 1);
  }
  void add_padMode(ace::PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DOption::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_GROUP, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Conv2DOption::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Conv2DOption::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Conv2DOption::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Conv2DOption::VT_PADS, pads);
  }
  void add_outPads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(Conv2DOption::VT_OUTPADS, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(Conv2DOption::VT_HASOUTPUTSHAPE, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Conv2DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOption> CreateConv2DOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Conv2DOptionBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_pads(pads);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DOption> CreateConv2DOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *outPads = nullptr,
    bool hasOutputShape = false) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto outPads__ = outPads ? _fbb.CreateVector<int32_t>(*outPads) : 0;
  return ace::CreateConv2DOption(
      _fbb,
      padX,
      padY,
      kernelX,
      kernelY,
      strideX,
      strideY,
      dilateX,
      dilateY,
      padMode,
      group,
      outputCount,
      inputCount,
      relu,
      relu6,
      pads__,
      outPads__,
      hasOutputShape);
}

flatbuffers::Offset<Conv2DOption> CreateConv2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv3DOptionT : public flatbuffers::NativeTable {
  typedef Conv3DOption TableType;
  std::vector<int32_t> dilates{};
  std::vector<int32_t> strides{};
  std::vector<int32_t> kernels{};
  std::vector<int32_t> pads{};
  ace::PadMode padMode = ace::PadMode_CAFFE;
  int32_t inputCount = 0;
  int32_t outputCount = 0;
  bool relu = false;
  bool relu6 = false;
};

struct Conv3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv3DOptionT NativeTableType;
  typedef Conv3DOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv3DOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DILATES = 4,
    VT_STRIDES = 6,
    VT_KERNELS = 8,
    VT_PADS = 10,
    VT_PADMODE = 12,
    VT_INPUTCOUNT = 14,
    VT_OUTPUTCOUNT = 16,
    VT_RELU = 18,
    VT_RELU6 = 20
  };
  const flatbuffers::Vector<int32_t> *dilates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATES);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  ace::PadMode padMode() const {
    return static_cast<ace::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DILATES) &&
           verifier.VerifyVector(dilates()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           verifier.EndTable();
  }
  Conv3DOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv3DOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv3DOptionBuilder {
  typedef Conv3DOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dilates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates) {
    fbb_.AddOffset(Conv3DOption::VT_DILATES, dilates);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Conv3DOption::VT_STRIDES, strides);
  }
  void add_kernels(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Conv3DOption::VT_KERNELS, kernels);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Conv3DOption::VT_PADS, pads);
  }
  void add_padMode(ace::PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv3DOption::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Conv3DOption::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Conv3DOption::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Conv3DOption::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Conv3DOption::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  explicit Conv3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv3DOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOption> CreateConv3DOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilates = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false) {
  Conv3DOptionBuilder builder_(_fbb);
  builder_.add_outputCount(outputCount);
  builder_.add_inputCount(inputCount);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_dilates(dilates);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv3DOption> CreateConv3DOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dilates = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    ace::PadMode padMode = ace::PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false) {
  auto dilates__ = dilates ? _fbb.CreateVector<int32_t>(*dilates) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return ace::CreateConv3DOption(
      _fbb,
      dilates__,
      strides__,
      kernels__,
      pads__,
      padMode,
      inputCount,
      outputCount,
      relu,
      relu6);
}

flatbuffers::Offset<Conv3DOption> CreateConv3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InnerProductOptionT : public flatbuffers::NativeTable {
  typedef InnerProductOption TableType;
  int32_t outputCount = 0;
  int32_t biasTerm = 0;
  int32_t weightSize = 0;
  std::vector<float> weight{};
  std::vector<float> bias{};
  int32_t axis = 0;
  bool transpose = false;
};

struct InnerProductOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InnerProductOptionT NativeTableType;
  typedef InnerProductOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InnerProductOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_BIASTERM = 6,
    VT_WEIGHTSIZE = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12,
    VT_AXIS = 14,
    VT_TRANSPOSE = 16
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(VT_BIASTERM, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(VT_TRANSPOSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_BIASTERM, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE, 4) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE, 1) &&
           verifier.EndTable();
  }
  InnerProductOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InnerProductOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InnerProductOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InnerProductOptionBuilder {
  typedef InnerProductOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(InnerProductOption::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(InnerProductOption::VT_BIASTERM, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(InnerProductOption::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(InnerProductOption::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(InnerProductOption::VT_BIAS, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(InnerProductOption::VT_AXIS, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(InnerProductOption::VT_TRANSPOSE, static_cast<uint8_t>(transpose), 0);
  }
  explicit InnerProductOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InnerProductOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InnerProductOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<InnerProductOption> CreateInnerProductOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false) {
  InnerProductOptionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

inline flatbuffers::Offset<InnerProductOption> CreateInnerProductOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    int32_t axis = 0,
    bool transpose = false) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return ace::CreateInnerProductOption(
      _fbb,
      outputCount,
      biasTerm,
      weightSize,
      weight__,
      bias__,
      axis,
      transpose);
}

flatbuffers::Offset<InnerProductOption> CreateInnerProductOption(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNOptionT : public flatbuffers::NativeTable {
  typedef LRNOption TableType;
  int32_t regionType = 0;
  int32_t localSize = 0;
  float alpha = 0.0f;
  float beta = 0.0f;
};

struct LRNOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNOptionT NativeTableType;
  typedef LRNOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGIONTYPE = 4,
    VT_LOCALSIZE = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t regionType() const {
    return GetField<int32_t>(VT_REGIONTYPE, 0);
  }
  int32_t localSize() const {
    return GetField<int32_t>(VT_LOCALSIZE, 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REGIONTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_LOCALSIZE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           verifier.EndTable();
  }
  LRNOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRNOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNOptionBuilder {
  typedef LRNOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regionType(int32_t regionType) {
    fbb_.AddElement<int32_t>(LRNOption::VT_REGIONTYPE, regionType, 0);
  }
  void add_localSize(int32_t localSize) {
    fbb_.AddElement<int32_t>(LRNOption::VT_LOCALSIZE, localSize, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRNOption::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRNOption::VT_BETA, beta, 0.0f);
  }
  explicit LRNOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LRNOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRNOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRNOption> CreateLRNOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t regionType = 0,
    int32_t localSize = 0,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LRNOptionBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_localSize(localSize);
  builder_.add_regionType(regionType);
  return builder_.Finish();
}

flatbuffers::Offset<LRNOption> CreateLRNOption(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizeOptionT : public flatbuffers::NativeTable {
  typedef NormalizeOption TableType;
  int32_t acrossSpatial = 0;
  int32_t channelShared = 0;
  float eps = 0.0f;
  std::vector<float> scale{};
};

struct NormalizeOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizeOptionT NativeTableType;
  typedef NormalizeOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NormalizeOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACROSSSPATIAL = 4,
    VT_CHANNELSHARED = 6,
    VT_EPS = 8,
    VT_SCALE = 10
  };
  int32_t acrossSpatial() const {
    return GetField<int32_t>(VT_ACROSSSPATIAL, 0);
  }
  int32_t channelShared() const {
    return GetField<int32_t>(VT_CHANNELSHARED, 0);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACROSSSPATIAL, 4) &&
           VerifyField<int32_t>(verifier, VT_CHANNELSHARED, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
  NormalizeOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormalizeOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizeOptionBuilder {
  typedef NormalizeOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acrossSpatial(int32_t acrossSpatial) {
    fbb_.AddElement<int32_t>(NormalizeOption::VT_ACROSSSPATIAL, acrossSpatial, 0);
  }
  void add_channelShared(int32_t channelShared) {
    fbb_.AddElement<int32_t>(NormalizeOption::VT_CHANNELSHARED, channelShared, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(NormalizeOption::VT_EPS, eps, 0.0f);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(NormalizeOption::VT_SCALE, scale);
  }
  explicit NormalizeOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NormalizeOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormalizeOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<NormalizeOption> CreateNormalizeOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  NormalizeOptionBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_eps(eps);
  builder_.add_channelShared(channelShared);
  builder_.add_acrossSpatial(acrossSpatial);
  return builder_.Finish();
}

inline flatbuffers::Offset<NormalizeOption> CreateNormalizeOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    const std::vector<float> *scale = nullptr) {
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return ace::CreateNormalizeOption(
      _fbb,
      acrossSpatial,
      channelShared,
      eps,
      scale__);
}

flatbuffers::Offset<NormalizeOption> CreateNormalizeOption(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxOptionT : public flatbuffers::NativeTable {
  typedef PriorBoxOption TableType;
  std::vector<float> minSizes{};
  std::vector<float> maxSizes{};
  std::vector<float> aspectRatios{};
  std::vector<float> variances{};
  bool flip = false;
  bool clip = false;
  int32_t imageWidth = 0;
  int32_t imageHeight = 0;
  int32_t stepWidth = 0;
  int32_t stepHeight = 0;
  float offset = 0.0f;
};

struct PriorBoxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxOptionT NativeTableType;
  typedef PriorBoxOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINSIZES = 4,
    VT_MAXSIZES = 6,
    VT_ASPECTRATIOS = 8,
    VT_VARIANCES = 10,
    VT_FLIP = 12,
    VT_CLIP = 14,
    VT_IMAGEWIDTH = 16,
    VT_IMAGEHEIGHT = 18,
    VT_STEPWIDTH = 20,
    VT_STEPHEIGHT = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<float> *minSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MINSIZES);
  }
  const flatbuffers::Vector<float> *maxSizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAXSIZES);
  }
  const flatbuffers::Vector<float> *aspectRatios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECTRATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  int32_t imageWidth() const {
    return GetField<int32_t>(VT_IMAGEWIDTH, 0);
  }
  int32_t imageHeight() const {
    return GetField<int32_t>(VT_IMAGEHEIGHT, 0);
  }
  int32_t stepWidth() const {
    return GetField<int32_t>(VT_STEPWIDTH, 0);
  }
  int32_t stepHeight() const {
    return GetField<int32_t>(VT_STEPHEIGHT, 0);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINSIZES) &&
           verifier.VerifyVector(minSizes()) &&
           VerifyOffset(verifier, VT_MAXSIZES) &&
           verifier.VerifyVector(maxSizes()) &&
           VerifyOffset(verifier, VT_ASPECTRATIOS) &&
           verifier.VerifyVector(aspectRatios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint8_t>(verifier, VT_FLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLIP, 1) &&
           VerifyField<int32_t>(verifier, VT_IMAGEWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_IMAGEHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_OFFSET, 4) &&
           verifier.EndTable();
  }
  PriorBoxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBoxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxOptionBuilder {
  typedef PriorBoxOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minSizes(flatbuffers::Offset<flatbuffers::Vector<float>> minSizes) {
    fbb_.AddOffset(PriorBoxOption::VT_MINSIZES, minSizes);
  }
  void add_maxSizes(flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes) {
    fbb_.AddOffset(PriorBoxOption::VT_MAXSIZES, maxSizes);
  }
  void add_aspectRatios(flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios) {
    fbb_.AddOffset(PriorBoxOption::VT_ASPECTRATIOS, aspectRatios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBoxOption::VT_VARIANCES, variances);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBoxOption::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBoxOption::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_imageWidth(int32_t imageWidth) {
    fbb_.AddElement<int32_t>(PriorBoxOption::VT_IMAGEWIDTH, imageWidth, 0);
  }
  void add_imageHeight(int32_t imageHeight) {
    fbb_.AddElement<int32_t>(PriorBoxOption::VT_IMAGEHEIGHT, imageHeight, 0);
  }
  void add_stepWidth(int32_t stepWidth) {
    fbb_.AddElement<int32_t>(PriorBoxOption::VT_STEPWIDTH, stepWidth, 0);
  }
  void add_stepHeight(int32_t stepHeight) {
    fbb_.AddElement<int32_t>(PriorBoxOption::VT_STEPHEIGHT, stepHeight, 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBoxOption::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PriorBoxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBoxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> minSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> maxSizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspectRatios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  PriorBoxOptionBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_stepHeight(stepHeight);
  builder_.add_stepWidth(stepWidth);
  builder_.add_imageHeight(imageHeight);
  builder_.add_imageWidth(imageWidth);
  builder_.add_variances(variances);
  builder_.add_aspectRatios(aspectRatios);
  builder_.add_maxSizes(maxSizes);
  builder_.add_minSizes(minSizes);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *minSizes = nullptr,
    const std::vector<float> *maxSizes = nullptr,
    const std::vector<float> *aspectRatios = nullptr,
    const std::vector<float> *variances = nullptr,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  auto minSizes__ = minSizes ? _fbb.CreateVector<float>(*minSizes) : 0;
  auto maxSizes__ = maxSizes ? _fbb.CreateVector<float>(*maxSizes) : 0;
  auto aspectRatios__ = aspectRatios ? _fbb.CreateVector<float>(*aspectRatios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return ace::CreatePriorBoxOption(
      _fbb,
      minSizes__,
      maxSizes__,
      aspectRatios__,
      variances__,
      flip,
      clip,
      imageWidth,
      imageHeight,
      stepWidth,
      stepHeight,
      offset);
}

flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOption(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalOptionT : public flatbuffers::NativeTable {
  typedef ProposalOption TableType;
  int32_t featStride = 0;
  int32_t baseSize = 0;
  int32_t preNmsTopN = 0;
  int32_t afterNmsTopN = 0;
  float nmsThreshold = 0.0f;
  int32_t minSize = 0;
};

struct ProposalOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalOptionT NativeTableType;
  typedef ProposalOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProposalOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATSTRIDE = 4,
    VT_BASESIZE = 6,
    VT_PRENMSTOPN = 8,
    VT_AFTERNMSTOPN = 10,
    VT_NMSTHRESHOLD = 12,
    VT_MINSIZE = 14
  };
  int32_t featStride() const {
    return GetField<int32_t>(VT_FEATSTRIDE, 0);
  }
  int32_t baseSize() const {
    return GetField<int32_t>(VT_BASESIZE, 0);
  }
  int32_t preNmsTopN() const {
    return GetField<int32_t>(VT_PRENMSTOPN, 0);
  }
  int32_t afterNmsTopN() const {
    return GetField<int32_t>(VT_AFTERNMSTOPN, 0);
  }
  float nmsThreshold() const {
    return GetField<float>(VT_NMSTHRESHOLD, 0.0f);
  }
  int32_t minSize() const {
    return GetField<int32_t>(VT_MINSIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FEATSTRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_BASESIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_PRENMSTOPN, 4) &&
           VerifyField<int32_t>(verifier, VT_AFTERNMSTOPN, 4) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_MINSIZE, 4) &&
           verifier.EndTable();
  }
  ProposalOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProposalOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalOptionBuilder {
  typedef ProposalOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_featStride(int32_t featStride) {
    fbb_.AddElement<int32_t>(ProposalOption::VT_FEATSTRIDE, featStride, 0);
  }
  void add_baseSize(int32_t baseSize) {
    fbb_.AddElement<int32_t>(ProposalOption::VT_BASESIZE, baseSize, 0);
  }
  void add_preNmsTopN(int32_t preNmsTopN) {
    fbb_.AddElement<int32_t>(ProposalOption::VT_PRENMSTOPN, preNmsTopN, 0);
  }
  void add_afterNmsTopN(int32_t afterNmsTopN) {
    fbb_.AddElement<int32_t>(ProposalOption::VT_AFTERNMSTOPN, afterNmsTopN, 0);
  }
  void add_nmsThreshold(float nmsThreshold) {
    fbb_.AddElement<float>(ProposalOption::VT_NMSTHRESHOLD, nmsThreshold, 0.0f);
  }
  void add_minSize(int32_t minSize) {
    fbb_.AddElement<int32_t>(ProposalOption::VT_MINSIZE, minSize, 0);
  }
  explicit ProposalOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProposalOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProposalOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalOption> CreateProposalOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featStride = 0,
    int32_t baseSize = 0,
    int32_t preNmsTopN = 0,
    int32_t afterNmsTopN = 0,
    float nmsThreshold = 0.0f,
    int32_t minSize = 0) {
  ProposalOptionBuilder builder_(_fbb);
  builder_.add_minSize(minSize);
  builder_.add_nmsThreshold(nmsThreshold);
  builder_.add_afterNmsTopN(afterNmsTopN);
  builder_.add_preNmsTopN(preNmsTopN);
  builder_.add_baseSize(baseSize);
  builder_.add_featStride(featStride);
  return builder_.Finish();
}

flatbuffers::Offset<ProposalOption> CreateProposalOption(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeOptionT : public flatbuffers::NativeTable {
  typedef ResizeOption TableType;
  float xScale = 0.0f;
  float yScale = 0.0f;
};

struct ResizeOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeOptionT NativeTableType;
  typedef ResizeOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XSCALE = 4,
    VT_YSCALE = 6
  };
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_XSCALE, 4) &&
           VerifyField<float>(verifier, VT_YSCALE, 4) &&
           verifier.EndTable();
  }
  ResizeOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeOptionBuilder {
  typedef ResizeOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(ResizeOption::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(ResizeOption::VT_YSCALE, yScale, 0.0f);
  }
  explicit ResizeOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResizeOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeOption> CreateResizeOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    float xScale = 0.0f,
    float yScale = 0.0f) {
  ResizeOptionBuilder builder_(_fbb);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeOption> CreateResizeOption(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoiPoolingOptionT : public flatbuffers::NativeTable {
  typedef RoiPoolingOption TableType;
  int32_t pooledWidth = 0;
  int32_t pooledHeight = 0;
  float spatialScale = 0.0f;
};

struct RoiPoolingOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoiPoolingOptionT NativeTableType;
  typedef RoiPoolingOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoiPoolingOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLEDWIDTH = 4,
    VT_POOLEDHEIGHT = 6,
    VT_SPATIALSCALE = 8
  };
  int32_t pooledWidth() const {
    return GetField<int32_t>(VT_POOLEDWIDTH, 0);
  }
  int32_t pooledHeight() const {
    return GetField<int32_t>(VT_POOLEDHEIGHT, 0);
  }
  float spatialScale() const {
    return GetField<float>(VT_SPATIALSCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POOLEDWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_POOLEDHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_SPATIALSCALE, 4) &&
           verifier.EndTable();
  }
  RoiPoolingOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoiPoolingOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoiPoolingOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoiPoolingOptionBuilder {
  typedef RoiPoolingOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledWidth(int32_t pooledWidth) {
    fbb_.AddElement<int32_t>(RoiPoolingOption::VT_POOLEDWIDTH, pooledWidth, 0);
  }
  void add_pooledHeight(int32_t pooledHeight) {
    fbb_.AddElement<int32_t>(RoiPoolingOption::VT_POOLEDHEIGHT, pooledHeight, 0);
  }
  void add_spatialScale(float spatialScale) {
    fbb_.AddElement<float>(RoiPoolingOption::VT_SPATIALSCALE, spatialScale, 0.0f);
  }
  explicit RoiPoolingOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoiPoolingOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoiPoolingOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoiPoolingOption> CreateRoiPoolingOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledWidth = 0,
    int32_t pooledHeight = 0,
    float spatialScale = 0.0f) {
  RoiPoolingOptionBuilder builder_(_fbb);
  builder_.add_spatialScale(spatialScale);
  builder_.add_pooledHeight(pooledHeight);
  builder_.add_pooledWidth(pooledWidth);
  return builder_.Finish();
}

flatbuffers::Offset<RoiPoolingOption> CreateRoiPoolingOption(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleOptionT : public flatbuffers::NativeTable {
  typedef ScaleOption TableType;
  int32_t channels = 0;
  std::vector<float> scaleData{};
  std::vector<float> biasData{};
};

struct ScaleOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleOptionT NativeTableType;
  typedef ScaleOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SCALEDATA = 6,
    VT_BIASDATA = 8
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<float> *scaleData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALEDATA);
  }
  const flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SCALEDATA) &&
           verifier.VerifyVector(scaleData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           verifier.EndTable();
  }
  ScaleOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScaleOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleOptionBuilder {
  typedef ScaleOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(ScaleOption::VT_CHANNELS, channels, 0);
  }
  void add_scaleData(flatbuffers::Offset<flatbuffers::Vector<float>> scaleData) {
    fbb_.AddOffset(ScaleOption::VT_SCALEDATA, scaleData);
  }
  void add_biasData(flatbuffers::Offset<flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(ScaleOption::VT_BIASDATA, biasData);
  }
  explicit ScaleOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScaleOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScaleOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScaleOption> CreateScaleOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scaleData = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> biasData = 0) {
  ScaleOptionBuilder builder_(_fbb);
  builder_.add_biasData(biasData);
  builder_.add_scaleData(scaleData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScaleOption> CreateScaleOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *scaleData = nullptr,
    const std::vector<float> *biasData = nullptr) {
  auto scaleData__ = scaleData ? _fbb.CreateVector<float>(*scaleData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  return ace::CreateScaleOption(
      _fbb,
      channels,
      scaleData__,
      biasData__);
}

flatbuffers::Offset<ScaleOption> CreateScaleOption(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxOptionT : public flatbuffers::NativeTable {
  typedef SoftmaxOption TableType;
  int32_t axis = 0;
};

struct SoftmaxOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxOptionT NativeTableType;
  typedef SoftmaxOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
  SoftmaxOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxOptionBuilder {
  typedef SoftmaxOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SoftmaxOption::VT_AXIS, axis, 0);
  }
  explicit SoftmaxOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftmaxOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOption> CreateSoftmaxOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  SoftmaxOptionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxOption> CreateSoftmaxOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputOptionT : public flatbuffers::NativeTable {
  typedef InputOption TableType;
  std::vector<int32_t> dims{};
  ace::DataType dtype = ace::DataType_NONE;
  ace::DataFormat dformat = ace::DataFormat_NONE;
};

struct InputOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputOptionT NativeTableType;
  typedef InputOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  ace::DataType dtype() const {
    return static_cast<ace::DataType>(GetField<int8_t>(VT_DTYPE, 0));
  }
  ace::DataFormat dformat() const {
    return static_cast<ace::DataFormat>(GetField<int8_t>(VT_DFORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_DFORMAT, 1) &&
           verifier.EndTable();
  }
  InputOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputOptionBuilder {
  typedef InputOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(InputOption::VT_DIMS, dims);
  }
  void add_dtype(ace::DataType dtype) {
    fbb_.AddElement<int8_t>(InputOption::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_dformat(ace::DataFormat dformat) {
    fbb_.AddElement<int8_t>(InputOption::VT_DFORMAT, static_cast<int8_t>(dformat), 0);
  }
  explicit InputOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputOption> CreateInputOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    ace::DataType dtype = ace::DataType_NONE,
    ace::DataFormat dformat = ace::DataFormat_NONE) {
  InputOptionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline flatbuffers::Offset<InputOption> CreateInputOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    ace::DataType dtype = ace::DataType_NONE,
    ace::DataFormat dformat = ace::DataFormat_NONE) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return ace::CreateInputOption(
      _fbb,
      dims__,
      dtype,
      dformat);
}

flatbuffers::Offset<InputOption> CreateInputOption(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DefaultOptionT : public flatbuffers::NativeTable {
  typedef DefaultOption TableType;
  std::string type{};
  std::string engine{};
  std::vector<int8_t> info{};
  std::vector<std::unique_ptr<ace::AttributeT>> attr{};
  DefaultOptionT() = default;
  DefaultOptionT(const DefaultOptionT &o);
  DefaultOptionT(DefaultOptionT&&) FLATBUFFERS_NOEXCEPT = default;
  DefaultOptionT &operator=(DefaultOptionT o) FLATBUFFERS_NOEXCEPT;
};

struct DefaultOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DefaultOptionT NativeTableType;
  typedef DefaultOptionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DefaultOptionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ENGINE = 6,
    VT_INFO = 8,
    VT_ATTR = 10
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *engine() const {
    return GetPointer<const flatbuffers::String *>(VT_ENGINE);
  }
  const flatbuffers::Vector<int8_t> *info() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>> *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ENGINE) &&
           verifier.VerifyString(engine()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  DefaultOptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DefaultOptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DefaultOption> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DefaultOptionBuilder {
  typedef DefaultOption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(DefaultOption::VT_TYPE, type);
  }
  void add_engine(flatbuffers::Offset<flatbuffers::String> engine) {
    fbb_.AddOffset(DefaultOption::VT_ENGINE, engine);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<int8_t>> info) {
    fbb_.AddOffset(DefaultOption::VT_INFO, info);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> attr) {
    fbb_.AddOffset(DefaultOption::VT_ATTR, attr);
  }
  explicit DefaultOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DefaultOption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DefaultOption>(end);
    return o;
  }
};

inline flatbuffers::Offset<DefaultOption> CreateDefaultOption(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> engine = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ace::Attribute>>> attr = 0) {
  DefaultOptionBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_info(info);
  builder_.add_engine(engine);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DefaultOption> CreateDefaultOptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *engine = nullptr,
    const std::vector<int8_t> *info = nullptr,
    std::vector<flatbuffers::Offset<ace::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto engine__ = engine ? _fbb.CreateString(engine) : 0;
  auto info__ = info ? _fbb.CreateVector<int8_t>(*info) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<ace::Attribute>(attr) : 0;
  return ace::CreateDefaultOption(
      _fbb,
      type__,
      engine__,
      info__,
      attr__);
}

flatbuffers::Offset<DefaultOption> CreateDefaultOption(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AbsOptionT *AbsOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AbsOptionT>(new AbsOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbsOption::UnPackTo(AbsOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsOption> AbsOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsOption> CreateAbsOption(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateAbsOption(
      _fbb);
}

inline BoundedReluOptionT *BoundedReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BoundedReluOptionT>(new BoundedReluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoundedReluOption::UnPackTo(BoundedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BoundedReluOption> BoundedReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoundedReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BoundedReluOption> CreateBoundedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const BoundedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BoundedReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateBoundedReluOption(
      _fbb);
}

inline ClipOptionT *ClipOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClipOptionT>(new ClipOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClipOption::UnPackTo(ClipOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ClipOption> ClipOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClipOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClipOption> CreateClipOption(flatbuffers::FlatBufferBuilder &_fbb, const ClipOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateClipOption(
      _fbb);
}

inline ClipV2OptionT *ClipV2Option::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClipV2OptionT>(new ClipV2OptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClipV2Option::UnPackTo(ClipV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ClipV2Option> ClipV2Option::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClipV2Option(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClipV2Option> CreateClipV2Option(flatbuffers::FlatBufferBuilder &_fbb, const ClipV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipV2OptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateClipV2Option(
      _fbb);
}

inline EluOptionT *EluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EluOptionT>(new EluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EluOption::UnPackTo(EluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<EluOption> EluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EluOption> CreateEluOption(flatbuffers::FlatBufferBuilder &_fbb, const EluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return ace::CreateEluOption(
      _fbb,
      _alpha);
}

inline ExpOptionT *ExpOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpOptionT>(new ExpOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpOption::UnPackTo(ExpOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpOption> ExpOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpOption> CreateExpOption(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateExpOption(
      _fbb);
}

inline GeluTanhOptionT *GeluTanhOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeluTanhOptionT>(new GeluTanhOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeluTanhOption::UnPackTo(GeluTanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GeluTanhOption> GeluTanhOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeluTanhOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeluTanhOption> CreateGeluTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const GeluTanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeluTanhOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateGeluTanhOption(
      _fbb);
}

inline HardSigmoidOptionT *HardSigmoidOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HardSigmoidOptionT>(new HardSigmoidOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HardSigmoidOption::UnPackTo(HardSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSigmoidOption> HardSigmoidOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSigmoidOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSigmoidOption> CreateHardSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSigmoidOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateHardSigmoidOption(
      _fbb);
}

inline HardSwishOptionT *HardSwishOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HardSwishOptionT>(new HardSwishOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HardSwishOption::UnPackTo(HardSwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HardSwishOption> HardSwishOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHardSwishOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HardSwishOption> CreateHardSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateHardSwishOption(
      _fbb);
}

inline LinearOptionT *LinearOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LinearOptionT>(new LinearOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LinearOption::UnPackTo(LinearOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LinearOption> LinearOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLinearOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LinearOption> CreateLinearOption(flatbuffers::FlatBufferBuilder &_fbb, const LinearOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LinearOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLinearOption(
      _fbb);
}

inline LogOptionT *LogOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogOptionT>(new LogOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogOption::UnPackTo(LogOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogOption> LogOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogOption> CreateLogOption(flatbuffers::FlatBufferBuilder &_fbb, const LogOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLogOption(
      _fbb);
}

inline LogisticOptionT *LogisticOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogisticOptionT>(new LogisticOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogisticOption::UnPackTo(LogisticOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogisticOption> LogisticOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogisticOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogisticOption> CreateLogisticOption(flatbuffers::FlatBufferBuilder &_fbb, const LogisticOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogisticOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLogisticOption(
      _fbb);
}

inline MishOptionT *MishOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MishOptionT>(new MishOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MishOption::UnPackTo(MishOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MishOption> MishOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMishOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MishOption> CreateMishOption(flatbuffers::FlatBufferBuilder &_fbb, const MishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MishOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMishOption(
      _fbb);
}

inline PowOptionT *PowOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PowOptionT>(new PowOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowOption::UnPackTo(PowOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<PowOption> PowOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowOption> CreatePowOption(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreatePowOption(
      _fbb);
}

inline PReluOptionT *PReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PReluOptionT>(new PReluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PReluOption::UnPackTo(PReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slopeCount(); _o->slopeCount = _e; }
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PReluOption> PReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PReluOption> CreatePReluOption(flatbuffers::FlatBufferBuilder &_fbb, const PReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slopeCount = _o->slopeCount;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return ace::CreatePReluOption(
      _fbb,
      _slopeCount,
      _slope);
}

inline ReluOptionT *ReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReluOptionT>(new ReluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReluOption::UnPackTo(ReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; }
}

inline flatbuffers::Offset<ReluOption> ReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReluOption> CreateReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return ace::CreateReluOption(
      _fbb,
      _slope);
}

inline Relu6OptionT *Relu6Option::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Relu6OptionT>(new Relu6OptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Relu6Option::UnPackTo(Relu6OptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minval(); _o->minval = _e; }
  { auto _e = maxval(); _o->maxval = _e; }
}

inline flatbuffers::Offset<Relu6Option> Relu6Option::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelu6Option(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Relu6Option> CreateRelu6Option(flatbuffers::FlatBufferBuilder &_fbb, const Relu6OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Relu6OptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minval = _o->minval;
  auto _maxval = _o->maxval;
  return ace::CreateRelu6Option(
      _fbb,
      _minval,
      _maxval);
}

inline ClippedReluOptionT *ClippedReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClippedReluOptionT>(new ClippedReluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ClippedReluOption::UnPackTo(ClippedReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = threashod(); _o->threashod = _e; }
}

inline flatbuffers::Offset<ClippedReluOption> ClippedReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClippedReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ClippedReluOption> CreateClippedReluOption(flatbuffers::FlatBufferBuilder &_fbb, const ClippedReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClippedReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _threashod = _o->threashod;
  return ace::CreateClippedReluOption(
      _fbb,
      _threashod);
}

inline LeakyReluOptionT *LeakyReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LeakyReluOptionT>(new LeakyReluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeakyReluOption::UnPackTo(LeakyReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = negative_slope(); _o->negative_slope = _e; }
}

inline flatbuffers::Offset<LeakyReluOption> LeakyReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluOption> CreateLeakyReluOption(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _negative_slope = _o->negative_slope;
  return ace::CreateLeakyReluOption(
      _fbb,
      _negative_slope);
}

inline LogSigmoidOptionT *LogSigmoidOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogSigmoidOptionT>(new LogSigmoidOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogSigmoidOption::UnPackTo(LogSigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogSigmoidOption> LogSigmoidOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSigmoidOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSigmoidOption> CreateLogSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const LogSigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSigmoidOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLogSigmoidOption(
      _fbb);
}

inline RoundOptionT *RoundOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoundOptionT>(new RoundOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoundOption::UnPackTo(RoundOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RoundOption> RoundOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoundOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoundOption> CreateRoundOption(flatbuffers::FlatBufferBuilder &_fbb, const RoundOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoundOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateRoundOption(
      _fbb);
}

inline SeluOptionT *SeluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SeluOptionT>(new SeluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SeluOption::UnPackTo(SeluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<SeluOption> SeluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSeluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SeluOption> CreateSeluOption(flatbuffers::FlatBufferBuilder &_fbb, const SeluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SeluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _alpha = _o->alpha;
  return ace::CreateSeluOption(
      _fbb,
      _scale,
      _alpha);
}

inline SigmoidOptionT *SigmoidOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SigmoidOptionT>(new SigmoidOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SigmoidOption::UnPackTo(SigmoidOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SigmoidOption> SigmoidOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidOption> CreateSigmoidOption(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSigmoidOption(
      _fbb);
}

inline SoftReluOptionT *SoftReluOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftReluOptionT>(new SoftReluOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftReluOption::UnPackTo(SoftReluOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SoftReluOption> SoftReluOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftReluOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftReluOption> CreateSoftReluOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftReluOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSoftReluOption(
      _fbb);
}

inline SoftReluV2OptionT *SoftReluV2Option::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftReluV2OptionT>(new SoftReluV2OptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftReluV2Option::UnPackTo(SoftReluV2OptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SoftReluV2Option> SoftReluV2Option::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftReluV2Option(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftReluV2Option> CreateSoftReluV2Option(flatbuffers::FlatBufferBuilder &_fbb, const SoftReluV2OptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftReluV2OptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSoftReluV2Option(
      _fbb);
}

inline SqrtOptionT *SqrtOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqrtOptionT>(new SqrtOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SqrtOption::UnPackTo(SqrtOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SqrtOption> SqrtOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqrtOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqrtOption> CreateSqrtOption(flatbuffers::FlatBufferBuilder &_fbb, const SqrtOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSqrtOption(
      _fbb);
}

inline SwishOptionT *SwishOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwishOptionT>(new SwishOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwishOption::UnPackTo(SwishOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SwishOption> SwishOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwishOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SwishOption> CreateSwishOption(flatbuffers::FlatBufferBuilder &_fbb, const SwishOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwishOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateSwishOption(
      _fbb);
}

inline TanhOptionT *TanhOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TanhOptionT>(new TanhOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TanhOption::UnPackTo(TanhOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TanhOption> TanhOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTanhOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TanhOption> CreateTanhOption(flatbuffers::FlatBufferBuilder &_fbb, const TanhOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TanhOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateTanhOption(
      _fbb);
}

inline ConstOptionT::ConstOptionT(const ConstOptionT &o)
      : tensor((o.tensor) ? new ace::TensorProtoT(*o.tensor) : nullptr) {
}

inline ConstOptionT &ConstOptionT::operator=(ConstOptionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tensor, o.tensor);
  return *this;
}

inline ConstOptionT *ConstOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConstOptionT>(new ConstOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConstOption::UnPackTo(ConstOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); if (_e) _o->tensor = std::unique_ptr<ace::TensorProtoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ConstOption> ConstOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConstOption> CreateConstOption(flatbuffers::FlatBufferBuilder &_fbb, const ConstOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor ? CreateTensorProto(_fbb, _o->tensor.get(), _rehasher) : 0;
  return ace::CreateConstOption(
      _fbb,
      _tensor);
}

inline NoneElementwiseOptionT *NoneElementwiseOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NoneElementwiseOptionT>(new NoneElementwiseOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NoneElementwiseOption::UnPackTo(NoneElementwiseOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NoneElementwiseOption> NoneElementwiseOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNoneElementwiseOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NoneElementwiseOption> CreateNoneElementwiseOption(flatbuffers::FlatBufferBuilder &_fbb, const NoneElementwiseOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NoneElementwiseOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateNoneElementwiseOption(
      _fbb);
}

inline AddOptionT *AddOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddOptionT>(new AddOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddOption::UnPackTo(AddOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddOption> AddOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddOption> CreateAddOption(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateAddOption(
      _fbb);
}

inline MulOptionT *MulOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulOptionT>(new MulOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulOption::UnPackTo(MulOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MulOption> MulOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulOption> CreateMulOption(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMulOption(
      _fbb);
}

inline MinOptionT *MinOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MinOptionT>(new MinOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MinOption::UnPackTo(MinOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MinOption> MinOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MinOption> CreateMinOption(flatbuffers::FlatBufferBuilder &_fbb, const MinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMinOption(
      _fbb);
}

inline MaxOptionT *MaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaxOptionT>(new MaxOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaxOption::UnPackTo(MaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaxOption> MaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaxOption> CreateMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const MaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMaxOption(
      _fbb);
}

inline MeanOptionT *MeanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MeanOptionT>(new MeanOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MeanOption::UnPackTo(MeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MeanOption> MeanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeanOption> CreateMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const MeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateMeanOption(
      _fbb);
}

inline DivOptionT *DivOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DivOptionT>(new DivOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivOption::UnPackTo(DivOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DivOption> DivOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivOption> CreateDivOption(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateDivOption(
      _fbb);
}

inline GreaterEqualOptionT *GreaterEqualOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterEqualOptionT>(new GreaterEqualOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterEqualOption::UnPackTo(GreaterEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqualOption> GreaterEqualOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqualOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqualOption> CreateGreaterEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateGreaterEqualOption(
      _fbb);
}

inline GreaterThanOptionT *GreaterThanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterThanOptionT>(new GreaterThanOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterThanOption::UnPackTo(GreaterThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterThanOption> GreaterThanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterThanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterThanOption> CreateGreaterThanOption(flatbuffers::FlatBufferBuilder &_fbb, const GreaterThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterThanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateGreaterThanOption(
      _fbb);
}

inline LessEqualOptionT *LessEqualOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessEqualOptionT>(new LessEqualOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessEqualOption::UnPackTo(LessEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqualOption> LessEqualOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqualOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqualOption> CreateLessEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLessEqualOption(
      _fbb);
}

inline LessThanOptionT *LessThanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessThanOptionT>(new LessThanOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessThanOption::UnPackTo(LessThanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessThanOption> LessThanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessThanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessThanOption> CreateLessThanOption(flatbuffers::FlatBufferBuilder &_fbb, const LessThanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessThanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateLessThanOption(
      _fbb);
}

inline EqualToOptionT *EqualToOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EqualToOptionT>(new EqualToOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EqualToOption::UnPackTo(EqualToOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EqualToOption> EqualToOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqualToOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EqualToOption> CreateEqualToOption(flatbuffers::FlatBufferBuilder &_fbb, const EqualToOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualToOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateEqualToOption(
      _fbb);
}

inline NotEqualOptionT *NotEqualOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NotEqualOptionT>(new NotEqualOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NotEqualOption::UnPackTo(NotEqualOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqualOption> NotEqualOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqualOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqualOption> CreateNotEqualOption(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateNotEqualOption(
      _fbb);
}

inline ReduceMinOptionT *ReduceMinOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceMinOptionT>(new ReduceMinOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceMinOption::UnPackTo(ReduceMinOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMinOption> ReduceMinOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMinOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMinOption> CreateReduceMinOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMinOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMinOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMinOption(
      _fbb);
}

inline ReduceMaxOptionT *ReduceMaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceMaxOptionT>(new ReduceMaxOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceMaxOption::UnPackTo(ReduceMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMaxOption> ReduceMaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMaxOption> CreateReduceMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMaxOption(
      _fbb);
}

inline ReduceMeanOptionT *ReduceMeanOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceMeanOptionT>(new ReduceMeanOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceMeanOption::UnPackTo(ReduceMeanOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMeanOption> ReduceMeanOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMeanOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMeanOption> CreateReduceMeanOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMeanOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMeanOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMeanOption(
      _fbb);
}

inline ReduceSumOptionT *ReduceSumOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceSumOptionT>(new ReduceSumOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceSumOption::UnPackTo(ReduceSumOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceSumOption> ReduceSumOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceSumOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceSumOption> CreateReduceSumOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceSumOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceSumOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceSumOption(
      _fbb);
}

inline ReduceMulOptionT *ReduceMulOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceMulOptionT>(new ReduceMulOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceMulOption::UnPackTo(ReduceMulOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReduceMulOption> ReduceMulOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceMulOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceMulOption> CreateReduceMulOption(flatbuffers::FlatBufferBuilder &_fbb, const ReduceMulOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceMulOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreateReduceMulOption(
      _fbb);
}

inline Pool2DOptionT *Pool2DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pool2DOptionT>(new Pool2DOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool2DOption::UnPackTo(Pool2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = padding(); if (_e) { _o->padding.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->padding[_i] = _e->Get(_i); } } }
  { auto _e = padtype(); _o->padtype = _e; }
  { auto _e = global_pooling(); _o->global_pooling = _e; }
  { auto _e = ceil_mode(); _o->ceil_mode = _e; }
  { auto _e = exclusive(); _o->exclusive = _e; }
}

inline flatbuffers::Offset<Pool2DOption> Pool2DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool2DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool2DOption> CreatePool2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _type = _o->type;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _padding = _o->padding.size() ? _fbb.CreateVector(_o->padding) : 0;
  auto _padtype = _o->padtype;
  auto _global_pooling = _o->global_pooling;
  auto _ceil_mode = _o->ceil_mode;
  auto _exclusive = _o->exclusive;
  return ace::CreatePool2DOption(
      _fbb,
      _size,
      _type,
      _strides,
      _padding,
      _padtype,
      _global_pooling,
      _ceil_mode,
      _exclusive);
}

inline Pool3DOptionT *Pool3DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pool3DOptionT>(new Pool3DOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pool3DOption::UnPackTo(Pool3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Pool3DOption> Pool3DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePool3DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pool3DOption> CreatePool3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Pool3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool3DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return ace::CreatePool3DOption(
      _fbb);
}

inline ReshapeOptionT *ReshapeOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReshapeOptionT>(new ReshapeOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReshapeOption::UnPackTo(ReshapeOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
  { auto _e = dimType(); _o->dimType = _e; }
}

inline flatbuffers::Offset<ReshapeOption> ReshapeOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeOption> CreateReshapeOption(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dimType = _o->dimType;
  return ace::CreateReshapeOption(
      _fbb,
      _dims,
      _dimType);
}

inline SliceOptionT *SliceOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SliceOptionT>(new SliceOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SliceOption::UnPackTo(SliceOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = slicePoints(); if (_e) { _o->slicePoints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slicePoints[_i] = _e->Get(_i); } } }
  { auto _e = sourceType(); _o->sourceType = _e; }
}

inline flatbuffers::Offset<SliceOption> SliceOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceOption> CreateSliceOption(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _slicePoints = _o->slicePoints.size() ? _fbb.CreateVector(_o->slicePoints) : 0;
  auto _sourceType = _o->sourceType;
  return ace::CreateSliceOption(
      _fbb,
      _axis,
      _slicePoints,
      _sourceType);
}

inline FlattenOptionT *FlattenOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenOptionT>(new FlattenOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlattenOption::UnPackTo(FlattenOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = endAxis(); _o->endAxis = _e; }
}

inline flatbuffers::Offset<FlattenOption> FlattenOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlattenOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlattenOption> CreateFlattenOption(flatbuffers::FlatBufferBuilder &_fbb, const FlattenOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _endAxis = _o->endAxis;
  return ace::CreateFlattenOption(
      _fbb,
      _axis,
      _endAxis);
}

inline PermuteOptionT *PermuteOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PermuteOptionT>(new PermuteOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PermuteOption::UnPackTo(PermuteOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PermuteOption> PermuteOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermuteOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PermuteOption> CreatePermuteOption(flatbuffers::FlatBufferBuilder &_fbb, const PermuteOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return ace::CreatePermuteOption(
      _fbb,
      _dims);
}

inline ArgMaxOptionT *ArgMaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMaxOptionT>(new ArgMaxOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMaxOption::UnPackTo(ArgMaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outMaxVal(); _o->outMaxVal = _e; }
  { auto _e = topK(); _o->topK = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = softmaxThreshold(); _o->softmaxThreshold = _e; }
}

inline flatbuffers::Offset<ArgMaxOption> ArgMaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxOption> CreateArgMaxOption(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outMaxVal = _o->outMaxVal;
  auto _topK = _o->topK;
  auto _axis = _o->axis;
  auto _softmaxThreshold = _o->softmaxThreshold;
  return ace::CreateArgMaxOption(
      _fbb,
      _outMaxVal,
      _topK,
      _axis,
      _softmaxThreshold);
}

inline BatchNormOptionT *BatchNormOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormOptionT>(new BatchNormOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNormOption::UnPackTo(BatchNormOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; }
  { auto _e = slopeData(); if (_e) { _o->slopeData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slopeData[_i] = _e->Get(_i); } } }
  { auto _e = meanData(); if (_e) { _o->meanData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meanData[_i] = _e->Get(_i); } } }
  { auto _e = varData(); if (_e) { _o->varData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->varData[_i] = _e->Get(_i); } } }
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } }
  { auto _e = Adata(); if (_e) { _o->Adata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Adata[_i] = _e->Get(_i); } } }
  { auto _e = Bdata(); if (_e) { _o->Bdata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Bdata[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<BatchNormOption> BatchNormOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNormOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNormOption> CreateBatchNormOption(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _slopeData = _o->slopeData.size() ? _fbb.CreateVector(_o->slopeData) : 0;
  auto _meanData = _o->meanData.size() ? _fbb.CreateVector(_o->meanData) : 0;
  auto _varData = _o->varData.size() ? _fbb.CreateVector(_o->varData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  auto _Adata = _o->Adata.size() ? _fbb.CreateVector(_o->Adata) : 0;
  auto _Bdata = _o->Bdata.size() ? _fbb.CreateVector(_o->Bdata) : 0;
  auto _epsilon = _o->epsilon;
  return ace::CreateBatchNormOption(
      _fbb,
      _channels,
      _slopeData,
      _meanData,
      _varData,
      _biasData,
      _Adata,
      _Bdata,
      _epsilon);
}

inline Conv2DOptionT *Conv2DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DOptionT>(new Conv2DOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DOption::UnPackTo(Conv2DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; }
  { auto _e = padY(); _o->padY = _e; }
  { auto _e = kernelX(); _o->kernelX = _e; }
  { auto _e = kernelY(); _o->kernelY = _e; }
  { auto _e = strideX(); _o->strideX = _e; }
  { auto _e = strideY(); _o->strideY = _e; }
  { auto _e = dilateX(); _o->dilateX = _e; }
  { auto _e = dilateY(); _o->dilateY = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = inputCount(); _o->inputCount = _e; }
  { auto _e = relu(); _o->relu = _e; }
  { auto _e = relu6(); _o->relu6 = _e; }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = outPads(); if (_e) { _o->outPads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outPads[_i] = _e->Get(_i); } } }
  { auto _e = hasOutputShape(); _o->hasOutputShape = _e; }
}

inline flatbuffers::Offset<Conv2DOption> Conv2DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DOption> CreateConv2DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _dilateX = _o->dilateX;
  auto _dilateY = _o->dilateY;
  auto _padMode = _o->padMode;
  auto _group = _o->group;
  auto _outputCount = _o->outputCount;
  auto _inputCount = _o->inputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _outPads = _o->outPads.size() ? _fbb.CreateVector(_o->outPads) : 0;
  auto _hasOutputShape = _o->hasOutputShape;
  return ace::CreateConv2DOption(
      _fbb,
      _padX,
      _padY,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _dilateX,
      _dilateY,
      _padMode,
      _group,
      _outputCount,
      _inputCount,
      _relu,
      _relu6,
      _pads,
      _outPads,
      _hasOutputShape);
}

inline Conv3DOptionT *Conv3DOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv3DOptionT>(new Conv3DOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv3DOption::UnPackTo(Conv3DOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dilates(); if (_e) { _o->dilates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilates[_i] = _e->Get(_i); } } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = kernels(); if (_e) { _o->kernels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernels[_i] = _e->Get(_i); } } }
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = inputCount(); _o->inputCount = _e; }
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = relu(); _o->relu = _e; }
  { auto _e = relu6(); _o->relu6 = _e; }
}

inline flatbuffers::Offset<Conv3DOption> Conv3DOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv3DOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv3DOption> CreateConv3DOption(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dilates = _o->dilates.size() ? _fbb.CreateVector(_o->dilates) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _kernels = _o->kernels.size() ? _fbb.CreateVector(_o->kernels) : 0;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  auto _padMode = _o->padMode;
  auto _inputCount = _o->inputCount;
  auto _outputCount = _o->outputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  return ace::CreateConv3DOption(
      _fbb,
      _dilates,
      _strides,
      _kernels,
      _pads,
      _padMode,
      _inputCount,
      _outputCount,
      _relu,
      _relu6);
}

inline InnerProductOptionT *InnerProductOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InnerProductOptionT>(new InnerProductOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InnerProductOption::UnPackTo(InnerProductOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; }
  { auto _e = biasTerm(); _o->biasTerm = _e; }
  { auto _e = weightSize(); _o->weightSize = _e; }
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } }
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = transpose(); _o->transpose = _e; }
}

inline flatbuffers::Offset<InnerProductOption> InnerProductOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInnerProductOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InnerProductOption> CreateInnerProductOption(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InnerProductOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _biasTerm = _o->biasTerm;
  auto _weightSize = _o->weightSize;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  auto _transpose = _o->transpose;
  return ace::CreateInnerProductOption(
      _fbb,
      _outputCount,
      _biasTerm,
      _weightSize,
      _weight,
      _bias,
      _axis,
      _transpose);
}

inline LRNOptionT *LRNOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LRNOptionT>(new LRNOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LRNOption::UnPackTo(LRNOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regionType(); _o->regionType = _e; }
  { auto _e = localSize(); _o->localSize = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<LRNOption> LRNOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRNOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRNOption> CreateLRNOption(flatbuffers::FlatBufferBuilder &_fbb, const LRNOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regionType = _o->regionType;
  auto _localSize = _o->localSize;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return ace::CreateLRNOption(
      _fbb,
      _regionType,
      _localSize,
      _alpha,
      _beta);
}

inline NormalizeOptionT *NormalizeOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NormalizeOptionT>(new NormalizeOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NormalizeOption::UnPackTo(NormalizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acrossSpatial(); _o->acrossSpatial = _e; }
  { auto _e = channelShared(); _o->channelShared = _e; }
  { auto _e = eps(); _o->eps = _e; }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<NormalizeOption> NormalizeOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalizeOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormalizeOption> CreateNormalizeOption(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizeOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _acrossSpatial = _o->acrossSpatial;
  auto _channelShared = _o->channelShared;
  auto _eps = _o->eps;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  return ace::CreateNormalizeOption(
      _fbb,
      _acrossSpatial,
      _channelShared,
      _eps,
      _scale);
}

inline PriorBoxOptionT *PriorBoxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriorBoxOptionT>(new PriorBoxOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriorBoxOption::UnPackTo(PriorBoxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = minSizes(); if (_e) { _o->minSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->minSizes[_i] = _e->Get(_i); } } }
  { auto _e = maxSizes(); if (_e) { _o->maxSizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->maxSizes[_i] = _e->Get(_i); } } }
  { auto _e = aspectRatios(); if (_e) { _o->aspectRatios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspectRatios[_i] = _e->Get(_i); } } }
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } }
  { auto _e = flip(); _o->flip = _e; }
  { auto _e = clip(); _o->clip = _e; }
  { auto _e = imageWidth(); _o->imageWidth = _e; }
  { auto _e = imageHeight(); _o->imageHeight = _e; }
  { auto _e = stepWidth(); _o->stepWidth = _e; }
  { auto _e = stepHeight(); _o->stepHeight = _e; }
  { auto _e = offset(); _o->offset = _e; }
}

inline flatbuffers::Offset<PriorBoxOption> PriorBoxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBoxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBoxOption> CreatePriorBoxOption(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _minSizes = _o->minSizes.size() ? _fbb.CreateVector(_o->minSizes) : 0;
  auto _maxSizes = _o->maxSizes.size() ? _fbb.CreateVector(_o->maxSizes) : 0;
  auto _aspectRatios = _o->aspectRatios.size() ? _fbb.CreateVector(_o->aspectRatios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _flip = _o->flip;
  auto _clip = _o->clip;
  auto _imageWidth = _o->imageWidth;
  auto _imageHeight = _o->imageHeight;
  auto _stepWidth = _o->stepWidth;
  auto _stepHeight = _o->stepHeight;
  auto _offset = _o->offset;
  return ace::CreatePriorBoxOption(
      _fbb,
      _minSizes,
      _maxSizes,
      _aspectRatios,
      _variances,
      _flip,
      _clip,
      _imageWidth,
      _imageHeight,
      _stepWidth,
      _stepHeight,
      _offset);
}

inline ProposalOptionT *ProposalOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProposalOptionT>(new ProposalOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProposalOption::UnPackTo(ProposalOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = featStride(); _o->featStride = _e; }
  { auto _e = baseSize(); _o->baseSize = _e; }
  { auto _e = preNmsTopN(); _o->preNmsTopN = _e; }
  { auto _e = afterNmsTopN(); _o->afterNmsTopN = _e; }
  { auto _e = nmsThreshold(); _o->nmsThreshold = _e; }
  { auto _e = minSize(); _o->minSize = _e; }
}

inline flatbuffers::Offset<ProposalOption> ProposalOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposalOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProposalOption> CreateProposalOption(flatbuffers::FlatBufferBuilder &_fbb, const ProposalOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _featStride = _o->featStride;
  auto _baseSize = _o->baseSize;
  auto _preNmsTopN = _o->preNmsTopN;
  auto _afterNmsTopN = _o->afterNmsTopN;
  auto _nmsThreshold = _o->nmsThreshold;
  auto _minSize = _o->minSize;
  return ace::CreateProposalOption(
      _fbb,
      _featStride,
      _baseSize,
      _preNmsTopN,
      _afterNmsTopN,
      _nmsThreshold,
      _minSize);
}

inline ResizeOptionT *ResizeOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeOptionT>(new ResizeOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeOption::UnPackTo(ResizeOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = xScale(); _o->xScale = _e; }
  { auto _e = yScale(); _o->yScale = _e; }
}

inline flatbuffers::Offset<ResizeOption> ResizeOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeOption> CreateResizeOption(flatbuffers::FlatBufferBuilder &_fbb, const ResizeOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _xScale = _o->xScale;
  auto _yScale = _o->yScale;
  return ace::CreateResizeOption(
      _fbb,
      _xScale,
      _yScale);
}

inline RoiPoolingOptionT *RoiPoolingOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoiPoolingOptionT>(new RoiPoolingOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoiPoolingOption::UnPackTo(RoiPoolingOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooledWidth(); _o->pooledWidth = _e; }
  { auto _e = pooledHeight(); _o->pooledHeight = _e; }
  { auto _e = spatialScale(); _o->spatialScale = _e; }
}

inline flatbuffers::Offset<RoiPoolingOption> RoiPoolingOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoiPoolingOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoiPoolingOption> CreateRoiPoolingOption(flatbuffers::FlatBufferBuilder &_fbb, const RoiPoolingOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoiPoolingOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooledWidth = _o->pooledWidth;
  auto _pooledHeight = _o->pooledHeight;
  auto _spatialScale = _o->spatialScale;
  return ace::CreateRoiPoolingOption(
      _fbb,
      _pooledWidth,
      _pooledHeight,
      _spatialScale);
}

inline ScaleOptionT *ScaleOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScaleOptionT>(new ScaleOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScaleOption::UnPackTo(ScaleOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channels(); _o->channels = _e; }
  { auto _e = scaleData(); if (_e) { _o->scaleData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scaleData[_i] = _e->Get(_i); } } }
  { auto _e = biasData(); if (_e) { _o->biasData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->biasData[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ScaleOption> ScaleOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScaleOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScaleOption> CreateScaleOption(flatbuffers::FlatBufferBuilder &_fbb, const ScaleOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channels = _o->channels;
  auto _scaleData = _o->scaleData.size() ? _fbb.CreateVector(_o->scaleData) : 0;
  auto _biasData = _o->biasData.size() ? _fbb.CreateVector(_o->biasData) : 0;
  return ace::CreateScaleOption(
      _fbb,
      _channels,
      _scaleData,
      _biasData);
}

inline SoftmaxOptionT *SoftmaxOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftmaxOptionT>(new SoftmaxOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftmaxOption::UnPackTo(SoftmaxOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<SoftmaxOption> SoftmaxOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxOption> CreateSoftmaxOption(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return ace::CreateSoftmaxOption(
      _fbb,
      _axis);
}

inline InputOptionT *InputOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InputOptionT>(new InputOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InputOption::UnPackTo(InputOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
  { auto _e = dtype(); _o->dtype = _e; }
  { auto _e = dformat(); _o->dformat = _e; }
}

inline flatbuffers::Offset<InputOption> InputOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputOption> CreateInputOption(flatbuffers::FlatBufferBuilder &_fbb, const InputOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _dtype = _o->dtype;
  auto _dformat = _o->dformat;
  return ace::CreateInputOption(
      _fbb,
      _dims,
      _dtype,
      _dformat);
}

inline DefaultOptionT::DefaultOptionT(const DefaultOptionT &o)
      : type(o.type),
        engine(o.engine),
        info(o.info) {
  attr.reserve(o.attr.size());
  for (const auto &attr_ : o.attr) { attr.emplace_back((attr_) ? new ace::AttributeT(*attr_) : nullptr); }
}

inline DefaultOptionT &DefaultOptionT::operator=(DefaultOptionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(engine, o.engine);
  std::swap(info, o.info);
  std::swap(attr, o.attr);
  return *this;
}

inline DefaultOptionT *DefaultOption::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DefaultOptionT>(new DefaultOptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DefaultOption::UnPackTo(DefaultOptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = engine(); if (_e) _o->engine = _e->str(); }
  { auto _e = info(); if (_e) { _o->info.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->info.begin()); } }
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<ace::AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<DefaultOption> DefaultOption::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDefaultOption(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DefaultOption> CreateDefaultOption(flatbuffers::FlatBufferBuilder &_fbb, const DefaultOptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DefaultOptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _engine = _o->engine.empty() ? 0 : _fbb.CreateString(_o->engine);
  auto _info = _o->info.size() ? _fbb.CreateVector(_o->info) : 0;
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<ace::Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ace::CreateDefaultOption(
      _fbb,
      _type,
      _engine,
      _info,
      _attr);
}

inline bool VerifyElementwiseOption(flatbuffers::Verifier &verifier, const void *obj, ElementwiseOption type) {
  switch (type) {
    case ElementwiseOption_NONE: {
      return true;
    }
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<const ace::AbsOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const ace::BoundedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<const ace::ClipOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ace::ClipV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ace::ClippedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<const ace::EluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<const ace::ExpOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const ace::GeluTanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::HardSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const ace::HardSwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const ace::LeakyReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<const ace::LinearOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<const ace::LogOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<const ace::LogisticOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::LogSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<const ace::MishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<const ace::PowOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<const ace::PReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<const ace::ReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<const ace::Relu6Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<const ace::RoundOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<const ace::SeluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const ace::SigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const ace::SoftReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const ace::SoftReluV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<const ace::SqrtOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<const ace::SwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<const ace::TanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<const ace::NoneElementwiseOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyElementwiseOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyElementwiseOption(
        verifier,  values->Get(i), types->GetEnum<ElementwiseOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ElementwiseOptionUnion::UnPack(const void *obj, ElementwiseOption type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<const ace::AbsOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const ace::BoundedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<const ace::ClipOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ace::ClipV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ace::ClippedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<const ace::EluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<const ace::ExpOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const ace::GeluTanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::HardSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const ace::HardSwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const ace::LeakyReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<const ace::LinearOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<const ace::LogOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<const ace::LogisticOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::LogSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<const ace::MishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<const ace::PowOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<const ace::PReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<const ace::ReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<const ace::Relu6Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<const ace::RoundOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<const ace::SeluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const ace::SigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const ace::SoftReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const ace::SoftReluV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<const ace::SqrtOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<const ace::SwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<const ace::TanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<const ace::NoneElementwiseOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ElementwiseOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<const ace::AbsOptionT *>(value);
      return CreateAbsOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const ace::BoundedReluOptionT *>(value);
      return CreateBoundedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<const ace::ClipOptionT *>(value);
      return CreateClipOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ace::ClipV2OptionT *>(value);
      return CreateClipV2Option(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ace::ClippedReluOptionT *>(value);
      return CreateClippedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<const ace::EluOptionT *>(value);
      return CreateEluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<const ace::ExpOptionT *>(value);
      return CreateExpOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const ace::GeluTanhOptionT *>(value);
      return CreateGeluTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::HardSigmoidOptionT *>(value);
      return CreateHardSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const ace::HardSwishOptionT *>(value);
      return CreateHardSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const ace::LeakyReluOptionT *>(value);
      return CreateLeakyReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<const ace::LinearOptionT *>(value);
      return CreateLinearOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<const ace::LogOptionT *>(value);
      return CreateLogOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<const ace::LogisticOptionT *>(value);
      return CreateLogisticOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::LogSigmoidOptionT *>(value);
      return CreateLogSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<const ace::MishOptionT *>(value);
      return CreateMishOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<const ace::PowOptionT *>(value);
      return CreatePowOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<const ace::PReluOptionT *>(value);
      return CreatePReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<const ace::ReluOptionT *>(value);
      return CreateReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<const ace::Relu6OptionT *>(value);
      return CreateRelu6Option(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<const ace::RoundOptionT *>(value);
      return CreateRoundOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<const ace::SeluOptionT *>(value);
      return CreateSeluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const ace::SigmoidOptionT *>(value);
      return CreateSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const ace::SoftReluOptionT *>(value);
      return CreateSoftReluOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const ace::SoftReluV2OptionT *>(value);
      return CreateSoftReluV2Option(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<const ace::SqrtOptionT *>(value);
      return CreateSqrtOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<const ace::SwishOptionT *>(value);
      return CreateSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<const ace::TanhOptionT *>(value);
      return CreateTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<const ace::NoneElementwiseOptionT *>(value);
      return CreateNoneElementwiseOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ElementwiseOptionUnion::ElementwiseOptionUnion(const ElementwiseOptionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ElementwiseOption_AbsOption: {
      value = new ace::AbsOptionT(*reinterpret_cast<ace::AbsOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_BoundedReluOption: {
      value = new ace::BoundedReluOptionT(*reinterpret_cast<ace::BoundedReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ClipOption: {
      value = new ace::ClipOptionT(*reinterpret_cast<ace::ClipOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ClipV2Option: {
      value = new ace::ClipV2OptionT(*reinterpret_cast<ace::ClipV2OptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ClippedReluOption: {
      value = new ace::ClippedReluOptionT(*reinterpret_cast<ace::ClippedReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_EluOption: {
      value = new ace::EluOptionT(*reinterpret_cast<ace::EluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ExpOption: {
      value = new ace::ExpOptionT(*reinterpret_cast<ace::ExpOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_GeluTanhOption: {
      value = new ace::GeluTanhOptionT(*reinterpret_cast<ace::GeluTanhOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_HardSigmoidOption: {
      value = new ace::HardSigmoidOptionT(*reinterpret_cast<ace::HardSigmoidOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_HardSwishOption: {
      value = new ace::HardSwishOptionT(*reinterpret_cast<ace::HardSwishOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LeakyReluOption: {
      value = new ace::LeakyReluOptionT(*reinterpret_cast<ace::LeakyReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LinearOption: {
      value = new ace::LinearOptionT(*reinterpret_cast<ace::LinearOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LogOption: {
      value = new ace::LogOptionT(*reinterpret_cast<ace::LogOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LogisticOption: {
      value = new ace::LogisticOptionT(*reinterpret_cast<ace::LogisticOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_LogSigmoidOption: {
      value = new ace::LogSigmoidOptionT(*reinterpret_cast<ace::LogSigmoidOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_MishOption: {
      value = new ace::MishOptionT(*reinterpret_cast<ace::MishOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_PowOption: {
      value = new ace::PowOptionT(*reinterpret_cast<ace::PowOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_PReluOption: {
      value = new ace::PReluOptionT(*reinterpret_cast<ace::PReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_ReluOption: {
      value = new ace::ReluOptionT(*reinterpret_cast<ace::ReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_Relu6Option: {
      value = new ace::Relu6OptionT(*reinterpret_cast<ace::Relu6OptionT *>(u.value));
      break;
    }
    case ElementwiseOption_RoundOption: {
      value = new ace::RoundOptionT(*reinterpret_cast<ace::RoundOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SeluOption: {
      value = new ace::SeluOptionT(*reinterpret_cast<ace::SeluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SigmoidOption: {
      value = new ace::SigmoidOptionT(*reinterpret_cast<ace::SigmoidOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SoftReluOption: {
      value = new ace::SoftReluOptionT(*reinterpret_cast<ace::SoftReluOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SoftReluV2Option: {
      value = new ace::SoftReluV2OptionT(*reinterpret_cast<ace::SoftReluV2OptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SqrtOption: {
      value = new ace::SqrtOptionT(*reinterpret_cast<ace::SqrtOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_SwishOption: {
      value = new ace::SwishOptionT(*reinterpret_cast<ace::SwishOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_TanhOption: {
      value = new ace::TanhOptionT(*reinterpret_cast<ace::TanhOptionT *>(u.value));
      break;
    }
    case ElementwiseOption_NoneElementwiseOption: {
      value = new ace::NoneElementwiseOptionT(*reinterpret_cast<ace::NoneElementwiseOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ElementwiseOptionUnion::Reset() {
  switch (type) {
    case ElementwiseOption_AbsOption: {
      auto ptr = reinterpret_cast<ace::AbsOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<ace::BoundedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ClipOption: {
      auto ptr = reinterpret_cast<ace::ClipOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ClipV2Option: {
      auto ptr = reinterpret_cast<ace::ClipV2OptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<ace::ClippedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_EluOption: {
      auto ptr = reinterpret_cast<ace::EluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ExpOption: {
      auto ptr = reinterpret_cast<ace::ExpOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<ace::GeluTanhOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<ace::HardSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_HardSwishOption: {
      auto ptr = reinterpret_cast<ace::HardSwishOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<ace::LeakyReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LinearOption: {
      auto ptr = reinterpret_cast<ace::LinearOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LogOption: {
      auto ptr = reinterpret_cast<ace::LogOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LogisticOption: {
      auto ptr = reinterpret_cast<ace::LogisticOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<ace::LogSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_MishOption: {
      auto ptr = reinterpret_cast<ace::MishOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_PowOption: {
      auto ptr = reinterpret_cast<ace::PowOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_PReluOption: {
      auto ptr = reinterpret_cast<ace::PReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_ReluOption: {
      auto ptr = reinterpret_cast<ace::ReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_Relu6Option: {
      auto ptr = reinterpret_cast<ace::Relu6OptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_RoundOption: {
      auto ptr = reinterpret_cast<ace::RoundOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SeluOption: {
      auto ptr = reinterpret_cast<ace::SeluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SigmoidOption: {
      auto ptr = reinterpret_cast<ace::SigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SoftReluOption: {
      auto ptr = reinterpret_cast<ace::SoftReluOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<ace::SoftReluV2OptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SqrtOption: {
      auto ptr = reinterpret_cast<ace::SqrtOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_SwishOption: {
      auto ptr = reinterpret_cast<ace::SwishOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_TanhOption: {
      auto ptr = reinterpret_cast<ace::TanhOptionT *>(value);
      delete ptr;
      break;
    }
    case ElementwiseOption_NoneElementwiseOption: {
      auto ptr = reinterpret_cast<ace::NoneElementwiseOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ElementwiseOption_NONE;
}

inline bool VerifyBinaryOption(flatbuffers::Verifier &verifier, const void *obj, BinaryOption type) {
  switch (type) {
    case BinaryOption_NONE: {
      return true;
    }
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<const ace::AddOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<const ace::MulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<const ace::MinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<const ace::MaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<const ace::MeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<const ace::DivOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const ace::GreaterEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const ace::GreaterThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const ace::LessEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<const ace::LessThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<const ace::EqualToOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const ace::NotEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBinaryOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBinaryOption(
        verifier,  values->Get(i), types->GetEnum<BinaryOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BinaryOptionUnion::UnPack(const void *obj, BinaryOption type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<const ace::AddOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<const ace::MulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<const ace::MinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<const ace::MaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<const ace::MeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<const ace::DivOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const ace::GreaterEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const ace::GreaterThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const ace::LessEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<const ace::LessThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<const ace::EqualToOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const ace::NotEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BinaryOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<const ace::AddOptionT *>(value);
      return CreateAddOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<const ace::MulOptionT *>(value);
      return CreateMulOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<const ace::MinOptionT *>(value);
      return CreateMinOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<const ace::MaxOptionT *>(value);
      return CreateMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<const ace::MeanOptionT *>(value);
      return CreateMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<const ace::DivOptionT *>(value);
      return CreateDivOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const ace::GreaterEqualOptionT *>(value);
      return CreateGreaterEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const ace::GreaterThanOptionT *>(value);
      return CreateGreaterThanOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const ace::LessEqualOptionT *>(value);
      return CreateLessEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<const ace::LessThanOptionT *>(value);
      return CreateLessThanOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<const ace::EqualToOptionT *>(value);
      return CreateEqualToOption(_fbb, ptr, _rehasher).Union();
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const ace::NotEqualOptionT *>(value);
      return CreateNotEqualOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BinaryOptionUnion::BinaryOptionUnion(const BinaryOptionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BinaryOption_AddOption: {
      value = new ace::AddOptionT(*reinterpret_cast<ace::AddOptionT *>(u.value));
      break;
    }
    case BinaryOption_MulOption: {
      value = new ace::MulOptionT(*reinterpret_cast<ace::MulOptionT *>(u.value));
      break;
    }
    case BinaryOption_MinOption: {
      value = new ace::MinOptionT(*reinterpret_cast<ace::MinOptionT *>(u.value));
      break;
    }
    case BinaryOption_MaxOption: {
      value = new ace::MaxOptionT(*reinterpret_cast<ace::MaxOptionT *>(u.value));
      break;
    }
    case BinaryOption_MeanOption: {
      value = new ace::MeanOptionT(*reinterpret_cast<ace::MeanOptionT *>(u.value));
      break;
    }
    case BinaryOption_DivOption: {
      value = new ace::DivOptionT(*reinterpret_cast<ace::DivOptionT *>(u.value));
      break;
    }
    case BinaryOption_GreaterEqualOption: {
      value = new ace::GreaterEqualOptionT(*reinterpret_cast<ace::GreaterEqualOptionT *>(u.value));
      break;
    }
    case BinaryOption_GreaterThanOption: {
      value = new ace::GreaterThanOptionT(*reinterpret_cast<ace::GreaterThanOptionT *>(u.value));
      break;
    }
    case BinaryOption_LessEqualOption: {
      value = new ace::LessEqualOptionT(*reinterpret_cast<ace::LessEqualOptionT *>(u.value));
      break;
    }
    case BinaryOption_LessThanOption: {
      value = new ace::LessThanOptionT(*reinterpret_cast<ace::LessThanOptionT *>(u.value));
      break;
    }
    case BinaryOption_EqualToOption: {
      value = new ace::EqualToOptionT(*reinterpret_cast<ace::EqualToOptionT *>(u.value));
      break;
    }
    case BinaryOption_NotEqualOption: {
      value = new ace::NotEqualOptionT(*reinterpret_cast<ace::NotEqualOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BinaryOptionUnion::Reset() {
  switch (type) {
    case BinaryOption_AddOption: {
      auto ptr = reinterpret_cast<ace::AddOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MulOption: {
      auto ptr = reinterpret_cast<ace::MulOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MinOption: {
      auto ptr = reinterpret_cast<ace::MinOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MaxOption: {
      auto ptr = reinterpret_cast<ace::MaxOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_MeanOption: {
      auto ptr = reinterpret_cast<ace::MeanOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_DivOption: {
      auto ptr = reinterpret_cast<ace::DivOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<ace::GreaterEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<ace::GreaterThanOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_LessEqualOption: {
      auto ptr = reinterpret_cast<ace::LessEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_LessThanOption: {
      auto ptr = reinterpret_cast<ace::LessThanOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_EqualToOption: {
      auto ptr = reinterpret_cast<ace::EqualToOptionT *>(value);
      delete ptr;
      break;
    }
    case BinaryOption_NotEqualOption: {
      auto ptr = reinterpret_cast<ace::NotEqualOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BinaryOption_NONE;
}

inline bool VerifyReduceOption(flatbuffers::Verifier &verifier, const void *obj, ReduceOption type) {
  switch (type) {
    case ReduceOption_NONE: {
      return true;
    }
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ace::ReduceSumOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyReduceOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReduceOption(
        verifier,  values->Get(i), types->GetEnum<ReduceOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ReduceOptionUnion::UnPack(const void *obj, ReduceOption type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ace::ReduceSumOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ReduceOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMinOptionT *>(value);
      return CreateReduceMinOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMaxOptionT *>(value);
      return CreateReduceMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMeanOptionT *>(value);
      return CreateReduceMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ace::ReduceSumOptionT *>(value);
      return CreateReduceSumOption(_fbb, ptr, _rehasher).Union();
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMulOptionT *>(value);
      return CreateReduceMulOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ReduceOptionUnion::ReduceOptionUnion(const ReduceOptionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      value = new ace::ReduceMinOptionT(*reinterpret_cast<ace::ReduceMinOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceMaxOption: {
      value = new ace::ReduceMaxOptionT(*reinterpret_cast<ace::ReduceMaxOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceMeanOption: {
      value = new ace::ReduceMeanOptionT(*reinterpret_cast<ace::ReduceMeanOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceSumOption: {
      value = new ace::ReduceSumOptionT(*reinterpret_cast<ace::ReduceSumOptionT *>(u.value));
      break;
    }
    case ReduceOption_ReduceMulOption: {
      value = new ace::ReduceMulOptionT(*reinterpret_cast<ace::ReduceMulOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ReduceOptionUnion::Reset() {
  switch (type) {
    case ReduceOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<ace::ReduceMinOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<ace::ReduceMaxOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<ace::ReduceMeanOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<ace::ReduceSumOptionT *>(value);
      delete ptr;
      break;
    }
    case ReduceOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<ace::ReduceMulOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ReduceOption_NONE;
}

inline bool VerifyOpOption(flatbuffers::Verifier &verifier, const void *obj, OpOption type) {
  switch (type) {
    case OpOption_NONE: {
      return true;
    }
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<const ace::DefaultOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<const ace::ConstOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<const ace::AbsOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const ace::BoundedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<const ace::ClipOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ace::ClipV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ace::ClippedReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<const ace::EluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<const ace::ExpOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const ace::GeluTanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::HardSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const ace::HardSwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const ace::LeakyReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<const ace::LinearOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<const ace::LogOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<const ace::LogisticOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::LogSigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<const ace::MishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<const ace::PowOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<const ace::PReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<const ace::ReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<const ace::Relu6Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<const ace::RoundOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<const ace::SeluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const ace::SigmoidOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const ace::SoftReluOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const ace::SoftReluV2Option *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<const ace::SqrtOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<const ace::SwishOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<const ace::TanhOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<const ace::AddOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<const ace::MulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<const ace::MinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<const ace::MaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<const ace::MeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<const ace::DivOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const ace::GreaterEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const ace::GreaterThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const ace::LessEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<const ace::LessThanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<const ace::EqualToOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const ace::NotEqualOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMinOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMeanOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ace::ReduceSumOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMulOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<const ace::Pool2DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<const ace::Pool3DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<const ace::ReshapeOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<const ace::SliceOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<const ace::FlattenOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<const ace::PermuteOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<const ace::ArgMaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<const ace::BatchNormOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<const ace::Conv2DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<const ace::Conv3DOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<const ace::InnerProductOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<const ace::LRNOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<const ace::NormalizeOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<const ace::PriorBoxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<const ace::ProposalOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<const ace::ResizeOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<const ace::RoiPoolingOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<const ace::ScaleOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<const ace::SoftmaxOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<const ace::InputOption *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpOptionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpOption(
        verifier,  values->Get(i), types->GetEnum<OpOption>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpOptionUnion::UnPack(const void *obj, OpOption type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<const ace::DefaultOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<const ace::ConstOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<const ace::AbsOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const ace::BoundedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<const ace::ClipOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ace::ClipV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ace::ClippedReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<const ace::EluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<const ace::ExpOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const ace::GeluTanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::HardSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const ace::HardSwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const ace::LeakyReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<const ace::LinearOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<const ace::LogOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<const ace::LogisticOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::LogSigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<const ace::MishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<const ace::PowOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<const ace::PReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<const ace::ReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<const ace::Relu6Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<const ace::RoundOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<const ace::SeluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const ace::SigmoidOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const ace::SoftReluOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const ace::SoftReluV2Option *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<const ace::SqrtOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<const ace::SwishOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<const ace::TanhOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<const ace::AddOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<const ace::MulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<const ace::MinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<const ace::MaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<const ace::MeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<const ace::DivOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const ace::GreaterEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const ace::GreaterThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const ace::LessEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<const ace::LessThanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<const ace::EqualToOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const ace::NotEqualOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMinOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMeanOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ace::ReduceSumOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMulOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<const ace::Pool2DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<const ace::Pool3DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<const ace::ReshapeOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<const ace::SliceOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<const ace::FlattenOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<const ace::PermuteOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<const ace::ArgMaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<const ace::BatchNormOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<const ace::Conv2DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<const ace::Conv3DOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<const ace::InnerProductOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<const ace::LRNOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<const ace::NormalizeOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<const ace::PriorBoxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<const ace::ProposalOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<const ace::ResizeOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<const ace::RoiPoolingOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<const ace::ScaleOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<const ace::SoftmaxOption *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<const ace::InputOption *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OpOptionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<const ace::DefaultOptionT *>(value);
      return CreateDefaultOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<const ace::ConstOptionT *>(value);
      return CreateConstOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<const ace::AbsOptionT *>(value);
      return CreateAbsOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<const ace::BoundedReluOptionT *>(value);
      return CreateBoundedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<const ace::ClipOptionT *>(value);
      return CreateClipOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<const ace::ClipV2OptionT *>(value);
      return CreateClipV2Option(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<const ace::ClippedReluOptionT *>(value);
      return CreateClippedReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<const ace::EluOptionT *>(value);
      return CreateEluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<const ace::ExpOptionT *>(value);
      return CreateExpOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<const ace::GeluTanhOptionT *>(value);
      return CreateGeluTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::HardSigmoidOptionT *>(value);
      return CreateHardSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<const ace::HardSwishOptionT *>(value);
      return CreateHardSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<const ace::LeakyReluOptionT *>(value);
      return CreateLeakyReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<const ace::LinearOptionT *>(value);
      return CreateLinearOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<const ace::LogOptionT *>(value);
      return CreateLogOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<const ace::LogisticOptionT *>(value);
      return CreateLogisticOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<const ace::LogSigmoidOptionT *>(value);
      return CreateLogSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<const ace::MishOptionT *>(value);
      return CreateMishOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<const ace::PowOptionT *>(value);
      return CreatePowOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<const ace::PReluOptionT *>(value);
      return CreatePReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<const ace::ReluOptionT *>(value);
      return CreateReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<const ace::Relu6OptionT *>(value);
      return CreateRelu6Option(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<const ace::RoundOptionT *>(value);
      return CreateRoundOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<const ace::SeluOptionT *>(value);
      return CreateSeluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<const ace::SigmoidOptionT *>(value);
      return CreateSigmoidOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<const ace::SoftReluOptionT *>(value);
      return CreateSoftReluOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<const ace::SoftReluV2OptionT *>(value);
      return CreateSoftReluV2Option(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<const ace::SqrtOptionT *>(value);
      return CreateSqrtOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<const ace::SwishOptionT *>(value);
      return CreateSwishOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<const ace::TanhOptionT *>(value);
      return CreateTanhOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<const ace::AddOptionT *>(value);
      return CreateAddOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<const ace::MulOptionT *>(value);
      return CreateMulOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<const ace::MinOptionT *>(value);
      return CreateMinOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<const ace::MaxOptionT *>(value);
      return CreateMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<const ace::MeanOptionT *>(value);
      return CreateMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<const ace::DivOptionT *>(value);
      return CreateDivOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<const ace::GreaterEqualOptionT *>(value);
      return CreateGreaterEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<const ace::GreaterThanOptionT *>(value);
      return CreateGreaterThanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<const ace::LessEqualOptionT *>(value);
      return CreateLessEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<const ace::LessThanOptionT *>(value);
      return CreateLessThanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<const ace::EqualToOptionT *>(value);
      return CreateEqualToOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<const ace::NotEqualOptionT *>(value);
      return CreateNotEqualOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMinOptionT *>(value);
      return CreateReduceMinOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMaxOptionT *>(value);
      return CreateReduceMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMeanOptionT *>(value);
      return CreateReduceMeanOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<const ace::ReduceSumOptionT *>(value);
      return CreateReduceSumOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<const ace::ReduceMulOptionT *>(value);
      return CreateReduceMulOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<const ace::Pool2DOptionT *>(value);
      return CreatePool2DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<const ace::Pool3DOptionT *>(value);
      return CreatePool3DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<const ace::ReshapeOptionT *>(value);
      return CreateReshapeOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<const ace::SliceOptionT *>(value);
      return CreateSliceOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<const ace::FlattenOptionT *>(value);
      return CreateFlattenOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<const ace::PermuteOptionT *>(value);
      return CreatePermuteOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<const ace::ArgMaxOptionT *>(value);
      return CreateArgMaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<const ace::BatchNormOptionT *>(value);
      return CreateBatchNormOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<const ace::Conv2DOptionT *>(value);
      return CreateConv2DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<const ace::Conv3DOptionT *>(value);
      return CreateConv3DOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<const ace::InnerProductOptionT *>(value);
      return CreateInnerProductOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<const ace::LRNOptionT *>(value);
      return CreateLRNOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<const ace::NormalizeOptionT *>(value);
      return CreateNormalizeOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<const ace::PriorBoxOptionT *>(value);
      return CreatePriorBoxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<const ace::ProposalOptionT *>(value);
      return CreateProposalOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<const ace::ResizeOptionT *>(value);
      return CreateResizeOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<const ace::RoiPoolingOptionT *>(value);
      return CreateRoiPoolingOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<const ace::ScaleOptionT *>(value);
      return CreateScaleOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<const ace::SoftmaxOptionT *>(value);
      return CreateSoftmaxOption(_fbb, ptr, _rehasher).Union();
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<const ace::InputOptionT *>(value);
      return CreateInputOption(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpOptionUnion::OpOptionUnion(const OpOptionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpOption_DefaultOption: {
      value = new ace::DefaultOptionT(*reinterpret_cast<ace::DefaultOptionT *>(u.value));
      break;
    }
    case OpOption_ConstOption: {
      value = new ace::ConstOptionT(*reinterpret_cast<ace::ConstOptionT *>(u.value));
      break;
    }
    case OpOption_AbsOption: {
      value = new ace::AbsOptionT(*reinterpret_cast<ace::AbsOptionT *>(u.value));
      break;
    }
    case OpOption_BoundedReluOption: {
      value = new ace::BoundedReluOptionT(*reinterpret_cast<ace::BoundedReluOptionT *>(u.value));
      break;
    }
    case OpOption_ClipOption: {
      value = new ace::ClipOptionT(*reinterpret_cast<ace::ClipOptionT *>(u.value));
      break;
    }
    case OpOption_ClipV2Option: {
      value = new ace::ClipV2OptionT(*reinterpret_cast<ace::ClipV2OptionT *>(u.value));
      break;
    }
    case OpOption_ClippedReluOption: {
      value = new ace::ClippedReluOptionT(*reinterpret_cast<ace::ClippedReluOptionT *>(u.value));
      break;
    }
    case OpOption_EluOption: {
      value = new ace::EluOptionT(*reinterpret_cast<ace::EluOptionT *>(u.value));
      break;
    }
    case OpOption_ExpOption: {
      value = new ace::ExpOptionT(*reinterpret_cast<ace::ExpOptionT *>(u.value));
      break;
    }
    case OpOption_GeluTanhOption: {
      value = new ace::GeluTanhOptionT(*reinterpret_cast<ace::GeluTanhOptionT *>(u.value));
      break;
    }
    case OpOption_HardSigmoidOption: {
      value = new ace::HardSigmoidOptionT(*reinterpret_cast<ace::HardSigmoidOptionT *>(u.value));
      break;
    }
    case OpOption_HardSwishOption: {
      value = new ace::HardSwishOptionT(*reinterpret_cast<ace::HardSwishOptionT *>(u.value));
      break;
    }
    case OpOption_LeakyReluOption: {
      value = new ace::LeakyReluOptionT(*reinterpret_cast<ace::LeakyReluOptionT *>(u.value));
      break;
    }
    case OpOption_LinearOption: {
      value = new ace::LinearOptionT(*reinterpret_cast<ace::LinearOptionT *>(u.value));
      break;
    }
    case OpOption_LogOption: {
      value = new ace::LogOptionT(*reinterpret_cast<ace::LogOptionT *>(u.value));
      break;
    }
    case OpOption_LogisticOption: {
      value = new ace::LogisticOptionT(*reinterpret_cast<ace::LogisticOptionT *>(u.value));
      break;
    }
    case OpOption_LogSigmoidOption: {
      value = new ace::LogSigmoidOptionT(*reinterpret_cast<ace::LogSigmoidOptionT *>(u.value));
      break;
    }
    case OpOption_MishOption: {
      value = new ace::MishOptionT(*reinterpret_cast<ace::MishOptionT *>(u.value));
      break;
    }
    case OpOption_PowOption: {
      value = new ace::PowOptionT(*reinterpret_cast<ace::PowOptionT *>(u.value));
      break;
    }
    case OpOption_PReluOption: {
      value = new ace::PReluOptionT(*reinterpret_cast<ace::PReluOptionT *>(u.value));
      break;
    }
    case OpOption_ReluOption: {
      value = new ace::ReluOptionT(*reinterpret_cast<ace::ReluOptionT *>(u.value));
      break;
    }
    case OpOption_Relu6Option: {
      value = new ace::Relu6OptionT(*reinterpret_cast<ace::Relu6OptionT *>(u.value));
      break;
    }
    case OpOption_RoundOption: {
      value = new ace::RoundOptionT(*reinterpret_cast<ace::RoundOptionT *>(u.value));
      break;
    }
    case OpOption_SeluOption: {
      value = new ace::SeluOptionT(*reinterpret_cast<ace::SeluOptionT *>(u.value));
      break;
    }
    case OpOption_SigmoidOption: {
      value = new ace::SigmoidOptionT(*reinterpret_cast<ace::SigmoidOptionT *>(u.value));
      break;
    }
    case OpOption_SoftReluOption: {
      value = new ace::SoftReluOptionT(*reinterpret_cast<ace::SoftReluOptionT *>(u.value));
      break;
    }
    case OpOption_SoftReluV2Option: {
      value = new ace::SoftReluV2OptionT(*reinterpret_cast<ace::SoftReluV2OptionT *>(u.value));
      break;
    }
    case OpOption_SqrtOption: {
      value = new ace::SqrtOptionT(*reinterpret_cast<ace::SqrtOptionT *>(u.value));
      break;
    }
    case OpOption_SwishOption: {
      value = new ace::SwishOptionT(*reinterpret_cast<ace::SwishOptionT *>(u.value));
      break;
    }
    case OpOption_TanhOption: {
      value = new ace::TanhOptionT(*reinterpret_cast<ace::TanhOptionT *>(u.value));
      break;
    }
    case OpOption_AddOption: {
      value = new ace::AddOptionT(*reinterpret_cast<ace::AddOptionT *>(u.value));
      break;
    }
    case OpOption_MulOption: {
      value = new ace::MulOptionT(*reinterpret_cast<ace::MulOptionT *>(u.value));
      break;
    }
    case OpOption_MinOption: {
      value = new ace::MinOptionT(*reinterpret_cast<ace::MinOptionT *>(u.value));
      break;
    }
    case OpOption_MaxOption: {
      value = new ace::MaxOptionT(*reinterpret_cast<ace::MaxOptionT *>(u.value));
      break;
    }
    case OpOption_MeanOption: {
      value = new ace::MeanOptionT(*reinterpret_cast<ace::MeanOptionT *>(u.value));
      break;
    }
    case OpOption_DivOption: {
      value = new ace::DivOptionT(*reinterpret_cast<ace::DivOptionT *>(u.value));
      break;
    }
    case OpOption_GreaterEqualOption: {
      value = new ace::GreaterEqualOptionT(*reinterpret_cast<ace::GreaterEqualOptionT *>(u.value));
      break;
    }
    case OpOption_GreaterThanOption: {
      value = new ace::GreaterThanOptionT(*reinterpret_cast<ace::GreaterThanOptionT *>(u.value));
      break;
    }
    case OpOption_LessEqualOption: {
      value = new ace::LessEqualOptionT(*reinterpret_cast<ace::LessEqualOptionT *>(u.value));
      break;
    }
    case OpOption_LessThanOption: {
      value = new ace::LessThanOptionT(*reinterpret_cast<ace::LessThanOptionT *>(u.value));
      break;
    }
    case OpOption_EqualToOption: {
      value = new ace::EqualToOptionT(*reinterpret_cast<ace::EqualToOptionT *>(u.value));
      break;
    }
    case OpOption_NotEqualOption: {
      value = new ace::NotEqualOptionT(*reinterpret_cast<ace::NotEqualOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMinOption: {
      value = new ace::ReduceMinOptionT(*reinterpret_cast<ace::ReduceMinOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMaxOption: {
      value = new ace::ReduceMaxOptionT(*reinterpret_cast<ace::ReduceMaxOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMeanOption: {
      value = new ace::ReduceMeanOptionT(*reinterpret_cast<ace::ReduceMeanOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceSumOption: {
      value = new ace::ReduceSumOptionT(*reinterpret_cast<ace::ReduceSumOptionT *>(u.value));
      break;
    }
    case OpOption_ReduceMulOption: {
      value = new ace::ReduceMulOptionT(*reinterpret_cast<ace::ReduceMulOptionT *>(u.value));
      break;
    }
    case OpOption_Pool2DOption: {
      value = new ace::Pool2DOptionT(*reinterpret_cast<ace::Pool2DOptionT *>(u.value));
      break;
    }
    case OpOption_Pool3DOption: {
      value = new ace::Pool3DOptionT(*reinterpret_cast<ace::Pool3DOptionT *>(u.value));
      break;
    }
    case OpOption_ReshapeOption: {
      value = new ace::ReshapeOptionT(*reinterpret_cast<ace::ReshapeOptionT *>(u.value));
      break;
    }
    case OpOption_SliceOption: {
      value = new ace::SliceOptionT(*reinterpret_cast<ace::SliceOptionT *>(u.value));
      break;
    }
    case OpOption_FlattenOption: {
      value = new ace::FlattenOptionT(*reinterpret_cast<ace::FlattenOptionT *>(u.value));
      break;
    }
    case OpOption_PermuteOption: {
      value = new ace::PermuteOptionT(*reinterpret_cast<ace::PermuteOptionT *>(u.value));
      break;
    }
    case OpOption_ArgMaxOption: {
      value = new ace::ArgMaxOptionT(*reinterpret_cast<ace::ArgMaxOptionT *>(u.value));
      break;
    }
    case OpOption_BatchNormOption: {
      value = new ace::BatchNormOptionT(*reinterpret_cast<ace::BatchNormOptionT *>(u.value));
      break;
    }
    case OpOption_Conv2DOption: {
      value = new ace::Conv2DOptionT(*reinterpret_cast<ace::Conv2DOptionT *>(u.value));
      break;
    }
    case OpOption_Conv3DOption: {
      value = new ace::Conv3DOptionT(*reinterpret_cast<ace::Conv3DOptionT *>(u.value));
      break;
    }
    case OpOption_InnerProductOption: {
      value = new ace::InnerProductOptionT(*reinterpret_cast<ace::InnerProductOptionT *>(u.value));
      break;
    }
    case OpOption_LRNOption: {
      value = new ace::LRNOptionT(*reinterpret_cast<ace::LRNOptionT *>(u.value));
      break;
    }
    case OpOption_NormalizeOption: {
      value = new ace::NormalizeOptionT(*reinterpret_cast<ace::NormalizeOptionT *>(u.value));
      break;
    }
    case OpOption_PriorBoxOption: {
      value = new ace::PriorBoxOptionT(*reinterpret_cast<ace::PriorBoxOptionT *>(u.value));
      break;
    }
    case OpOption_ProposalOption: {
      value = new ace::ProposalOptionT(*reinterpret_cast<ace::ProposalOptionT *>(u.value));
      break;
    }
    case OpOption_ResizeOption: {
      value = new ace::ResizeOptionT(*reinterpret_cast<ace::ResizeOptionT *>(u.value));
      break;
    }
    case OpOption_RoiPoolingOption: {
      value = new ace::RoiPoolingOptionT(*reinterpret_cast<ace::RoiPoolingOptionT *>(u.value));
      break;
    }
    case OpOption_ScaleOption: {
      value = new ace::ScaleOptionT(*reinterpret_cast<ace::ScaleOptionT *>(u.value));
      break;
    }
    case OpOption_SoftmaxOption: {
      value = new ace::SoftmaxOptionT(*reinterpret_cast<ace::SoftmaxOptionT *>(u.value));
      break;
    }
    case OpOption_InputOption: {
      value = new ace::InputOptionT(*reinterpret_cast<ace::InputOptionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpOptionUnion::Reset() {
  switch (type) {
    case OpOption_DefaultOption: {
      auto ptr = reinterpret_cast<ace::DefaultOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ConstOption: {
      auto ptr = reinterpret_cast<ace::ConstOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_AbsOption: {
      auto ptr = reinterpret_cast<ace::AbsOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_BoundedReluOption: {
      auto ptr = reinterpret_cast<ace::BoundedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ClipOption: {
      auto ptr = reinterpret_cast<ace::ClipOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ClipV2Option: {
      auto ptr = reinterpret_cast<ace::ClipV2OptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ClippedReluOption: {
      auto ptr = reinterpret_cast<ace::ClippedReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_EluOption: {
      auto ptr = reinterpret_cast<ace::EluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ExpOption: {
      auto ptr = reinterpret_cast<ace::ExpOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_GeluTanhOption: {
      auto ptr = reinterpret_cast<ace::GeluTanhOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_HardSigmoidOption: {
      auto ptr = reinterpret_cast<ace::HardSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_HardSwishOption: {
      auto ptr = reinterpret_cast<ace::HardSwishOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LeakyReluOption: {
      auto ptr = reinterpret_cast<ace::LeakyReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LinearOption: {
      auto ptr = reinterpret_cast<ace::LinearOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LogOption: {
      auto ptr = reinterpret_cast<ace::LogOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LogisticOption: {
      auto ptr = reinterpret_cast<ace::LogisticOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LogSigmoidOption: {
      auto ptr = reinterpret_cast<ace::LogSigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MishOption: {
      auto ptr = reinterpret_cast<ace::MishOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PowOption: {
      auto ptr = reinterpret_cast<ace::PowOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PReluOption: {
      auto ptr = reinterpret_cast<ace::PReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReluOption: {
      auto ptr = reinterpret_cast<ace::ReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Relu6Option: {
      auto ptr = reinterpret_cast<ace::Relu6OptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_RoundOption: {
      auto ptr = reinterpret_cast<ace::RoundOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SeluOption: {
      auto ptr = reinterpret_cast<ace::SeluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SigmoidOption: {
      auto ptr = reinterpret_cast<ace::SigmoidOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SoftReluOption: {
      auto ptr = reinterpret_cast<ace::SoftReluOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SoftReluV2Option: {
      auto ptr = reinterpret_cast<ace::SoftReluV2OptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SqrtOption: {
      auto ptr = reinterpret_cast<ace::SqrtOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SwishOption: {
      auto ptr = reinterpret_cast<ace::SwishOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_TanhOption: {
      auto ptr = reinterpret_cast<ace::TanhOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_AddOption: {
      auto ptr = reinterpret_cast<ace::AddOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MulOption: {
      auto ptr = reinterpret_cast<ace::MulOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MinOption: {
      auto ptr = reinterpret_cast<ace::MinOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MaxOption: {
      auto ptr = reinterpret_cast<ace::MaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_MeanOption: {
      auto ptr = reinterpret_cast<ace::MeanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_DivOption: {
      auto ptr = reinterpret_cast<ace::DivOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_GreaterEqualOption: {
      auto ptr = reinterpret_cast<ace::GreaterEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_GreaterThanOption: {
      auto ptr = reinterpret_cast<ace::GreaterThanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LessEqualOption: {
      auto ptr = reinterpret_cast<ace::LessEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LessThanOption: {
      auto ptr = reinterpret_cast<ace::LessThanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_EqualToOption: {
      auto ptr = reinterpret_cast<ace::EqualToOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_NotEqualOption: {
      auto ptr = reinterpret_cast<ace::NotEqualOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMinOption: {
      auto ptr = reinterpret_cast<ace::ReduceMinOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMaxOption: {
      auto ptr = reinterpret_cast<ace::ReduceMaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMeanOption: {
      auto ptr = reinterpret_cast<ace::ReduceMeanOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceSumOption: {
      auto ptr = reinterpret_cast<ace::ReduceSumOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReduceMulOption: {
      auto ptr = reinterpret_cast<ace::ReduceMulOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Pool2DOption: {
      auto ptr = reinterpret_cast<ace::Pool2DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Pool3DOption: {
      auto ptr = reinterpret_cast<ace::Pool3DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ReshapeOption: {
      auto ptr = reinterpret_cast<ace::ReshapeOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SliceOption: {
      auto ptr = reinterpret_cast<ace::SliceOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_FlattenOption: {
      auto ptr = reinterpret_cast<ace::FlattenOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PermuteOption: {
      auto ptr = reinterpret_cast<ace::PermuteOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ArgMaxOption: {
      auto ptr = reinterpret_cast<ace::ArgMaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_BatchNormOption: {
      auto ptr = reinterpret_cast<ace::BatchNormOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Conv2DOption: {
      auto ptr = reinterpret_cast<ace::Conv2DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_Conv3DOption: {
      auto ptr = reinterpret_cast<ace::Conv3DOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_InnerProductOption: {
      auto ptr = reinterpret_cast<ace::InnerProductOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_LRNOption: {
      auto ptr = reinterpret_cast<ace::LRNOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_NormalizeOption: {
      auto ptr = reinterpret_cast<ace::NormalizeOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_PriorBoxOption: {
      auto ptr = reinterpret_cast<ace::PriorBoxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ProposalOption: {
      auto ptr = reinterpret_cast<ace::ProposalOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ResizeOption: {
      auto ptr = reinterpret_cast<ace::ResizeOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_RoiPoolingOption: {
      auto ptr = reinterpret_cast<ace::RoiPoolingOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_ScaleOption: {
      auto ptr = reinterpret_cast<ace::ScaleOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_SoftmaxOption: {
      auto ptr = reinterpret_cast<ace::SoftmaxOptionT *>(value);
      delete ptr;
      break;
    }
    case OpOption_InputOption: {
      auto ptr = reinterpret_cast<ace::InputOptionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpOption_NONE;
}

inline const flatbuffers::TypeTable *ElementwiseOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::AbsOptionTypeTable,
    ace::BoundedReluOptionTypeTable,
    ace::ClipOptionTypeTable,
    ace::ClipV2OptionTypeTable,
    ace::ClippedReluOptionTypeTable,
    ace::EluOptionTypeTable,
    ace::ExpOptionTypeTable,
    ace::GeluTanhOptionTypeTable,
    ace::HardSigmoidOptionTypeTable,
    ace::HardSwishOptionTypeTable,
    ace::LeakyReluOptionTypeTable,
    ace::LinearOptionTypeTable,
    ace::LogOptionTypeTable,
    ace::LogisticOptionTypeTable,
    ace::LogSigmoidOptionTypeTable,
    ace::MishOptionTypeTable,
    ace::PowOptionTypeTable,
    ace::PReluOptionTypeTable,
    ace::ReluOptionTypeTable,
    ace::Relu6OptionTypeTable,
    ace::RoundOptionTypeTable,
    ace::SeluOptionTypeTable,
    ace::SigmoidOptionTypeTable,
    ace::SoftReluOptionTypeTable,
    ace::SoftReluV2OptionTypeTable,
    ace::SqrtOptionTypeTable,
    ace::SwishOptionTypeTable,
    ace::TanhOptionTypeTable,
    ace::NoneElementwiseOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "NoneElementwiseOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 30, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::AddOptionTypeTable,
    ace::MulOptionTypeTable,
    ace::MinOptionTypeTable,
    ace::MaxOptionTypeTable,
    ace::MeanOptionTypeTable,
    ace::DivOptionTypeTable,
    ace::GreaterEqualOptionTypeTable,
    ace::GreaterThanOptionTypeTable,
    ace::LessEqualOptionTypeTable,
    ace::LessThanOptionTypeTable,
    ace::EqualToOptionTypeTable,
    ace::NotEqualOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::ReduceMinOptionTypeTable,
    ace::ReduceMaxOptionTypeTable,
    ace::ReduceMeanOptionTypeTable,
    ace::ReduceSumOptionTypeTable,
    ace::ReduceMulOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAX_POOL",
    "AVG_POOL",
    "GLOBAL_MAX_POOL",
    "GLOBAL_AVG_POOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PaddingTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PaddingTypeTypeTable
  };
  static const char * const names[] = {
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DefaultOptionTypeTable,
    ace::ConstOptionTypeTable,
    ace::AbsOptionTypeTable,
    ace::BoundedReluOptionTypeTable,
    ace::ClipOptionTypeTable,
    ace::ClipV2OptionTypeTable,
    ace::ClippedReluOptionTypeTable,
    ace::EluOptionTypeTable,
    ace::ExpOptionTypeTable,
    ace::GeluTanhOptionTypeTable,
    ace::HardSigmoidOptionTypeTable,
    ace::HardSwishOptionTypeTable,
    ace::LeakyReluOptionTypeTable,
    ace::LinearOptionTypeTable,
    ace::LogOptionTypeTable,
    ace::LogisticOptionTypeTable,
    ace::LogSigmoidOptionTypeTable,
    ace::MishOptionTypeTable,
    ace::PowOptionTypeTable,
    ace::PReluOptionTypeTable,
    ace::ReluOptionTypeTable,
    ace::Relu6OptionTypeTable,
    ace::RoundOptionTypeTable,
    ace::SeluOptionTypeTable,
    ace::SigmoidOptionTypeTable,
    ace::SoftReluOptionTypeTable,
    ace::SoftReluV2OptionTypeTable,
    ace::SqrtOptionTypeTable,
    ace::SwishOptionTypeTable,
    ace::TanhOptionTypeTable,
    ace::AddOptionTypeTable,
    ace::MulOptionTypeTable,
    ace::MinOptionTypeTable,
    ace::MaxOptionTypeTable,
    ace::MeanOptionTypeTable,
    ace::DivOptionTypeTable,
    ace::GreaterEqualOptionTypeTable,
    ace::GreaterThanOptionTypeTable,
    ace::LessEqualOptionTypeTable,
    ace::LessThanOptionTypeTable,
    ace::EqualToOptionTypeTable,
    ace::NotEqualOptionTypeTable,
    ace::ReduceMinOptionTypeTable,
    ace::ReduceMaxOptionTypeTable,
    ace::ReduceMeanOptionTypeTable,
    ace::ReduceSumOptionTypeTable,
    ace::ReduceMulOptionTypeTable,
    ace::Pool2DOptionTypeTable,
    ace::Pool3DOptionTypeTable,
    ace::ReshapeOptionTypeTable,
    ace::SliceOptionTypeTable,
    ace::FlattenOptionTypeTable,
    ace::PermuteOptionTypeTable,
    ace::ArgMaxOptionTypeTable,
    ace::BatchNormOptionTypeTable,
    ace::Conv2DOptionTypeTable,
    ace::Conv3DOptionTypeTable,
    ace::InnerProductOptionTypeTable,
    ace::LRNOptionTypeTable,
    ace::NormalizeOptionTypeTable,
    ace::PriorBoxOptionTypeTable,
    ace::ProposalOptionTypeTable,
    ace::ResizeOptionTypeTable,
    ace::RoiPoolingOptionTypeTable,
    ace::ScaleOptionTypeTable,
    ace::SoftmaxOptionTypeTable,
    ace::InputOptionTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "DefaultOption",
    "ConstOption",
    "AbsOption",
    "BoundedReluOption",
    "ClipOption",
    "ClipV2Option",
    "ClippedReluOption",
    "EluOption",
    "ExpOption",
    "GeluTanhOption",
    "HardSigmoidOption",
    "HardSwishOption",
    "LeakyReluOption",
    "LinearOption",
    "LogOption",
    "LogisticOption",
    "LogSigmoidOption",
    "MishOption",
    "PowOption",
    "PReluOption",
    "ReluOption",
    "Relu6Option",
    "RoundOption",
    "SeluOption",
    "SigmoidOption",
    "SoftReluOption",
    "SoftReluV2Option",
    "SqrtOption",
    "SwishOption",
    "TanhOption",
    "AddOption",
    "MulOption",
    "MinOption",
    "MaxOption",
    "MeanOption",
    "DivOption",
    "GreaterEqualOption",
    "GreaterThanOption",
    "LessEqualOption",
    "LessThanOption",
    "EqualToOption",
    "NotEqualOption",
    "ReduceMinOption",
    "ReduceMaxOption",
    "ReduceMeanOption",
    "ReduceSumOption",
    "ReduceMulOption",
    "Pool2DOption",
    "Pool3DOption",
    "ReshapeOption",
    "SliceOption",
    "FlattenOption",
    "PermuteOption",
    "ArgMaxOption",
    "BatchNormOption",
    "Conv2DOption",
    "Conv3DOption",
    "InnerProductOption",
    "LRNOption",
    "NormalizeOption",
    "PriorBoxOption",
    "ProposalOption",
    "ResizeOption",
    "RoiPoolingOption",
    "ScaleOption",
    "SoftmaxOption",
    "InputOption"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 68, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AbsOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BoundedReluOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClipOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClipV2OptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeluTanhOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HardSigmoidOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HardSwishOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LinearOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogisticOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MishOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "slopeCount",
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Relu6OptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minval",
    "maxval"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClippedReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "threashod"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LeakyReluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "negative_slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogSigmoidOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoundOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SeluOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "scale",
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SigmoidOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftReluOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftReluV2OptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqrtOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SwishOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TanhOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConstOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::TensorProtoTypeTable
  };
  static const char * const names[] = {
    "tensor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NoneElementwiseOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaxOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MeanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterThanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessEqualOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessThanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EqualToOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NotEqualOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMinOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMaxOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMeanOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceSumOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceMulOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool2DOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PoolTypeTypeTable,
    ace::PaddingTypeTypeTable
  };
  static const char * const names[] = {
    "size",
    "type",
    "strides",
    "padding",
    "padtype",
    "global_pooling",
    "ceil_mode",
    "exclusive"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pool3DOptionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DataFormatTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dimType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::FrontendFrameworkTypeTable
  };
  static const char * const names[] = {
    "axis",
    "slicePoints",
    "sourceType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis",
    "endAxis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PermuteOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outMaxVal",
    "topK",
    "axis",
    "softmaxThreshold"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "channels",
    "slopeData",
    "meanData",
    "varData",
    "biasData",
    "Adata",
    "Bdata",
    "epsilon"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PadModeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "dilateX",
    "dilateY",
    "padMode",
    "group",
    "outputCount",
    "inputCount",
    "relu",
    "relu6",
    "pads",
    "outPads",
    "hasOutputShape"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv3DOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::PadModeTypeTable
  };
  static const char * const names[] = {
    "dilates",
    "strides",
    "kernels",
    "pads",
    "padMode",
    "inputCount",
    "outputCount",
    "relu",
    "relu6"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InnerProductOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "outputCount",
    "biasTerm",
    "weightSize",
    "weight",
    "bias",
    "axis",
    "transpose"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "regionType",
    "localSize",
    "alpha",
    "beta"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NormalizeOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "acrossSpatial",
    "channelShared",
    "eps",
    "scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "minSizes",
    "maxSizes",
    "aspectRatios",
    "variances",
    "flip",
    "clip",
    "imageWidth",
    "imageHeight",
    "stepWidth",
    "stepHeight",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProposalOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "featStride",
    "baseSize",
    "preNmsTopN",
    "afterNmsTopN",
    "nmsThreshold",
    "minSize"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "xScale",
    "yScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoiPoolingOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "pooledWidth",
    "pooledHeight",
    "spatialScale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "channels",
    "scaleData",
    "biasData"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::DataTypeTypeTable,
    ace::DataFormatTypeTable
  };
  static const char * const names[] = {
    "dims",
    "dtype",
    "dformat"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DefaultOptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ace::AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "engine",
    "info",
    "attr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace ace

#endif  // FLATBUFFERS_GENERATED_OPOPTION_ACE_H_
